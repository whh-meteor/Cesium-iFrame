(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["Cesium~ecc0699a"],{"4f77":function(a,t,n){"use strict";var e=n("535a"),o=n("2f63");function i(a,t,n){this.heading=Object(e["a"])(a,0),this.pitch=Object(e["a"])(t,0),this.range=Object(e["a"])(n,0)}i.clone=function(a,t){if(Object(o["a"])(a))return Object(o["a"])(t)||(t=new i),t.heading=a.heading,t.pitch=a.pitch,t.range=a.range,t},t["a"]=i},"69e5":function(a,t,n){"use strict";var e=n("dd06"),o=n("9201"),i=n("ee1e"),c=n("cef5"),r=n("be18"),s=n("bef8"),l=n("abab"),u=n("535a"),p=n("2f63"),d=n("c52f"),h=n("1e13"),g=n("cef8"),w=n("6cbd"),f=n("3d7f"),y=n("d2c7"),O=n("81d7"),E=n("5410"),m=n("93da"),b=n("df07"),k=n("188e"),j=n("0260"),P=n("eace"),I=n("1184");const S=[f["a"],I["a"]],_=S.length,A=Math.cos(m["a"].toRadians(30)),N=Math.cos(m["a"].toRadians(150)),T=0,L=1e3;function z(a){a=Object(u["a"])(a,u["a"].EMPTY_OBJECT);const t=a.positions;this.width=Object(u["a"])(a.width,1),this._positions=t,this.granularity=Object(u["a"])(a.granularity,9999),this.loop=Object(u["a"])(a.loop,!1),this.arcType=Object(u["a"])(a.arcType,o["a"].GEODESIC),this._ellipsoid=d["a"].WGS84,this._projectionIndex=0,this._workerName="createGroundPolylineGeometry",this._scene3DOnly=!1}Object.defineProperties(z.prototype,{packedLength:{get:function(){return 1+3*this._positions.length+1+1+1+d["a"].packedLength+1+1}}}),z.setProjectionAndEllipsoid=function(a,t){let n=0;for(let e=0;e<_;e++)if(t instanceof S[e]){n=e;break}a._projectionIndex=n,a._ellipsoid=t.ellipsoid};const x=new r["a"],D=new r["a"],C=new r["a"];function q(a,t,n,e,o){const i=v(e,a,0,x),c=v(e,a,n,D),s=v(e,t,0,C),l=H(c,i,D),u=H(s,i,C);return r["a"].cross(u,l,o),r["a"].normalize(o,o)}const R=new s["a"],M=new r["a"],F=new r["a"],B=new r["a"];function G(a,t,n,e,i,c,s,l,u,p,d){if(0===i)return;let w;c===o["a"].GEODESIC?w=new h["a"](a,t,s):c===o["a"].RHUMB&&(w=new g["a"](a,t,s));const f=w.surfaceDistance;if(f<i)return;const y=q(a,t,e,s,B),O=Math.ceil(f/i),E=f/O;let m=E;const b=O-1;let k=l.length;for(let o=0;o<b;o++){const a=w.interpolateUsingSurfaceDistance(m,R),t=v(s,a,n,M),o=v(s,a,e,F);r["a"].pack(y,l,k),r["a"].pack(t,u,k),r["a"].pack(o,p,k),d.push(a.latitude),d.push(a.longitude),k+=3,m+=E}}const U=new s["a"];function v(a,t,n,e){return s["a"].clone(t,U),U.height=n,s["a"].toCartesian(U,a,e)}function H(a,t,n){return r["a"].subtract(a,t,n),r["a"].normalize(n,n),n}function V(a,t,n,e){return e=H(a,t,e),e=r["a"].cross(e,n,e),e=r["a"].normalize(e,e),e=r["a"].cross(n,e,e),e}z.pack=function(a,t,n){let e=Object(u["a"])(n,0);const o=a._positions,i=o.length;t[e++]=i;for(let c=0;c<i;++c){const a=o[c];r["a"].pack(a,t,e),e+=3}return t[e++]=a.granularity,t[e++]=a.loop?1:0,t[e++]=a.arcType,d["a"].pack(a._ellipsoid,t,e),e+=d["a"].packedLength,t[e++]=a._projectionIndex,t[e++]=a._scene3DOnly?1:0,t},z.unpack=function(a,t,n){let e=Object(u["a"])(t,0);const o=a[e++],i=new Array(o);for(let u=0;u<o;u++)i[u]=r["a"].unpack(a,e),e+=3;const c=a[e++],s=1===a[e++],l=a[e++],h=d["a"].unpack(a,e);e+=d["a"].packedLength;const g=a[e++],w=1===a[e++];return Object(p["a"])(n)||(n=new z({positions:i})),n._positions=i,n.granularity=c,n.loop=s,n.arcType=l,n._ellipsoid=h,n._projectionIndex=g,n._scene3DOnly=w,n};const W=new r["a"],Y=new r["a"],Z=new r["a"],J=new r["a"],$=0,Q=-1;function X(a,t,n,e,o){const i=H(n,t,J),c=V(a,t,i,W),s=V(e,t,i,Y);if(m["a"].equalsEpsilon(r["a"].dot(c,s),Q,m["a"].EPSILON5))return o=r["a"].cross(i,c,o),o=r["a"].normalize(o,o),o;o=r["a"].add(s,c,o),o=r["a"].normalize(o,o);const l=r["a"].cross(i,o,Z);return r["a"].dot(s,l)<$&&(o=r["a"].negate(o,o)),o}const K=k["a"].fromPointNormal(r["a"].ZERO,r["a"].UNIT_Y),aa=new r["a"],ta=new r["a"],na=new r["a"],ea=new r["a"],oa=new r["a"],ia=new r["a"],ca=new s["a"],ra=new s["a"],sa=new s["a"];z.createGeometry=function(a){const t=!a._scene3DOnly;let n=a.loop;const e=a._ellipsoid,c=a.granularity,l=a.arcType,u=new S[a._projectionIndex](e),d=T,h=L;let w,f;const y=a._positions,O=y.length;let b,k,j,P;2===O&&(n=!1);const I=new g["a"](void 0,void 0,e);let _,A,N;const z=[y[0]];for(f=0;f<O-1;f++)b=y[f],k=y[f+1],_=E["a"].lineSegmentPlane(b,k,K,ia),!Object(p["a"])(_)||r["a"].equalsEpsilon(_,b,m["a"].EPSILON7)||r["a"].equalsEpsilon(_,k,m["a"].EPSILON7)||(a.arcType===o["a"].GEODESIC?z.push(r["a"].clone(_)):a.arcType===o["a"].RHUMB&&(N=e.cartesianToCartographic(_,ca).longitude,j=e.cartesianToCartographic(b,ca),P=e.cartesianToCartographic(k,ra),I.setEndPoints(j,P),A=I.findIntersectionWithLongitude(N,sa),_=e.cartographicToCartesian(A,ia),!Object(p["a"])(_)||r["a"].equalsEpsilon(_,b,m["a"].EPSILON7)||r["a"].equalsEpsilon(_,k,m["a"].EPSILON7)||z.push(r["a"].clone(_)))),z.push(k);n&&(b=y[O-1],k=y[0],_=E["a"].lineSegmentPlane(b,k,K,ia),!Object(p["a"])(_)||r["a"].equalsEpsilon(_,b,m["a"].EPSILON7)||r["a"].equalsEpsilon(_,k,m["a"].EPSILON7)||(a.arcType===o["a"].GEODESIC?z.push(r["a"].clone(_)):a.arcType===o["a"].RHUMB&&(N=e.cartesianToCartographic(_,ca).longitude,j=e.cartesianToCartographic(b,ca),P=e.cartesianToCartographic(k,ra),I.setEndPoints(j,P),A=I.findIntersectionWithLongitude(N,sa),_=e.cartographicToCartesian(A,ia),!Object(p["a"])(_)||r["a"].equalsEpsilon(_,b,m["a"].EPSILON7)||r["a"].equalsEpsilon(_,k,m["a"].EPSILON7)||z.push(r["a"].clone(_)))));let x=z.length,D=new Array(x);for(f=0;f<x;f++){const a=s["a"].fromCartesian(z[f],e);a.height=0,D[f]=a}if(D=Object(i["a"])(D,s["a"].equalsEpsilon),x=D.length,x<2)return;const C=[],R=[],M=[],F=[];let B=aa,U=ta,H=na,V=ea,W=oa;const Y=D[0],Z=D[1],J=D[x-1];for(B=v(e,J,d,B),V=v(e,Z,d,V),U=v(e,Y,d,U),H=v(e,Y,h,H),W=n?X(B,U,H,V,W):q(Y,Z,h,e,W),r["a"].pack(W,R,0),r["a"].pack(U,M,0),r["a"].pack(H,F,0),C.push(Y.latitude),C.push(Y.longitude),G(Y,Z,d,h,c,l,e,R,M,F,C),f=1;f<x-1;++f){B=r["a"].clone(U,B),U=r["a"].clone(V,U);const a=D[f];v(e,a,h,H),v(e,D[f+1],d,V),X(B,U,H,V,W),w=R.length,r["a"].pack(W,R,w),r["a"].pack(U,M,w),r["a"].pack(H,F,w),C.push(a.latitude),C.push(a.longitude),G(D[f],D[f+1],d,h,c,l,e,R,M,F,C)}const $=D[x-1],Q=D[x-2];if(U=v(e,$,d,U),H=v(e,$,h,H),n){const a=D[0];B=v(e,Q,d,B),V=v(e,a,d,V),W=X(B,U,H,V,W)}else W=q(Q,$,h,e,W);if(w=R.length,r["a"].pack(W,R,w),r["a"].pack(U,M,w),r["a"].pack(H,F,w),C.push($.latitude),C.push($.longitude),n){for(G($,Y,d,h,c,l,e,R,M,F,C),w=R.length,f=0;f<3;++f)R[w+f]=R[f],M[w+f]=M[f],F[w+f]=F[f];C.push(Y.latitude),C.push(Y.longitude)}return tt(n,u,M,F,R,C,t)};const la=new r["a"],ua=new b["a"],pa=new j["a"];function da(a,t,n,e){const o=H(n,t,la),i=r["a"].dot(o,a);if(i>A||i<N){const t=H(e,n,J),o=i<N?m["a"].PI_OVER_TWO:-m["a"].PI_OVER_TWO,c=j["a"].fromAxisAngle(t,o,pa),r=b["a"].fromQuaternion(c,ua);return b["a"].multiplyByVector(r,a,a),!0}return!1}const ha=new s["a"],ga=new r["a"],wa=new r["a"];function fa(a,t,n,e,o){const i=s["a"].toCartesian(t,a._ellipsoid,ga);let c=r["a"].add(i,n,wa),l=!1;const u=a._ellipsoid;let p=u.cartesianToCartographic(c,ha);Math.abs(t.longitude-p.longitude)>m["a"].PI_OVER_TWO&&(l=!0,c=r["a"].subtract(i,n,wa),p=u.cartesianToCartographic(c,ha)),p.height=0;const d=a.project(p,o);return o=r["a"].subtract(d,e,o),o.z=0,o=r["a"].normalize(o,o),l&&r["a"].negate(o,o),o}const ya=new r["a"],Oa=new r["a"];function Ea(a,t,n,e,o,i){const c=r["a"].subtract(t,a,ya);r["a"].normalize(c,c);const s=n-T;let l=r["a"].multiplyByScalar(c,s,Oa);r["a"].add(a,l,o);const u=e-L;l=r["a"].multiplyByScalar(c,u,Oa),r["a"].add(t,l,i)}const ma=new r["a"];function ba(a,t){const n=k["a"].getPointDistance(K,a),e=k["a"].getPointDistance(K,t);let o=ma;m["a"].equalsEpsilon(n,0,m["a"].EPSILON2)?(o=H(t,a,o),r["a"].multiplyByScalar(o,m["a"].EPSILON2,o),r["a"].add(a,o,a)):m["a"].equalsEpsilon(e,0,m["a"].EPSILON2)&&(o=H(a,t,o),r["a"].multiplyByScalar(o,m["a"].EPSILON2,o),r["a"].add(t,o,t))}function ka(a,t){const n=Math.abs(a.longitude),e=Math.abs(t.longitude);if(m["a"].equalsEpsilon(n,m["a"].PI,m["a"].EPSILON11)){const e=m["a"].sign(t.longitude);return a.longitude=e*(n-m["a"].EPSILON11),1}if(m["a"].equalsEpsilon(e,m["a"].PI,m["a"].EPSILON11)){const n=m["a"].sign(a.longitude);return t.longitude=n*(e-m["a"].EPSILON11),2}return 0}const ja=new s["a"],Pa=new s["a"],Ia=new r["a"],Sa=new r["a"],_a=new r["a"],Aa=new r["a"],Na=new r["a"],Ta=new r["a"],La=[ja,Pa],za=new P["a"],xa=new r["a"],Da=new r["a"],Ca=new r["a"],qa=new r["a"],Ra=new r["a"],Ma=new r["a"],Fa=new r["a"],Ba=new r["a"],Ga=new r["a"],Ua=new r["a"],va=new r["a"],Ha=new r["a"],Va=new r["a"],Wa=new r["a"],Ya=new w["a"],Za=new w["a"],Ja=new r["a"],$a=new r["a"],Qa=new r["a"],Xa=[new c["a"],new c["a"]],Ka=[0,2,1,0,3,2,0,7,3,0,4,7,0,5,4,0,1,5,5,7,4,5,6,7,5,2,6,5,1,2,3,6,2,3,7,6],at=Ka.length;function tt(a,t,n,o,i,s,u){let p,d;const h=t._ellipsoid,g=n.length/3-1,f=8*g,E=4*f,b=36*g,k=f>65535?new Uint32Array(b):new Uint16Array(b),j=new Float64Array(3*f),I=new Float32Array(E),S=new Float32Array(E),_=new Float32Array(E),N=new Float32Array(E),T=new Float32Array(E);let L,z,x,D;u&&(L=new Float32Array(E),z=new Float32Array(E),x=new Float32Array(E),D=new Float32Array(2*f));const C=s.length/2;let q=0;const R=ja;R.height=0;const M=Pa;M.height=0;let F=Ia,B=Sa;if(u)for(d=0,p=1;p<C;p++)R.latitude=s[d],R.longitude=s[d+1],M.latitude=s[d+2],M.longitude=s[d+3],F=t.project(R,F),B=t.project(M,B),q+=r["a"].distance(F,B),d+=2;const G=o.length/3;B=r["a"].unpack(o,0,B);let U,v=0;for(d=3,p=1;p<G;p++)F=r["a"].clone(B,F),B=r["a"].unpack(o,d,B),v+=r["a"].distance(F,B),d+=3;d=3;let V=0,W=0,Y=0,Z=0,J=!1,$=r["a"].unpack(n,0,Aa),Q=r["a"].unpack(o,0,Sa),X=r["a"].unpack(i,0,Ta);if(a){const a=r["a"].unpack(n,n.length-6,_a);da(X,a,$,Q)&&(X=r["a"].negate(X,X))}let K=0,aa=0,ta=0;for(p=0;p<g;p++){const a=r["a"].clone($,_a),c=r["a"].clone(Q,Ia);let l,p,g,f,y=r["a"].clone(X,Na);if(J&&(y=r["a"].negate(y,y)),$=r["a"].unpack(n,d,Aa),Q=r["a"].unpack(o,d,Sa),X=r["a"].unpack(i,d,Ta),J=da(X,a,$,Q),R.latitude=s[V],R.longitude=s[V+1],M.latitude=s[V+2],M.longitude=s[V+3],u){const a=ka(R,M);l=t.project(R,Ra),p=t.project(M,Ma);const n=H(p,l,Ja);n.y=Math.abs(n.y),g=Fa,f=Ba,0===a||r["a"].dot(n,r["a"].UNIT_Y)>A?(g=fa(t,R,y,l,Fa),f=fa(t,M,X,p,Ba)):1===a?(f=fa(t,M,X,p,Ba),g.x=0,g.y=m["a"].sign(R.longitude-Math.abs(M.longitude)),g.z=0):(g=fa(t,R,y,l,Fa),f.x=0,f.y=m["a"].sign(R.longitude-M.longitude),f.z=0)}const O=r["a"].distance(c,Q),E=w["a"].fromCartesian(a,Ya),b=r["a"].subtract($,a,Ga),k=r["a"].normalize(b,Ha);let C=r["a"].subtract(c,a,Ua);C=r["a"].normalize(C,C);let F=r["a"].cross(k,C,Ha);F=r["a"].normalize(F,F);let B=r["a"].cross(C,y,Va);B=r["a"].normalize(B,B);let G=r["a"].subtract(Q,$,va);G=r["a"].normalize(G,G);let na=r["a"].cross(X,G,Wa);na=r["a"].normalize(na,na);const ea=O/v,oa=K/v;let ia,ca,ra,sa=0,la=0,ua=0;if(u){sa=r["a"].distance(l,p),ia=w["a"].fromCartesian(l,Za),ca=r["a"].subtract(p,l,Ja),ra=r["a"].normalize(ca,$a);const a=ra.x;ra.x=ra.y,ra.y=-a,la=sa/q,ua=aa/q}for(U=0;U<8;U++){const a=Z+4*U,t=W+2*U,n=a+3,e=U<4?1:-1,o=2===U||3===U||6===U||7===U?1:-1;r["a"].pack(E.high,I,a),I[n]=b.x,r["a"].pack(E.low,S,a),S[n]=b.y,r["a"].pack(B,_,a),_[n]=b.z,r["a"].pack(na,N,a),N[n]=ea*e,r["a"].pack(F,T,a);let i=oa*o;0===i&&o<0&&(i=9),T[n]=i,u&&(L[a]=ia.high.x,L[a+1]=ia.high.y,L[a+2]=ia.low.x,L[a+3]=ia.low.y,x[a]=-g.y,x[a+1]=g.x,x[a+2]=f.y,x[a+3]=-f.x,z[a]=ca.x,z[a+1]=ca.y,z[a+2]=ra.x,z[a+3]=ra.y,D[t]=la*e,i=ua*o,0===i&&o<0&&(i=9),D[t+1]=i)}const pa=Ca,ha=qa,ga=xa,wa=Da,ya=P["a"].fromCartographicArray(La,za),Oa=e["a"].getMinimumMaximumHeights(ya,h),ma=Oa.minimumTerrainHeight,ja=Oa.maximumTerrainHeight;ta+=ma,ta+=ja,Ea(a,c,ma,ja,pa,ga),Ea($,Q,ma,ja,ha,wa);let Pa=r["a"].multiplyByScalar(F,m["a"].EPSILON5,Qa);r["a"].add(pa,Pa,pa),r["a"].add(ha,Pa,ha),r["a"].add(ga,Pa,ga),r["a"].add(wa,Pa,wa),ba(pa,ha),ba(ga,wa),r["a"].pack(pa,j,Y),r["a"].pack(ha,j,Y+3),r["a"].pack(wa,j,Y+6),r["a"].pack(ga,j,Y+9),Pa=r["a"].multiplyByScalar(F,-2*m["a"].EPSILON5,Qa),r["a"].add(pa,Pa,pa),r["a"].add(ha,Pa,ha),r["a"].add(ga,Pa,ga),r["a"].add(wa,Pa,wa),ba(pa,ha),ba(ga,wa),r["a"].pack(pa,j,Y+12),r["a"].pack(ha,j,Y+15),r["a"].pack(wa,j,Y+18),r["a"].pack(ga,j,Y+21),V+=2,d+=3,W+=16,Y+=24,Z+=32,K+=O,aa+=sa}d=0;let na=0;for(p=0;p<g;p++){for(U=0;U<at;U++)k[d+U]=Ka[U]+na;na+=8,d+=at}const ea=Xa;c["a"].fromVertices(n,r["a"].ZERO,3,ea[0]),c["a"].fromVertices(o,r["a"].ZERO,3,ea[1]);const oa=c["a"].fromBoundingSpheres(ea);oa.radius+=ta/(2*g);const ia={position:new O["a"]({componentDatatype:l["a"].DOUBLE,componentsPerAttribute:3,normalize:!1,values:j}),startHiAndForwardOffsetX:nt(I),startLoAndForwardOffsetY:nt(S),startNormalAndForwardOffsetZ:nt(_),endNormalAndTextureCoordinateNormalizationX:nt(N),rightNormalAndTextureCoordinateNormalizationY:nt(T)};return u&&(ia.startHiLo2D=nt(L),ia.offsetAndRight2D=nt(z),ia.startEndNormals2D=nt(x),ia.texcoordNormalization2D=new O["a"]({componentDatatype:l["a"].FLOAT,componentsPerAttribute:2,normalize:!1,values:D})),new y["a"]({attributes:ia,indices:k,boundingSphere:oa})}function nt(a){return new O["a"]({componentDatatype:l["a"].FLOAT,componentsPerAttribute:4,normalize:!1,values:a})}z._projectNormal=fa,t["a"]=z},"8dd9":function(a,t,n){"use strict";var e=n("535a"),o=n("2f63"),i=n("93da");function c(a,t,n){this.heading=Object(e["a"])(a,0),this.pitch=Object(e["a"])(t,0),this.roll=Object(e["a"])(n,0)}c.fromQuaternion=function(a,t){Object(o["a"])(t)||(t=new c);const n=2*(a.w*a.y-a.z*a.x),e=1-2*(a.x*a.x+a.y*a.y),r=2*(a.w*a.x+a.y*a.z),s=1-2*(a.y*a.y+a.z*a.z),l=2*(a.w*a.z+a.x*a.y);return t.heading=-Math.atan2(l,s),t.roll=Math.atan2(r,e),t.pitch=-i["a"].asinClamped(n),t},c.fromDegrees=function(a,t,n,e){return Object(o["a"])(e)||(e=new c),e.heading=a*i["a"].RADIANS_PER_DEGREE,e.pitch=t*i["a"].RADIANS_PER_DEGREE,e.roll=n*i["a"].RADIANS_PER_DEGREE,e},c.clone=function(a,t){if(Object(o["a"])(a))return Object(o["a"])(t)?(t.heading=a.heading,t.pitch=a.pitch,t.roll=a.roll,t):new c(a.heading,a.pitch,a.roll)},c.equals=function(a,t){return a===t||Object(o["a"])(a)&&Object(o["a"])(t)&&a.heading===t.heading&&a.pitch===t.pitch&&a.roll===t.roll},c.equalsEpsilon=function(a,t,n,e){return a===t||Object(o["a"])(a)&&Object(o["a"])(t)&&i["a"].equalsEpsilon(a.heading,t.heading,n,e)&&i["a"].equalsEpsilon(a.pitch,t.pitch,n,e)&&i["a"].equalsEpsilon(a.roll,t.roll,n,e)},c.prototype.clone=function(a){return c.clone(this,a)},c.prototype.equals=function(a){return c.equals(this,a)},c.prototype.equalsEpsilon=function(a,t,n){return c.equalsEpsilon(this,a,t,n)},c.prototype.toString=function(){return`(${this.heading}, ${this.pitch}, ${this.roll})`},t["a"]=c}}]);