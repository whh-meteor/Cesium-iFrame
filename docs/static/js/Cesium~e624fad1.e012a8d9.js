(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["Cesium~e624fad1"],{"0768":function(e,n,t){"use strict";n["a"]="varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec2 v_st;\n\nvoid main()\n{\n    vec3 positionToEyeEC = -v_positionEC;\n\n    vec3 normalEC = normalize(v_normalEC);\n#ifdef FACE_FORWARD\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n#endif\n\n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n    materialInput.st = v_st;\n    czm_material material = czm_getMaterial(materialInput);\n\n#ifdef FLAT\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#else\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n#endif\n}\n"},"082a":function(e,n,t){"use strict";var o=t("535a"),i=t("2f63"),a=t("daa2"),r=t("ddf5"),s=t("8e67"),c=t("9937"),l=t("352a"),p=t("e349");function u(e,n){if(n=Object(o["a"])(n,o["a"].EMPTY_OBJECT),!Object(i["a"])(e))return;if(!Object(l["a"])(e,"KHR_materials_common"))return;Object(l["a"])(e,"KHR_techniques_webgl")||(Object(i["a"])(e.extensions)||(e.extensions={}),e.extensions.KHR_techniques_webgl={programs:[],shaders:[],techniques:[]},e.extensionsUsed.push("KHR_techniques_webgl"),e.extensionsRequired.push("KHR_techniques_webgl"));const t=e.extensions.KHR_techniques_webgl;v(e);const a=m(e),r=p["a"].splitIncompatibleMaterials(e),s={};let u=!1;return c["a"].material(e,(function(o,c){if(Object(i["a"])(o.extensions)&&Object(i["a"])(o.extensions.KHR_materials_common)){const l=o.extensions.KHR_materials_common,p=r[c],m=_(l,p);let d=s[m];Object(i["a"])(d)||(d=f(e,t,p,l,a,n.addBatchIdToGeneratedShaders),s[m]=d,u=!0);const v={},h=l.values;let g;for(const e in h)h.hasOwnProperty(e)&&"transparent"!==e&&"doubleSided"!==e&&(g="u_"+e.toLowerCase(),v[g]=h[e]);o.extensions.KHR_techniques_webgl={technique:d,values:v},o.alphaMode="OPAQUE",l.transparent&&(o.alphaMode="BLEND"),l.doubleSided&&(o.doubleSided=!0)}})),u?(p["a"].ensureSemanticExistence(e),e):e}function m(e){const n={};let t;if(Object(i["a"])(e.extensions)&&Object(i["a"])(e.extensions.KHR_materials_common)&&(t=e.extensions.KHR_materials_common.lights),Object(i["a"])(t)){const o=e.nodes;for(const e in o)if(o.hasOwnProperty(e)){const n=o[e];if(Object(i["a"])(n.extensions)&&Object(i["a"])(n.extensions.KHR_materials_common)){const o=n.extensions.KHR_materials_common.light;Object(i["a"])(o)&&Object(i["a"])(t[o])&&(t[o].node=e),delete n.extensions.KHR_materials_common}}let r=0;for(const e in t)if(t.hasOwnProperty(e)){const o=t[e],s=o.type;if("ambient"!==s&&!Object(i["a"])(o.node)){delete t[e];continue}const c="light"+r.toString();let l,p,u,m;switch(o.baseName=c,s){case"ambient":l=o.ambient,n[c+"Color"]={type:a["a"].FLOAT_VEC3,value:l.color};break;case"directional":p=o.directional,n[c+"Color"]={type:a["a"].FLOAT_VEC3,value:p.color},Object(i["a"])(o.node)&&(n[c+"Transform"]={node:o.node,semantic:"MODELVIEW",type:a["a"].FLOAT_MAT4});break;case"point":u=o.point,n[c+"Color"]={type:a["a"].FLOAT_VEC3,value:u.color},Object(i["a"])(o.node)&&(n[c+"Transform"]={node:o.node,semantic:"MODELVIEW",type:a["a"].FLOAT_MAT4}),n[c+"Attenuation"]={type:a["a"].FLOAT_VEC3,value:[u.constantAttenuation,u.linearAttenuation,u.quadraticAttenuation]};break;case"spot":m=o.spot,n[c+"Color"]={type:a["a"].FLOAT_VEC3,value:m.color},Object(i["a"])(o.node)&&(n[c+"Transform"]={node:o.node,semantic:"MODELVIEW",type:a["a"].FLOAT_MAT4},n[c+"InverseTransform"]={node:o.node,semantic:"MODELVIEWINVERSE",type:a["a"].FLOAT_MAT4,useInFragment:!0}),n[c+"Attenuation"]={type:a["a"].FLOAT_VEC3,value:[m.constantAttenuation,m.linearAttenuation,m.quadraticAttenuation]},n[c+"FallOff"]={type:a["a"].FLOAT_VEC2,value:[m.fallOffAngle,m.fallOffExponent]};break}++r}}return n}function f(e,n,t,c,p,u){Object(i["a"])(c)||(c={}),u=Object(o["a"])(u,!1);const m=n.techniques,f=n.shaders,_=n.programs,v=c.technique.toUpperCase();let h;Object(i["a"])(e.extensions)&&Object(i["a"])(e.extensions.KHR_materials_common)&&(h=e.extensions.KHR_materials_common.lights);const g=c.values,b=Object(o["a"])(c.jointCount,0);let T,y=!1,C=!1;Object(i["a"])(t)&&(T=t.skinning,y=T.skinned,C=t.hasVertexColors);let x="precision highp float;\n",E="precision highp float;\n";const O="CONSTANT"!==v,S={u_modelViewMatrix:{semantic:Object(l["a"])(e,"CESIUM_RTC")?"CESIUM_RTC_MODELVIEW":"MODELVIEW",type:a["a"].FLOAT_MAT4},u_projectionMatrix:{semantic:"PROJECTION",type:a["a"].FLOAT_MAT4}};let I;O&&(S.u_normalMatrix={semantic:"MODELVIEWINVERSETRANSPOSE",type:a["a"].FLOAT_MAT3}),y&&(S.u_jointMatrix={count:b,semantic:"JOINTMATRIX",type:a["a"].FLOAT_MAT4});let A=!1;for(const o in g)if(g.hasOwnProperty(o)&&"transparent"!==o&&"doubleSided"!==o){const e=d(o,g[o]);I="u_"+o.toLowerCase(),A||e!==a["a"].SAMPLER_2D||(A=!0),S[I]={type:e}}if(Object(i["a"])(S.u_diffuse)&&(S.u_diffuse.semantic="_3DTILESDIFFUSE"),Object(i["a"])(p))for(const o in p)p.hasOwnProperty(o)&&(I="u_"+o,S[I]=p[o]);for(I in S)if(S.hasOwnProperty(I)){const e=S[I],n=Object(i["a"])(e.count)?`[${e.count}]`:"";e.type!==a["a"].FLOAT_MAT3&&e.type!==a["a"].FLOAT_MAT4||e.useInFragment?(E+=`uniform ${Object(r["a"])(e.type)} ${I}${n};\n`,delete e.useInFragment):x+=`uniform ${Object(r["a"])(e.type)} ${I}${n};\n`}let D="";y&&(D+="    mat4 skinMatrix =\n        a_weight.x * u_jointMatrix[int(a_joint.x)] +\n        a_weight.y * u_jointMatrix[int(a_joint.y)] +\n        a_weight.z * u_jointMatrix[int(a_joint.z)] +\n        a_weight.w * u_jointMatrix[int(a_joint.w)];\n");const F={a_position:{semantic:"POSITION"}};let H;x+="attribute vec3 a_position;\n",x+="varying vec3 v_positionEC;\n",D+=y?"  vec4 pos = u_modelViewMatrix * skinMatrix * vec4(a_position,1.0);\n":"  vec4 pos = u_modelViewMatrix * vec4(a_position,1.0);\n",D+="  v_positionEC = pos.xyz;\n",D+="  gl_Position = u_projectionMatrix * pos;\n",E+="varying vec3 v_positionEC;\n",O&&(F.a_normal={semantic:"NORMAL"},x+="attribute vec3 a_normal;\n",x+="varying vec3 v_normal;\n",D+=y?"  v_normal = u_normalMatrix * mat3(skinMatrix) * a_normal;\n":"  v_normal = u_normalMatrix * a_normal;\n",E+="varying vec3 v_normal;\n"),A&&(F.a_texcoord_0={semantic:"TEXCOORD_0"},H="v_texcoord_0",x+="attribute vec2 a_texcoord_0;\n",x+=`varying vec2 ${H};\n`,D+=`  ${H} = a_texcoord_0;\n`,E+=`varying vec2 ${H};\n`),y&&(F.a_joint={semantic:"JOINTS_0"},F.a_weight={semantic:"WEIGHTS_0"},x+="attribute vec4 a_joint;\n",x+="attribute vec4 a_weight;\n"),C&&(F.a_vertexColor={semantic:"COLOR_0"},x+="attribute vec4 a_vertexColor;\n",x+="varying vec4 v_vertexColor;\n",D+="  v_vertexColor = a_vertexColor;\n",E+="varying vec4 v_vertexColor;\n"),u&&(F.a_batchId={semantic:"_BATCHID"},x+="attribute float a_batchId;\n");const L=O&&("BLINN"===v||"PHONG"===v)&&Object(i["a"])(S.u_specular)&&Object(i["a"])(S.u_shininess)&&S.u_shininess>0;let z=!1,R=!1,w="";for(const o in h)if(h.hasOwnProperty(o)){const e=h[o],n=e.type.toLowerCase(),t=e.baseName;w+="  {\n";const i=`u_${t}Color`;if("ambient"===n)R=!0,w+=`    ambientLight += ${i};\n`;else if(O){z=!0;const e=`v_${t}Direction`,o=`v_${t}Position`;"point"!==n&&(x+=`varying vec3 ${e};\n`,E+=`varying vec3 ${e};\n`,D+=`  ${e} = mat3(u_${t}Transform) * vec3(0.,0.,1.);\n`,"directional"===n&&(w+=`    vec3 l = normalize(${e});\n`)),"directional"!==n?(x+=`varying vec3 ${o};\n`,E+=`varying vec3 ${o};\n`,D+=`  ${o} = u_${t}Transform[3].xyz;\n`,w+=`    vec3 VP = ${o} - v_positionEC;\n`,w+="    vec3 l = normalize(VP);\n",w+="    float range = length(VP);\n",w+=`    float attenuation = 1.0 / (u_${t}Attenuation.x + `,w+=`(u_${t}Attenuation.y * range) + `,w+=`(u_${t}Attenuation.z * range * range));\n`):w+="    float attenuation = 1.0;\n","spot"===n&&(w+=`    float spotDot = dot(l, normalize(${e}));\n`,w+=`    if (spotDot < cos(u_${t}FallOff.x * 0.5))\n`,w+="    {\n",w+="      attenuation = 0.0;\n",w+="    }\n",w+="    else\n",w+="    {\n",w+=`        attenuation *= max(0.0, pow(spotDot, u_${t}FallOff.y));\n`,w+="    }\n"),w+=`    diffuseLight += ${i}* max(dot(normal,l), 0.) * attenuation;\n`,L&&("BLINN"===v?(w+="    vec3 h = normalize(l + viewDir);\n",w+="    float specularIntensity = max(0., pow(max(dot(normal, h), 0.), u_shininess)) * attenuation;\n"):(w+="    vec3 reflectDir = reflect(-l, normal);\n",w+="    float specularIntensity = max(0., pow(max(dot(reflectDir, viewDir), 0.), u_shininess)) * attenuation;\n"),w+=`    specularLight += ${i} * specularIntensity;\n`)}w+="  }\n"}if(R||(w+="  ambientLight += vec3(0.2, 0.2, 0.2);\n"),!z&&"CONSTANT"!==v){E+="#ifdef USE_CUSTOM_LIGHT_COLOR \n",E+="uniform vec3 gltf_lightColor; \n",E+="#endif \n",w+="#ifndef USE_CUSTOM_LIGHT_COLOR \n",w+="    vec3 lightColor = czm_lightColor;\n",w+="#else \n",w+="    vec3 lightColor = gltf_lightColor;\n",w+="#endif \n",w+="  vec3 l = normalize(czm_lightDirectionEC);\n";const e="0.2";w+=`  diffuseLight += lightColor * max(dot(normal,l), ${e});\n`,L&&("BLINN"===v?(w+="  vec3 h = normalize(l + viewDir);\n",w+="  float specularIntensity = max(0., pow(max(dot(normal, h), 0.), u_shininess));\n"):(w+="  vec3 reflectDir = reflect(-l, normal);\n",w+="  float specularIntensity = max(0., pow(max(dot(reflectDir, viewDir), 0.), u_shininess));\n"),w+="  specularLight += lightColor * specularIntensity;\n")}x+="void main(void) {\n",x+=D,x+="}\n",E+="void main(void) {\n";let j,P="  vec3 color = vec3(0.0, 0.0, 0.0);\n";O&&(E+="  vec3 normal = normalize(v_normal);\n",c.doubleSided&&(E+="  if (czm_backFacing())\n",E+="  {\n",E+="    normal = -normal;\n",E+="  }\n")),"CONSTANT"!==v?(Object(i["a"])(S.u_diffuse)&&(S.u_diffuse.type===a["a"].SAMPLER_2D?E+=`  vec4 diffuse = texture2D(u_diffuse, ${H});\n`:E+="  vec4 diffuse = u_diffuse;\n",E+="  vec3 diffuseLight = vec3(0.0, 0.0, 0.0);\n",P+="  color += diffuse.rgb * diffuseLight;\n"),L&&(S.u_specular.type===a["a"].SAMPLER_2D?E+=`  vec3 specular = texture2D(u_specular, ${H}).rgb;\n`:E+="  vec3 specular = u_specular.rgb;\n",E+="  vec3 specularLight = vec3(0.0, 0.0, 0.0);\n",P+="  color += specular * specularLight;\n"),j=Object(i["a"])(S.u_transparency)?"  gl_FragColor = vec4(color * diffuse.a * u_transparency, diffuse.a * u_transparency);\n":"  gl_FragColor = vec4(color * diffuse.a, diffuse.a);\n"):j=Object(i["a"])(S.u_transparency)?"  gl_FragColor = vec4(color * u_transparency, u_transparency);\n":"  gl_FragColor = vec4(color, 1.0);\n",C&&(P+="  color *= v_vertexColor.rgb;\n"),Object(i["a"])(S.u_emission)&&(S.u_emission.type===a["a"].SAMPLER_2D?E+=`  vec3 emission = texture2D(u_emission, ${H}).rgb;\n`:E+="  vec3 emission = u_emission.rgb;\n",P+="  color += emission;\n"),(Object(i["a"])(S.u_ambient)||"CONSTANT"!==v)&&(Object(i["a"])(S.u_ambient)?S.u_ambient.type===a["a"].SAMPLER_2D?E+=`  vec3 ambient = texture2D(u_ambient, ${H}).rgb;\n`:E+="  vec3 ambient = u_ambient.rgb;\n":E+="  vec3 ambient = diffuse.rgb;\n",P+="  color += ambient * ambientLight;\n"),E+="  vec3 viewDir = -normalize(v_positionEC);\n",E+="  vec3 ambientLight = vec3(0.0, 0.0, 0.0);\n",E+=w,E+=P,E+=j,E+="}\n";const N=Object(s["a"])(f,{type:a["a"].VERTEX_SHADER,extras:{_pipeline:{source:x,extension:".glsl"}}}),M=Object(s["a"])(f,{type:a["a"].FRAGMENT_SHADER,extras:{_pipeline:{source:E,extension:".glsl"}}}),G=Object(s["a"])(_,{fragmentShader:M,vertexShader:N}),V=Object(s["a"])(m,{attributes:F,program:G,uniforms:S});return V}function d(e,n){let t;switch(t=Object(i["a"])(n.value)?n.value:Object(i["a"])(n.index)?[n.index]:n,e){case"ambient":return 1===t.length?a["a"].SAMPLER_2D:a["a"].FLOAT_VEC4;case"diffuse":return 1===t.length?a["a"].SAMPLER_2D:a["a"].FLOAT_VEC4;case"emission":return 1===t.length?a["a"].SAMPLER_2D:a["a"].FLOAT_VEC4;case"specular":return 1===t.length?a["a"].SAMPLER_2D:a["a"].FLOAT_VEC4;case"shininess":return a["a"].FLOAT;case"transparency":return a["a"].FLOAT;case"transparent":return a["a"].BOOL;case"doubleSided":return a["a"].BOOL}}function _(e,n){let t="";t+=`technique:${e.technique};`;const a=e.values,r=Object.keys(a).sort(),s=r.length;for(let o=0;o<s;++o){const e=r[o];a.hasOwnProperty(e)&&(t+=`${e}:${d(e,a[e])}`,t+=";")}const c=Object(o["a"])(e.jointCount,0);if(t+=c.toString()+";",Object(i["a"])(n)){const e=n.skinning;c>0&&(t+=e.type+";"),t+=n.hasVertexColors}return t}function v(e){const n=e.extensions.KHR_materials_common;if(!Object(i["a"])(n)||!Object(i["a"])(n.lights))return;const t=n.lights,a=t.length;for(let r=0;r<a;r++){const e=t[r];if("ambient"===e.type){Object(i["a"])(e.ambient)||(e.ambient={});const n=e.ambient;Object(i["a"])(n.color)||(n.color=[1,1,1])}else if("directional"===e.type){Object(i["a"])(e.directional)||(e.directional={});const n=e.directional;Object(i["a"])(n.color)||(n.color=[1,1,1])}else if("point"===e.type){Object(i["a"])(e.point)||(e.point={});const n=e.point;Object(i["a"])(n.color)||(n.color=[1,1,1]),n.constantAttenuation=Object(o["a"])(n.constantAttenuation,1),n.linearAttenuation=Object(o["a"])(n.linearAttenuation,0),n.quadraticAttenuation=Object(o["a"])(n.quadraticAttenuation,0)}else if("spot"===e.type){Object(i["a"])(e.spot)||(e.spot={});const n=e.spot;Object(i["a"])(n.color)||(n.color=[1,1,1]),n.constantAttenuation=Object(o["a"])(n.constantAttenuation,1),n.fallOffAngle=Object(o["a"])(n.fallOffAngle,3.14159265),n.fallOffExponent=Object(o["a"])(n.fallOffExponent,0),n.linearAttenuation=Object(o["a"])(n.linearAttenuation,0),n.quadraticAttenuation=Object(o["a"])(n.quadraticAttenuation,0)}}}n["a"]=u},"2c4b":function(e,n,t){"use strict";n["a"]="attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nattribute vec4 color;\nattribute float batchId;\n\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec4 v_color;\n\nvoid main()\n{\n    vec4 p = czm_computePosition();\n\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\n    v_color = color;\n\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"},"2d11":function(e,n,t){"use strict";n["a"]="attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nattribute float batchId;\n\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\n\nvoid main()\n{\n    vec4 p = czm_computePosition();\n\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\n\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"},"365a":function(e,n,t){"use strict";n["a"]="attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nattribute vec2 st;\nattribute float batchId;\n\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec2 v_st;\n\nvoid main()\n{\n    vec4 p = czm_computePosition();\n\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\n    v_st = st;\n\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"},"40ef":function(e,n,t){"use strict";t.d(n,"a",(function(){return c}));var o=t("2f63"),i=t("e856"),a=t("974b"),r=t("283e"),s=t("5457");function c(e){const n=new Uint8Array(e);let t=Object(a["a"])(n);if("glTF"===t&&(t="glb"),s["a"].isBinaryFormat(t))return{contentType:t,binaryPayload:n};const i=l(n);if(Object(o["a"])(i.root))return{contentType:s["a"].EXTERNAL_TILESET,jsonPayload:i};if(Object(o["a"])(i.asset))return{contentType:s["a"].GLTF,jsonPayload:i};if(Object(o["a"])(i.tileAvailability))return{contentType:s["a"].IMPLICIT_SUBTREE_JSON,jsonPayload:i};if(Object(o["a"])(i.type))return{contentType:s["a"].GEOJSON,jsonPayload:i};throw new r["a"]("Invalid tile content.")}function l(e){let n;try{n=Object(i["a"])(e)}catch(t){throw new r["a"]("Invalid tile content.")}return n}},"461c":function(e,n,t){"use strict";n["a"]="#ifdef MRT\n#extension GL_EXT_draw_buffers : enable\n#endif\n\nuniform vec4 u_bgColor;\nuniform sampler2D u_depthTexture;\n\nvarying vec2 v_textureCoordinates;\n\nvoid main()\n{\n    if (texture2D(u_depthTexture, v_textureCoordinates).r < 1.0)\n    {\n#ifdef MRT\n        gl_FragData[0] = u_bgColor;\n        gl_FragData[1] = vec4(u_bgColor.a);\n#else\n        gl_FragColor = u_bgColor;\n#endif\n        return;\n    }\n    \n    discard;\n}\n"},"518d":function(e,n,t){"use strict";t.d(n,"a",(function(){return i}));var o=t("2f63");function i(e){return{tile:{boundingVolume:a("TILE",e),minimumHeight:r("TILE",e),maximumHeight:s("TILE",e)},content:{boundingVolume:a("CONTENT",e),minimumHeight:r("CONTENT",e),maximumHeight:s("CONTENT",e)}}}function a(e,n){const t=e+"_BOUNDING_BOX",i=n.getPropertyBySemantic(t);if(Object(o["a"])(i))return{box:i};const a=e+"_BOUNDING_REGION",r=n.getPropertyBySemantic(a);if(Object(o["a"])(r))return{region:r};const s=e+"_BOUNDING_SPHERE",c=n.getPropertyBySemantic(s);return Object(o["a"])(c)?{sphere:c}:void 0}function r(e,n){const t=e+"_MINIMUM_HEIGHT";return n.getPropertyBySemantic(t)}function s(e,n){const t=e+"_MAXIMUM_HEIGHT";return n.getPropertyBySemantic(t)}},"55d8":function(e,n,t){"use strict";t.d(n,"a",(function(){return i}));var o=t("2f63");function i(e,n){return Object(o["a"])(e)&&Object(o["a"])(e.extensions)&&Object(o["a"])(e.extensions[n])}},"60fc":function(e,n,t){"use strict";n["a"]="attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nattribute vec3 tangent;\nattribute vec3 bitangent;\nattribute vec2 st;\nattribute float batchId;\n\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec3 v_tangentEC;\nvarying vec3 v_bitangentEC;\nvarying vec2 v_st;\n\nvoid main()\n{\n    vec4 p = czm_computePosition();\n\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\n    v_tangentEC = czm_normal * tangent;                       // tangent in eye coordinates\n    v_bitangentEC = czm_normal * bitangent;                   // bitangent in eye coordinates\n    v_st = st;\n\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"},"6d53":function(e,n,t){"use strict";n["a"]='#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n\nuniform sampler2D u_atlas;\n\n#ifdef VECTOR_TILE\nuniform vec4 u_highlightColor;\n#endif\n\nvarying vec2 v_textureCoordinates;\nvarying vec4 v_pickColor;\nvarying vec4 v_color;\n\n#ifdef SDF\nvarying vec4 v_outlineColor;\nvarying float v_outlineWidth;\n#endif\n\n#ifdef FRAGMENT_DEPTH_CHECK\nvarying vec4 v_textureCoordinateBounds;                  // the min and max x and y values for the texture coordinates\nvarying vec4 v_originTextureCoordinateAndTranslate;      // texture coordinate at the origin, billboard translate (used for label glyphs)\nvarying vec4 v_compressed;                               // x: eyeDepth, y: applyTranslate & enableDepthCheck, z: dimensions, w: imageSize\nvarying mat2 v_rotationMatrix;\n\nconst float SHIFT_LEFT12 = 4096.0;\nconst float SHIFT_LEFT1 = 2.0;\n\nconst float SHIFT_RIGHT12 = 1.0 / 4096.0;\nconst float SHIFT_RIGHT1 = 1.0 / 2.0;\n\nfloat getGlobeDepth(vec2 adjustedST, vec2 depthLookupST, bool applyTranslate, vec2 dimensions, vec2 imageSize)\n{\n    vec2 lookupVector = imageSize * (depthLookupST - adjustedST);\n    lookupVector = v_rotationMatrix * lookupVector;\n    vec2 labelOffset = (dimensions - imageSize) * (depthLookupST - vec2(0.0, v_originTextureCoordinateAndTranslate.y)); // aligns label glyph with bounding rectangle.  Will be zero for billboards because dimensions and imageSize will be equal\n\n    vec2 translation = v_originTextureCoordinateAndTranslate.zw;\n\n    if (applyTranslate)\n    {\n        // this is only needed for labels where the horizontal origin is not LEFT\n        // it moves the label back to where the "origin" should be since all label glyphs are set to HorizontalOrigin.LEFT\n        translation += (dimensions * v_originTextureCoordinateAndTranslate.xy * vec2(1.0, 0.0));\n    }\n\n    vec2 st = ((lookupVector - translation + labelOffset) + gl_FragCoord.xy) / czm_viewport.zw;\n    float logDepthOrDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, st));\n\n    if (logDepthOrDepth == 0.0)\n    {\n        return 0.0; // not on the globe\n    }\n\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth);\n    return eyeCoordinate.z / eyeCoordinate.w;\n}\n#endif\n\n\n#ifdef SDF\n\n// Get the distance from the edge of a glyph at a given position sampling an SDF texture.\nfloat getDistance(vec2 position)\n{\n    return texture2D(u_atlas, position).r;\n}\n\n// Samples the sdf texture at the given position and produces a color based on the fill color and the outline.\nvec4 getSDFColor(vec2 position, float outlineWidth, vec4 outlineColor, float smoothing)\n{\n    float distance = getDistance(position);\n\n    if (outlineWidth > 0.0)\n    {\n        // Don\'t get the outline edge exceed the SDF_EDGE\n        float outlineEdge = clamp(SDF_EDGE - outlineWidth, 0.0, SDF_EDGE);\n        float outlineFactor = smoothstep(SDF_EDGE - smoothing, SDF_EDGE + smoothing, distance);\n        vec4 sdfColor = mix(outlineColor, v_color, outlineFactor);\n        float alpha = smoothstep(outlineEdge - smoothing, outlineEdge + smoothing, distance);\n        return vec4(sdfColor.rgb, sdfColor.a * alpha);\n    }\n    else\n    {\n        float alpha = smoothstep(SDF_EDGE - smoothing, SDF_EDGE + smoothing, distance);\n        return vec4(v_color.rgb, v_color.a * alpha);\n    }\n}\n#endif\n\nvoid main()\n{\n    vec4 color = texture2D(u_atlas, v_textureCoordinates);\n\n#ifdef SDF\n    float outlineWidth = v_outlineWidth;\n    vec4 outlineColor = v_outlineColor;\n\n    // Get the current distance\n    float distance = getDistance(v_textureCoordinates);\n\n#ifdef GL_OES_standard_derivatives\n    float smoothing = fwidth(distance);\n    // Get an offset that is approximately half the distance to the neighbor pixels\n    // 0.354 is approximately half of 1/sqrt(2)\n    vec2 sampleOffset = 0.354 * vec2(dFdx(v_textureCoordinates) + dFdy(v_textureCoordinates));\n\n    // Sample the center point\n    vec4 center = getSDFColor(v_textureCoordinates, outlineWidth, outlineColor, smoothing);\n\n    // Sample the 4 neighbors\n    vec4 color1 = getSDFColor(v_textureCoordinates + vec2(sampleOffset.x, sampleOffset.y), outlineWidth, outlineColor, smoothing);\n    vec4 color2 = getSDFColor(v_textureCoordinates + vec2(-sampleOffset.x, sampleOffset.y), outlineWidth, outlineColor, smoothing);\n    vec4 color3 = getSDFColor(v_textureCoordinates + vec2(-sampleOffset.x, -sampleOffset.y), outlineWidth, outlineColor, smoothing);\n    vec4 color4 = getSDFColor(v_textureCoordinates + vec2(sampleOffset.x, -sampleOffset.y), outlineWidth, outlineColor, smoothing);\n\n    // Equally weight the center sample and the 4 neighboring samples\n    color = (center + color1 + color2 + color3 + color4)/5.0;\n#else\n    // Just do a single sample\n    float smoothing = 1.0/32.0;\n    color = getSDFColor(v_textureCoordinates, outlineWidth, outlineColor, smoothing);\n#endif\n\n    color = czm_gammaCorrect(color);\n#else\n    color = czm_gammaCorrect(color);\n    color *= czm_gammaCorrect(v_color);\n#endif\n\n// Fully transparent parts of the billboard are not pickable.\n#if !defined(OPAQUE) && !defined(TRANSLUCENT)\n    if (color.a < 0.005)   // matches 0/255 and 1/255\n    {\n        discard;\n    }\n#else\n// The billboard is rendered twice. The opaque pass discards translucent fragments\n// and the translucent pass discards opaque fragments.\n#ifdef OPAQUE\n    if (color.a < 0.995)   // matches < 254/255\n    {\n        discard;\n    }\n#else\n    if (color.a >= 0.995)  // matches 254/255 and 255/255\n    {\n        discard;\n    }\n#endif\n#endif\n\n#ifdef VECTOR_TILE\n    color *= u_highlightColor;\n#endif\n    gl_FragColor = color;\n\n#ifdef LOG_DEPTH\n    czm_writeLogDepth();\n#endif\n\n#ifdef FRAGMENT_DEPTH_CHECK\n    float temp = v_compressed.y;\n\n    temp = temp * SHIFT_RIGHT1;\n\n    float temp2 = (temp - floor(temp)) * SHIFT_LEFT1;\n    bool enableDepthTest = temp2 != 0.0;\n    bool applyTranslate = floor(temp) != 0.0;\n\n    if (enableDepthTest) {\n        temp = v_compressed.z;\n        temp = temp * SHIFT_RIGHT12;\n\n        vec2 dimensions;\n        dimensions.y = (temp - floor(temp)) * SHIFT_LEFT12;\n        dimensions.x = floor(temp);\n\n        temp = v_compressed.w;\n        temp = temp * SHIFT_RIGHT12;\n\n        vec2 imageSize;\n        imageSize.y = (temp - floor(temp)) * SHIFT_LEFT12;\n        imageSize.x = floor(temp);\n\n        vec2 adjustedST = v_textureCoordinates - v_textureCoordinateBounds.xy;\n        adjustedST = adjustedST / vec2(v_textureCoordinateBounds.z - v_textureCoordinateBounds.x, v_textureCoordinateBounds.w - v_textureCoordinateBounds.y);\n\n        float epsilonEyeDepth = v_compressed.x + czm_epsilon1;\n        float globeDepth1 = getGlobeDepth(adjustedST, v_originTextureCoordinateAndTranslate.xy, applyTranslate, dimensions, imageSize);\n\n        // negative values go into the screen\n        if (globeDepth1 != 0.0 && globeDepth1 > epsilonEyeDepth)\n        {\n            float globeDepth2 = getGlobeDepth(adjustedST, vec2(0.0, 1.0), applyTranslate, dimensions, imageSize); // top left corner\n            if (globeDepth2 != 0.0 && globeDepth2 > epsilonEyeDepth)\n            {\n                float globeDepth3 = getGlobeDepth(adjustedST, vec2(1.0, 1.0), applyTranslate, dimensions, imageSize); // top right corner\n                if (globeDepth3 != 0.0 && globeDepth3 > epsilonEyeDepth)\n                {\n                    discard;\n                }\n            }\n        }\n    }\n#endif\n\n}\n'},"7be3":function(e,n,t){"use strict";n["a"]="attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 prevPosition3DHigh;\nattribute vec3 prevPosition3DLow;\nattribute vec3 nextPosition3DHigh;\nattribute vec3 nextPosition3DLow;\nattribute vec2 expandAndWidth;\nattribute vec2 st;\nattribute float batchId;\n\nvarying float v_width;\nvarying vec2 v_st;\nvarying float v_polylineAngle;\n\nvoid main()\n{\n    float expandDir = expandAndWidth.x;\n    float width = abs(expandAndWidth.y) + 0.5;\n    bool usePrev = expandAndWidth.y < 0.0;\n\n    vec4 p = czm_computePosition();\n    vec4 prev = czm_computePrevPosition();\n    vec4 next = czm_computeNextPosition();\n\n    float angle;\n    vec4 positionWC = getPolylineWindowCoordinates(p, prev, next, expandDir, width, usePrev, angle);\n    gl_Position = czm_viewportOrthographic * positionWC;\n\n    v_width = width;\n    v_st.s = st.s;\n    v_st.t = czm_writeNonPerspective(st.t, gl_Position.w);\n    v_polylineAngle = angle;\n}\n"},8086:function(e,n,t){"use strict";t.d(n,"a",(function(){return p}));var o=t("2bb9"),i=t("535a"),a=t("2f63"),r=t("a7eb"),s=t("5b21"),c=t("fdb7"),l=t("3899");function p(e){e=Object(i["a"])(e,i["a"].EMPTY_OBJECT);const n=e.extension,t=e.schema;let o;const p=[];let m;if(Object(a["a"])(n.featureTables))for(m=Object.keys(n.featureTables).sort(),o=0;o<m.length;o++){const i=m[o],a=n.featureTables[i],s=t.classes[a.class],c=new l["a"]({count:a.count,properties:a.properties,class:s,bufferViews:e.bufferViews});p.push(new r["a"]({id:i,count:a.count,metadataTable:c,extras:a.extras,extensions:a.extensions}))}const f=[];if(Object(a["a"])(n.featureTextures))for(m=Object.keys(n.featureTextures).sort(),o=0;o<m.length;o++){const i=m[o],a=n.featureTextures[i];f.push(new s["a"]({id:i,propertyTexture:u(a),class:t.classes[a.class],textures:e.textures}))}return new c["a"]({schema:t,propertyTables:p,propertyTextures:f,statistics:n.statistics,extras:n.extras,extensions:n.extensions})}function u(e){const n={class:e.class,properties:{}},t=e.properties;for(const i in t)if(t.hasOwnProperty(i)){const e=t[i],a={channels:m(e.channels),extras:e.extras,extensions:e.extensions};n.properties[i]=Object(o["a"])(e.texture,a,!0)}return n}function m(e){const n=e.length,t=new Array(n);for(let o=0;o<n;o++)t[o]="rgba".indexOf(e[o]);return t}},"9c89":function(e,n,t){"use strict";n["a"]="attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec4 color;\nattribute float batchId;\n\nvarying vec4 v_color;\n\nvoid main()\n{\n    vec4 p = czm_computePosition();\n\n    v_color = color;\n\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"},"9ffa":function(e,n,t){"use strict";n["a"]="varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\n\nvoid main()\n{\n    vec3 positionToEyeEC = -v_positionEC;\n\n    vec3 normalEC = normalize(v_normalEC);\n#ifdef FACE_FORWARD\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n#endif\n\n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n    czm_material material = czm_getMaterial(materialInput);\n\n#ifdef FLAT\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#else\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n#endif\n}\n"},a0fe:function(e,n,t){"use strict";n["a"]="attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 prevPosition3DHigh;\nattribute vec3 prevPosition3DLow;\nattribute vec3 nextPosition3DHigh;\nattribute vec3 nextPosition3DLow;\nattribute vec2 expandAndWidth;\nattribute vec4 color;\nattribute float batchId;\n\nvarying vec4 v_color;\n\nvoid main()\n{\n    float expandDir = expandAndWidth.x;\n    float width = abs(expandAndWidth.y) + 0.5;\n    bool usePrev = expandAndWidth.y < 0.0;\n\n    vec4 p = czm_computePosition();\n    vec4 prev = czm_computePrevPosition();\n    vec4 next = czm_computeNextPosition();\n\n    float angle;\n    vec4 positionWC = getPolylineWindowCoordinates(p, prev, next, expandDir, width, usePrev, angle);\n    gl_Position = czm_viewportOrthographic * positionWC;\n\n    v_color = color;\n}\n"},b0df:function(e,n,t){"use strict";n["a"]="uniform vec3 u_radiiAndDynamicAtmosphereColor;\n\nuniform float u_atmosphereLightIntensity;\nuniform float u_atmosphereRayleighScaleHeight;\nuniform float u_atmosphereMieScaleHeight;\nuniform float u_atmosphereMieAnisotropy;\nuniform vec3 u_atmosphereRayleighCoefficient;\nuniform vec3 u_atmosphereMieCoefficient;\n\nconst float ATMOSPHERE_THICKNESS = 111e3; // The thickness of the atmosphere in meters.\nconst int PRIMARY_STEPS = 16; // Number of times the ray from the camera to the world position (primary ray) is sampled.\nconst int LIGHT_STEPS = 4; // Number of times the light is sampled from the light source's intersection with the atmosphere to a sample position on the primary ray.\n\n/**\n * This function computes the colors contributed by Rayliegh and Mie scattering on a given ray, as well as\n * the transmittance value for the ray.\n *\n * @param {czm_ray} primaryRay The ray from the camera to the position.\n * @param {float} primaryRayLength The length of the primary ray.\n * @param {vec3} lightDirection The direction of the light to calculate the scattering from.\n * @param {vec3} rayleighColor The variable the Rayleigh scattering will be written to.\n * @param {vec3} mieColor The variable the Mie scattering will be written to.\n * @param {float} opacity The variable the transmittance will be written to.\n * @glslFunction\n */\nvoid computeScattering(\n    czm_ray primaryRay,\n    float primaryRayLength,\n    vec3 lightDirection,\n    float atmosphereInnerRadius,\n    out vec3 rayleighColor,\n    out vec3 mieColor,\n    out float opacity\n) {\n\n    // Initialize the default scattering amounts to 0.\n    rayleighColor = vec3(0.0);\n    mieColor = vec3(0.0);\n    opacity = 0.0;\n\n    float atmosphereOuterRadius = atmosphereInnerRadius + ATMOSPHERE_THICKNESS;\n\n    vec3 origin = vec3(0.0);\n\n    // Calculate intersection from the camera to the outer ring of the atmosphere.\n    czm_raySegment primaryRayAtmosphereIntersect = czm_raySphereIntersectionInterval(primaryRay, origin, atmosphereOuterRadius);\n\n    // Return empty colors if no intersection with the atmosphere geometry.\n    if (primaryRayAtmosphereIntersect == czm_emptyRaySegment) {\n        return;\n    }\n\n    // The ray should start from the first intersection with the outer atmopshere, or from the camera position, if it is inside the atmosphere.\n    primaryRayAtmosphereIntersect.start = max(primaryRayAtmosphereIntersect.start, 0.0);\n    // The ray should end at the exit from the atmosphere or at the distance to the vertex, whichever is smaller.\n    primaryRayAtmosphereIntersect.stop = min(primaryRayAtmosphereIntersect.stop, length(primaryRayLength));\n\n    // Setup for sampling positions along the ray - starting from the intersection with the outer ring of the atmosphere.\n    float rayStepLength = (primaryRayAtmosphereIntersect.stop - primaryRayAtmosphereIntersect.start) / float(PRIMARY_STEPS);\n    float rayPositionLength = primaryRayAtmosphereIntersect.start;\n\n    vec3 rayleighAccumulation = vec3(0.0);\n    vec3 mieAccumulation = vec3(0.0);\n    vec2 opticalDepth = vec2(0.0);\n    vec2 heightScale = vec2(u_atmosphereRayleighScaleHeight, u_atmosphereMieScaleHeight);\n\n    // Sample positions on the primary ray.\n    for (int i = 0; i < PRIMARY_STEPS; i++) {\n        // Calculate sample position along viewpoint ray.\n        vec3 samplePosition = primaryRay.origin + primaryRay.direction * (rayPositionLength + rayStepLength);\n        \n        // Calculate height of sample position above ellipsoid.\n        float sampleHeight = length(samplePosition) - atmosphereInnerRadius;\n\n        // Calculate and accumulate density of particles at the sample position.\n        vec2 sampleDensity = exp(-sampleHeight / heightScale) * rayStepLength;\n        opticalDepth += sampleDensity;\n\n        // Generate ray from the sample position segment to the light source, up to the outer ring of the atmosphere.\n        czm_ray lightRay = czm_ray(samplePosition, lightDirection);\n        czm_raySegment lightRayAtmosphereIntersect = czm_raySphereIntersectionInterval(lightRay, origin, atmosphereOuterRadius);\n        \n        float lightStepLength = lightRayAtmosphereIntersect.stop / float(LIGHT_STEPS);\n        float lightPositionLength = 0.0;\n\n        vec2 lightOpticalDepth = vec2(0.0);\n\n        // Sample positions along the light ray, to accumulate incidence of light on the latest sample segment.\n        for (int j = 0; j < LIGHT_STEPS; j++) {\n\n            // Calculate sample position along light ray.\n            vec3 lightPosition = samplePosition + lightDirection * (lightPositionLength + lightStepLength * 0.5);\n\n            // Calculate height of the light sample position above ellipsoid.\n            float lightHeight = length(lightPosition) - atmosphereInnerRadius;\n\n            // Calculate density of photons at the light sample position.\n            lightOpticalDepth += exp(-lightHeight / heightScale) * lightStepLength;\n\n            // Increment distance on light ray.\n            lightPositionLength += lightStepLength;\n        }\n\n        // Compute attenuation via the primary ray and the light ray.\n        vec3 attenuation = exp(-((u_atmosphereMieCoefficient * (opticalDepth.y + lightOpticalDepth.y)) + (u_atmosphereRayleighCoefficient * (opticalDepth.x + lightOpticalDepth.x))));\n\n        // Accumulate the scattering.\n        rayleighAccumulation += sampleDensity.x * attenuation;\n        mieAccumulation += sampleDensity.y * attenuation;\n\n        // Increment distance on primary ray.\n        rayPositionLength += rayStepLength;\n    }\n\n    // Compute the scattering amount.\n    rayleighColor = u_atmosphereRayleighCoefficient * rayleighAccumulation;\n    mieColor = u_atmosphereMieCoefficient * mieAccumulation;\n\n    // Compute the transmittance i.e. how much light is passing through the atmosphere.\n    opacity = length(exp(-((u_atmosphereMieCoefficient * opticalDepth.y) + (u_atmosphereRayleighCoefficient * opticalDepth.x))));\n}\n\nvec4 computeAtmosphereColor(\n    vec3 positionWC,\n    vec3 lightDirection,\n    vec3 rayleighColor,\n    vec3 mieColor,\n    float opacity\n) {\n    // Setup the primary ray: from the camera position to the vertex position.\n    vec3 cameraToPositionWC = positionWC - czm_viewerPositionWC;\n    vec3 cameraToPositionWCDirection = normalize(cameraToPositionWC);\n\n    float cosAngle = dot(cameraToPositionWCDirection, lightDirection);\n    float cosAngleSq = cosAngle * cosAngle;\n\n    float G = u_atmosphereMieAnisotropy;\n    float GSq = G * G;\n\n    // The Rayleigh phase function.\n    float rayleighPhase = 3.0 / (50.2654824574) * (1.0 + cosAngleSq);\n    // The Mie phase function.\n    float miePhase = 3.0 / (25.1327412287) * ((1.0 - GSq) * (cosAngleSq + 1.0)) / (pow(1.0 + GSq - 2.0 * cosAngle * G, 1.5) * (2.0 + GSq));\n\n    // The final color is generated by combining the effects of the Rayleigh and Mie scattering.\n    vec3 rayleigh = rayleighPhase * rayleighColor;\n    vec3 mie = miePhase * mieColor;\n\n    vec3 color = (rayleigh + mie) * u_atmosphereLightIntensity;\n\n    return vec4(color, opacity);\n}\n"},b6b6:function(e,n,t){"use strict";n["a"]="varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec3 v_tangentEC;\nvarying vec3 v_bitangentEC;\nvarying vec2 v_st;\n\nvoid main()\n{\n    vec3 positionToEyeEC = -v_positionEC;\n    mat3 tangentToEyeMatrix = czm_tangentToEyeSpaceMatrix(v_normalEC, v_tangentEC, v_bitangentEC);\n\n    vec3 normalEC = normalize(v_normalEC);\n#ifdef FACE_FORWARD\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n#endif\n\n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.tangentToEyeMatrix = tangentToEyeMatrix;\n    materialInput.positionToEyeEC = positionToEyeEC;\n    materialInput.st = v_st;\n    czm_material material = czm_getMaterial(materialInput);\n\n#ifdef FLAT\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#else\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n#endif\n}\n"},c763:function(e,n,t){"use strict";t.d(n,"a",(function(){return p}));var o=t("535a"),i=t("2f63"),a=t("a7eb"),r=t("5b21"),s=t("9c90"),c=t("fdb7"),l=t("3899");function p(e){e=Object(o["a"])(e,o["a"].EMPTY_OBJECT);const n=e.extension,t=e.schema,p=[];if(Object(i["a"])(n.propertyTables))for(let o=0;o<n.propertyTables.length;o++){const i=n.propertyTables[o],r=t.classes[i.class],s=new l["a"]({count:i.count,properties:i.properties,class:r,bufferViews:e.bufferViews});p.push(new a["a"]({id:o,name:i.name,count:i.count,metadataTable:s,extras:i.extras,extensions:i.extensions}))}const u=[];if(Object(i["a"])(n.propertyTextures))for(let o=0;o<n.propertyTextures.length;o++){const i=n.propertyTextures[o];u.push(new r["a"]({id:o,name:i.name,propertyTexture:i,class:t.classes[i.class],textures:e.textures}))}const m=[];if(Object(i["a"])(n.propertyAttributes))for(let o=0;o<n.propertyAttributes.length;o++){const e=n.propertyAttributes[o];m.push(new s["a"]({id:o,name:e.name,class:t.classes[e.class],propertyAttribute:e}))}return new c["a"]({schema:t,propertyTables:p,propertyTextures:u,propertyAttributes:m,statistics:n.statistics,extras:n.extras,extensions:n.extensions})}},d007:function(e,n,t){"use strict";var o=t("535a"),i=t("2f63"),a=t("daa2"),r=t("ddf5"),s=t("8e67"),c=t("9937"),l=t("352a"),p=t("e349");function u(e,n){if(n=Object(o["a"])(n,o["a"].EMPTY_OBJECT),Object(l["a"])(e,"KHR_techniques_webgl"))return e;if(!Object(i["a"])(e.materials)||0===e.materials.length)return e;Object(i["a"])(e.extensions)||(e.extensions={}),Object(i["a"])(e.extensionsUsed)||(e.extensionsUsed=[]),Object(i["a"])(e.extensionsRequired)||(e.extensionsRequired=[]),e.extensions.KHR_techniques_webgl={programs:[],shaders:[],techniques:[]},e.extensionsUsed.push("KHR_techniques_webgl"),e.extensionsRequired.push("KHR_techniques_webgl");const t=p["a"].splitIncompatibleMaterials(e);return c["a"].material(e,(function(o,a){const r={},s=g(e,o,a,r,t,n);Object(i["a"])(o.extensions)||(o.extensions={}),o.extensions.KHR_techniques_webgl={values:r,technique:s}})),p["a"].ensureSemanticExistence(e),e}function m(e){return Object(i["a"])(e.extensions)&&Object(i["a"])(e.extensions.KHR_materials_pbrSpecularGlossiness)}function f(e,n,t,o,a){let r;const s=t[n];return Object(i["a"])(s)&&Object(i["a"])(s.texCoord)&&1===s.texCoord&&(o=o.replace("0","1")),Object(i["a"])(t[n+"Offset"])?(r=n+"Coord",a.fragmentShaderMain+=`    vec2 ${r} = computeTexCoord(${o}, ${n}Offset, ${n}Rotation, ${n}Scale);\n`):r=o,r}const d=[0,0],_=[0],v=[1,1];function h(e,n,t){if(-1===e.indexOf("Texture")||!Object(i["a"])(n.extensions)||!Object(i["a"])(n.extensions.KHR_texture_transform))return;const a="u_"+e,r=n.extensions.KHR_texture_transform;t[a+"Offset"]=Object(o["a"])(r.offset,d),t[a+"Rotation"]=Object(o["a"])(r.rotation,_),t[a+"Scale"]=Object(o["a"])(r.scale,v),Object(i["a"])(n.texCoord)&&Object(i["a"])(r.texCoord)&&(t[a].texCoord=r.texCoord)}function g(e,n,t,p,u,d){const _=Object(o["a"])(d.addBatchIdToGeneratedShaders,!1),v=e.extensions.KHR_techniques_webgl,g=v.techniques,T=v.shaders,y=v.programs,C=m(n);let x,E,O;if(!C){const e=n.pbrMetallicRoughness;if(Object(i["a"])(e))for(E in e)e.hasOwnProperty(E)&&(O=e[E],x="u_"+E,p[x]=O,h(E,O,p));else p["u_baseColorFactor"]=[1,1,1,1]}if(C){const e=n.extensions.KHR_materials_pbrSpecularGlossiness;for(E in e)e.hasOwnProperty(E)&&(O=e[E],x="u_"+E,p[x]=O,h(E,O,p))}for(const o in n)n.hasOwnProperty(o)&&(o.indexOf("Texture")>=0||o.indexOf("Factor")>=0)&&(O=n[o],x="u_"+o,p[x]=O,h(o,O,p));let S,I="precision highp float;\n",A="precision highp float;\n";Object(i["a"])(e.skins)&&(S=e.skins[0]);const D=Object(i["a"])(S)?S.joints:[],F=D.length,H=u[t];let L,z,R=!1,w=!1,j=!1,P=!1,N=!1,M=!1,G=!1,V=!1,B=!1;Object(i["a"])(H)&&(L=H.skinning,R=L.skinned&&D.length>0,w=H.hasVertexColors,j=H.hasMorphTargets,P=H.hasNormals,N=H.hasTangents,M=H.hasTexCoords,G=H.hasTexCoord1,V=H.hasOutline),j&&c["a"].mesh(e,(function(e){c["a"].meshPrimitive(e,(function(e){if(e.material===t){const n=e.targets;Object(i["a"])(n)&&(z=n)}}))}));const W={u_modelViewMatrix:{semantic:Object(l["a"])(e,"CESIUM_RTC")?"CESIUM_RTC_MODELVIEW":"MODELVIEW",type:a["a"].FLOAT_MAT4},u_projectionMatrix:{semantic:"PROJECTION",type:a["a"].FLOAT_MAT4}};Object(i["a"])(n.extensions)&&Object(i["a"])(n.extensions.KHR_materials_unlit)&&(B=!0),P&&(W.u_normalMatrix={semantic:"MODELVIEWINVERSETRANSPOSE",type:a["a"].FLOAT_MAT3}),R&&(W.u_jointMatrix={count:F,semantic:"JOINTMATRIX",type:a["a"].FLOAT_MAT4}),j&&(W.u_morphWeights={count:z.length,semantic:"MORPHWEIGHTS",type:a["a"].FLOAT});const $=n.alphaMode;for(x in Object(i["a"])($)&&"MASK"===$&&(W.u_alphaCutoff={semantic:"ALPHACUTOFF",type:a["a"].FLOAT}),p)p.hasOwnProperty(x)&&(W[x]={type:b(x)});const U=Object(o["a"])(W.u_baseColorTexture,W.u_baseColorFactor);for(x in Object(i["a"])(U)&&(U.semantic="_3DTILESDIFFUSE"),W)if(W.hasOwnProperty(x)){const e=W[x],n=Object(i["a"])(e.count)?`[${e.count}]`:"";e.type!==a["a"].FLOAT_MAT3&&e.type!==a["a"].FLOAT_MAT4&&"u_morphWeights"!==x||e.useInFragment?(A+=`uniform ${Object(r["a"])(e.type)} ${x}${n};\n`,delete e.useInFragment):I+=`uniform ${Object(r["a"])(e.type)} ${x}${n};\n`}V&&(A+="uniform sampler2D u_outlineTexture;\n");let k="";R&&(k+="    mat4 skinMatrix =\n        a_weight.x * u_jointMatrix[int(a_joint.x)] +\n        a_weight.y * u_jointMatrix[int(a_joint.y)] +\n        a_weight.z * u_jointMatrix[int(a_joint.z)] +\n        a_weight.w * u_jointMatrix[int(a_joint.w)];\n");const q={a_position:{semantic:"POSITION"}};if(V&&(q.a_outlineCoordinates={semantic:"_OUTLINE_COORDINATES"}),I+="attribute vec3 a_position;\n",P&&(I+="varying vec3 v_positionEC;\n"),V&&(I+="attribute vec3 a_outlineCoordinates;\n",I+="varying vec3 v_outlineCoordinates;\n"),k+="    vec3 weightedPosition = a_position;\n",P&&(k+="    vec3 weightedNormal = a_normal;\n"),N&&(k+="    vec4 weightedTangent = a_tangent;\n"),j)for(let o=0;o<z.length;o++){const e=z[o];for(const n in e)if(e.hasOwnProperty(n)&&"extras"!==n){const e=`a_${n}_${o}`;q[e]={semantic:`${n}_${o}`},I+=`attribute vec3 ${e};\n`,"POSITION"===n?k+=`    weightedPosition += u_morphWeights[${o}] * ${e};\n`:"NORMAL"===n?k+=`    weightedNormal += u_morphWeights[${o}] * ${e};\n`:N&&"TANGENT"===n&&(k+=`    weightedTangent.xyz += u_morphWeights[${o}] * ${e};\n`)}}k+=R?"    vec4 position = skinMatrix * vec4(weightedPosition, 1.0);\n":"    vec4 position = vec4(weightedPosition, 1.0);\n",k+="    position = u_modelViewMatrix * position;\n",P&&(k+="    v_positionEC = position.xyz;\n"),k+="    gl_Position = u_projectionMatrix * position;\n",V&&(k+="    v_outlineCoordinates = a_outlineCoordinates;\n"),P&&(q.a_normal={semantic:"NORMAL"},I+="attribute vec3 a_normal;\n",B||(I+="varying vec3 v_normal;\n",k+=R?"    v_normal = u_normalMatrix * mat3(skinMatrix) * weightedNormal;\n":"    v_normal = u_normalMatrix * weightedNormal;\n",A+="varying vec3 v_normal;\n"),A+="varying vec3 v_positionEC;\n"),N&&(q.a_tangent={semantic:"TANGENT"},I+="attribute vec4 a_tangent;\n",I+="varying vec4 v_tangent;\n",k+="    v_tangent.xyz = u_normalMatrix * weightedTangent.xyz;\n",k+="    v_tangent.w = weightedTangent.w;\n",A+="varying vec4 v_tangent;\n"),V&&(A+="varying vec3 v_outlineCoordinates;\n");let K,X,Y,J,Z,Q,ee,ne,te="";if(M){if(q.a_texcoord_0={semantic:"TEXCOORD_0"},K="v_texcoord_0",I+="attribute vec2 a_texcoord_0;\n",I+=`varying vec2 ${K};\n`,k+=`    ${K} = a_texcoord_0;\n`,A+=`varying vec2 ${K};\n`,G){q.a_texcoord_1={semantic:"TEXCOORD_1"};const e=K.replace("0","1");I+="attribute vec2 a_texcoord_1;\n",I+=`varying vec2 ${e};\n`,k+=`    ${e} = a_texcoord_1;\n`,A+=`varying vec2 ${e};\n`}const n={fragmentShaderMain:te};X=f(e,"u_normalTexture",p,K,n),Y=f(e,"u_baseColorTexture",p,K,n),J=f(e,"u_specularGlossinessTexture",p,K,n),Z=f(e,"u_diffuseTexture",p,K,n),Q=f(e,"u_metallicRoughnessTexture",p,K,n),ee=f(e,"u_occlusionTexture",p,K,n),ne=f(e,"u_emissiveTexture",p,K,n),te=n.fragmentShaderMain}R&&(q.a_joint={semantic:"JOINTS_0"},q.a_weight={semantic:"WEIGHTS_0"},I+="attribute vec4 a_joint;\n",I+="attribute vec4 a_weight;\n"),w&&(q.a_vertexColor={semantic:"COLOR_0"},I+="attribute vec4 a_vertexColor;\n",I+="varying vec4 v_vertexColor;\n",k+="  v_vertexColor = a_vertexColor;\n",A+="varying vec4 v_vertexColor;\n"),_&&(q.a_batchId={semantic:"_BATCHID"},I+="attribute float a_batchId;\n"),I+="void main(void) \n{\n",I+=k,I+="}\n",P&&!B&&(A+="const float M_PI = 3.141592653589793;\n",A+="vec3 lambertianDiffuse(vec3 diffuseColor) \n{\n    return diffuseColor / M_PI;\n}\n\n",A+="vec3 fresnelSchlick2(vec3 f0, vec3 f90, float VdotH) \n{\n    return f0 + (f90 - f0) * pow(clamp(1.0 - VdotH, 0.0, 1.0), 5.0);\n}\n\n",A+="vec3 fresnelSchlick(float metalness, float VdotH) \n{\n    return metalness + (vec3(1.0) - metalness) * pow(1.0 - VdotH, 5.0);\n}\n\n",A+="float smithVisibilityG1(float NdotV, float roughness) \n{\n    float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;\n    return NdotV / (NdotV * (1.0 - k) + k);\n}\n\n",A+="float smithVisibilityGGX(float roughness, float NdotL, float NdotV) \n{\n    return smithVisibilityG1(NdotL, roughness) * smithVisibilityG1(NdotV, roughness);\n}\n\n",A+="float GGX(float roughness, float NdotH) \n{\n    float roughnessSquared = roughness * roughness;\n    float f = (NdotH * roughnessSquared - NdotH) * NdotH + 1.0;\n    return roughnessSquared / (M_PI * f * f);\n}\n\n"),A+="vec3 SRGBtoLINEAR3(vec3 srgbIn) \n{\n    return pow(srgbIn, vec3(2.2));\n}\n\n",A+="vec4 SRGBtoLINEAR4(vec4 srgbIn) \n{\n    vec3 linearOut = pow(srgbIn.rgb, vec3(2.2));\n    return vec4(linearOut, srgbIn.a);\n}\n\n",A+="vec3 applyTonemapping(vec3 linearIn) \n{\n#ifndef HDR \n    return czm_acesTonemapping(linearIn);\n#else \n    return linearIn;\n#endif \n}\n\n",A+="vec3 LINEARtoSRGB(vec3 linearIn) \n{\n#ifndef HDR \n    return pow(linearIn, vec3(1.0/2.2));\n#else \n    return linearIn;\n#endif \n}\n\n",A+="vec2 computeTexCoord(vec2 texCoords, vec2 offset, float rotation, vec2 scale) \n{\n    rotation = -rotation; \n    mat3 transform = mat3(\n        cos(rotation) * scale.x, sin(rotation) * scale.x, 0.0, \n       -sin(rotation) * scale.y, cos(rotation) * scale.y, 0.0, \n        offset.x, offset.y, 1.0); \n    vec2 transformedTexCoords = (transform * vec3(fract(texCoords), 1.0)).xy; \n    return transformedTexCoords; \n}\n\n",A+="#ifdef USE_IBL_LIGHTING \n",A+="uniform vec2 gltf_iblFactor; \n",A+="#endif \n",A+="#ifdef USE_CUSTOM_LIGHT_COLOR \n",A+="uniform vec3 gltf_lightColor; \n",A+="#endif \n",A+="void main(void) \n{\n",A+=te,P&&!B&&(A+="    vec3 ng = normalize(v_normal);\n",A+="    vec3 positionWC = vec3(czm_inverseView * vec4(v_positionEC, 1.0));\n",Object(i["a"])(p.u_normalTexture)?N?(A+="    vec3 t = normalize(v_tangent.xyz);\n",A+="    vec3 b = normalize(cross(ng, t) * v_tangent.w);\n",A+="    mat3 tbn = mat3(t, b, ng);\n",A+=`    vec3 n = texture2D(u_normalTexture, ${X}).rgb;\n`,A+="    n = normalize(tbn * (2.0 * n - 1.0));\n"):(A="#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"+A,A+="#ifdef GL_OES_standard_derivatives\n",A+="    vec3 pos_dx = dFdx(v_positionEC);\n",A+="    vec3 pos_dy = dFdy(v_positionEC);\n",A+=`    vec3 tex_dx = dFdx(vec3(${X},0.0));\n`,A+=`    vec3 tex_dy = dFdy(vec3(${X},0.0));\n`,A+="    vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n",A+="    t = normalize(t - ng * dot(ng, t));\n",A+="    vec3 b = normalize(cross(ng, t));\n",A+="    mat3 tbn = mat3(t, b, ng);\n",A+=`    vec3 n = texture2D(u_normalTexture, ${X}).rgb;\n`,A+="    n = normalize(tbn * (2.0 * n - 1.0));\n",A+="#else\n",A+="    vec3 n = ng;\n",A+="#endif\n"):A+="    vec3 n = ng;\n",n.doubleSided&&(A+="    if (czm_backFacing())\n",A+="    {\n",A+="        n = -n;\n",A+="    }\n")),Object(i["a"])(p.u_baseColorTexture)?(A+=`    vec4 baseColorWithAlpha = SRGBtoLINEAR4(texture2D(u_baseColorTexture, ${Y}));\n`,Object(i["a"])(p.u_baseColorFactor)&&(A+="    baseColorWithAlpha *= u_baseColorFactor;\n")):Object(i["a"])(p.u_baseColorFactor)?A+="    vec4 baseColorWithAlpha = u_baseColorFactor;\n":A+="    vec4 baseColorWithAlpha = vec4(1.0);\n",w&&(A+="    baseColorWithAlpha *= v_vertexColor;\n"),A+="    vec3 baseColor = baseColorWithAlpha.rgb;\n",P&&!B?(C?(Object(i["a"])(p.u_specularGlossinessTexture)?(A+=`    vec4 specularGlossiness = SRGBtoLINEAR4(texture2D(u_specularGlossinessTexture, ${J}));\n`,A+="    vec3 specular = specularGlossiness.rgb;\n",A+="    float glossiness = specularGlossiness.a;\n",Object(i["a"])(p.u_specularFactor)&&(A+="    specular *= u_specularFactor;\n"),Object(i["a"])(p.u_glossinessFactor)&&(A+="    glossiness *= u_glossinessFactor;\n")):(Object(i["a"])(p.u_specularFactor)?A+="    vec3 specular = clamp(u_specularFactor, vec3(0.0), vec3(1.0));\n":A+="    vec3 specular = vec3(1.0);\n",Object(i["a"])(p.u_glossinessFactor)?A+="    float glossiness = clamp(u_glossinessFactor, 0.0, 1.0);\n":A+="    float glossiness = 1.0;\n"),Object(i["a"])(p.u_diffuseTexture)?(A+=`    vec4 diffuse = SRGBtoLINEAR4(texture2D(u_diffuseTexture, ${Z}));\n`,Object(i["a"])(p.u_diffuseFactor)&&(A+="    diffuse *= u_diffuseFactor;\n")):Object(i["a"])(p.u_diffuseFactor)?A+="    vec4 diffuse = clamp(u_diffuseFactor, vec4(0.0), vec4(1.0));\n":A+="    vec4 diffuse = vec4(1.0);\n",A+="    baseColorWithAlpha.a = diffuse.a;\n"):Object(i["a"])(p.u_metallicRoughnessTexture)?(A+=`    vec3 metallicRoughness = texture2D(u_metallicRoughnessTexture, ${Q}).rgb;\n`,A+="    float metalness = clamp(metallicRoughness.b, 0.0, 1.0);\n",A+="    float roughness = clamp(metallicRoughness.g, 0.04, 1.0);\n",Object(i["a"])(p.u_metallicFactor)&&(A+="    metalness *= u_metallicFactor;\n"),Object(i["a"])(p.u_roughnessFactor)&&(A+="    roughness *= u_roughnessFactor;\n")):(Object(i["a"])(p.u_metallicFactor)?A+="    float metalness = clamp(u_metallicFactor, 0.0, 1.0);\n":A+="    float metalness = 1.0;\n",Object(i["a"])(p.u_roughnessFactor)?A+="    float roughness = clamp(u_roughnessFactor, 0.04, 1.0);\n":A+="    float roughness = 1.0;\n"),A+="    vec3 v = -normalize(v_positionEC);\n",A+="#ifndef USE_CUSTOM_LIGHT_COLOR \n",A+="    vec3 lightColorHdr = czm_lightColorHdr;\n",A+="#else \n",A+="    vec3 lightColorHdr = gltf_lightColor;\n",A+="#endif \n",A+="    vec3 l = normalize(czm_lightDirectionEC);\n",A+="    vec3 h = normalize(v + l);\n",A+="    float NdotL = clamp(dot(n, l), 0.001, 1.0);\n",A+="    float NdotV = abs(dot(n, v)) + 0.001;\n",A+="    float NdotH = clamp(dot(n, h), 0.0, 1.0);\n",A+="    float LdotH = clamp(dot(l, h), 0.0, 1.0);\n",A+="    float VdotH = clamp(dot(v, h), 0.0, 1.0);\n",A+="    vec3 f0 = vec3(0.04);\n",C?(A+="    float roughness = 1.0 - glossiness;\n",A+="    vec3 diffuseColor = diffuse.rgb * (1.0 - max(max(specular.r, specular.g), specular.b));\n",A+="    vec3 specularColor = specular;\n"):(A+="    vec3 diffuseColor = baseColor * (1.0 - metalness) * (1.0 - f0);\n",A+="    vec3 specularColor = mix(f0, baseColor, metalness);\n"),A+="    float alpha = roughness * roughness;\n",A+="    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n",A+="    vec3 r90 = vec3(clamp(reflectance * 25.0, 0.0, 1.0));\n",A+="    vec3 r0 = specularColor.rgb;\n",A+="    vec3 F = fresnelSchlick2(r0, r90, VdotH);\n",A+="    float G = smithVisibilityGGX(alpha, NdotL, NdotV);\n",A+="    float D = GGX(alpha, NdotH);\n",A+="    vec3 diffuseContribution = (1.0 - F) * lambertianDiffuse(diffuseColor);\n",A+="    vec3 specularContribution = F * G * D / (4.0 * NdotL * NdotV);\n",A+="    vec3 color = NdotL * lightColorHdr * (diffuseContribution + specularContribution);\n",A+="#if defined(USE_IBL_LIGHTING) && !defined(DIFFUSE_IBL) && !defined(SPECULAR_IBL) \n",A+="    vec3 r = normalize(czm_inverseViewRotation * normalize(reflect(v, n)));\n",A+="    float vertexRadius = length(positionWC);\n",A+="    float horizonDotNadir = 1.0 - min(1.0, czm_ellipsoidRadii.x / vertexRadius);\n",A+="    float reflectionDotNadir = dot(r, normalize(positionWC));\n",A+="    r.x = -r.x;\n",A+="    r = -normalize(czm_temeToPseudoFixed * r);\n",A+="    r.x = -r.x;\n",A+="    float inverseRoughness = 1.04 - roughness;\n",A+="    inverseRoughness *= inverseRoughness;\n",A+="    vec3 sceneSkyBox = textureCube(czm_environmentMap, r).rgb * inverseRoughness;\n",A+="    float atmosphereHeight = 0.05;\n",A+="    float blendRegionSize = 0.1 * ((1.0 - inverseRoughness) * 8.0 + 1.1 - horizonDotNadir);\n",A+="    float blendRegionOffset = roughness * -1.0;\n",A+="    float farAboveHorizon = clamp(horizonDotNadir - blendRegionSize * 0.5 + blendRegionOffset, 1.0e-10 - blendRegionSize, 0.99999);\n",A+="    float aroundHorizon = clamp(horizonDotNadir + blendRegionSize * 0.5, 1.0e-10 - blendRegionSize, 0.99999);\n",A+="    float farBelowHorizon = clamp(horizonDotNadir + blendRegionSize * 1.5, 1.0e-10 - blendRegionSize, 0.99999);\n",A+="    float smoothstepHeight = smoothstep(0.0, atmosphereHeight, horizonDotNadir);\n",A+="    vec3 belowHorizonColor = mix(vec3(0.1, 0.15, 0.25), vec3(0.4, 0.7, 0.9), smoothstepHeight);\n",A+="    vec3 nadirColor = belowHorizonColor * 0.5;\n",A+="    vec3 aboveHorizonColor = mix(vec3(0.9, 1.0, 1.2), belowHorizonColor, roughness * 0.5);\n",A+="    vec3 blueSkyColor = mix(vec3(0.18, 0.26, 0.48), aboveHorizonColor, reflectionDotNadir * inverseRoughness * 0.5 + 0.75);\n",A+="    vec3 zenithColor = mix(blueSkyColor, sceneSkyBox, smoothstepHeight);\n",A+="    vec3 blueSkyDiffuseColor = vec3(0.7, 0.85, 0.9);\n",A+="    float diffuseIrradianceFromEarth = (1.0 - horizonDotNadir) * (reflectionDotNadir * 0.25 + 0.75) * smoothstepHeight;\n",A+="    float diffuseIrradianceFromSky = (1.0 - smoothstepHeight) * (1.0 - (reflectionDotNadir * 0.25 + 0.25));\n",A+="    vec3 diffuseIrradiance = blueSkyDiffuseColor * clamp(diffuseIrradianceFromEarth + diffuseIrradianceFromSky, 0.0, 1.0);\n",A+="    float notDistantRough = (1.0 - horizonDotNadir * roughness * 0.8);\n",A+="    vec3 specularIrradiance = mix(zenithColor, aboveHorizonColor, smoothstep(farAboveHorizon, aroundHorizon, reflectionDotNadir) * notDistantRough);\n",A+="    specularIrradiance = mix(specularIrradiance, belowHorizonColor, smoothstep(aroundHorizon, farBelowHorizon, reflectionDotNadir) * inverseRoughness);\n",A+="    specularIrradiance = mix(specularIrradiance, nadirColor, smoothstep(farBelowHorizon, 1.0, reflectionDotNadir) * inverseRoughness);\n",A+="#ifdef USE_SUN_LUMINANCE \n",A+="    float LdotZenith = clamp(dot(normalize(czm_inverseViewRotation * l), normalize(positionWC * -1.0)), 0.001, 1.0);\n",A+="    float S = acos(LdotZenith);\n",A+="    float NdotZenith = clamp(dot(normalize(czm_inverseViewRotation * n), normalize(positionWC * -1.0)), 0.001, 1.0);\n",A+="    float gamma = acos(NdotL);\n",A+="    float numerator = ((0.91 + 10.0 * exp(-3.0 * gamma) + 0.45 * pow(NdotL, 2.0)) * (1.0 - exp(-0.32 / NdotZenith)));\n",A+="    float denominator = (0.91 + 10.0 * exp(-3.0 * S) + 0.45 * pow(LdotZenith,2.0)) * (1.0 - exp(-0.32));\n",A+="    float luminance = gltf_luminanceAtZenith * (numerator / denominator);\n",A+="#endif \n",A+="    vec2 brdfLut = texture2D(czm_brdfLut, vec2(NdotV, roughness)).rg;\n",A+="    vec3 IBLColor = (diffuseIrradiance * diffuseColor * gltf_iblFactor.x) + (specularIrradiance * SRGBtoLINEAR3(specularColor * brdfLut.x + brdfLut.y) * gltf_iblFactor.y);\n",A+="    float maximumComponent = max(max(lightColorHdr.x, lightColorHdr.y), lightColorHdr.z);\n",A+="    vec3 lightColor = lightColorHdr / max(maximumComponent, 1.0);\n",A+="    IBLColor *= lightColor;\n",A+="#ifdef USE_SUN_LUMINANCE \n",A+="    color += IBLColor * luminance;\n",A+="#else \n",A+="    color += IBLColor; \n",A+="#endif \n",A+="#elif defined(DIFFUSE_IBL) || defined(SPECULAR_IBL) \n",A+="    const mat3 yUpToZUp = mat3(-1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0); \n",A+="    vec3 cubeDir = normalize(yUpToZUp * gltf_iblReferenceFrameMatrix * normalize(reflect(-v, n))); \n",A+="#ifdef DIFFUSE_IBL \n",A+="#ifdef CUSTOM_SPHERICAL_HARMONICS \n",A+="    vec3 diffuseIrradiance = czm_sphericalHarmonics(cubeDir, gltf_sphericalHarmonicCoefficients); \n",A+="#else \n",A+="    vec3 diffuseIrradiance = czm_sphericalHarmonics(cubeDir, czm_sphericalHarmonicCoefficients); \n",A+="#endif \n",A+="#else \n",A+="    vec3 diffuseIrradiance = vec3(0.0); \n",A+="#endif \n",A+="#ifdef SPECULAR_IBL \n",A+="    vec2 brdfLut = texture2D(czm_brdfLut, vec2(NdotV, roughness)).rg;\n",A+="#ifdef CUSTOM_SPECULAR_IBL \n",A+="    vec3 specularIBL = czm_sampleOctahedralProjection(gltf_specularMap, gltf_specularMapSize, cubeDir,  roughness * gltf_maxSpecularLOD, gltf_maxSpecularLOD);\n",A+="#else \n",A+="    vec3 specularIBL = czm_sampleOctahedralProjection(czm_specularEnvironmentMaps, czm_specularEnvironmentMapSize, cubeDir,  roughness * czm_specularEnvironmentMapsMaximumLOD, czm_specularEnvironmentMapsMaximumLOD);\n",A+="#endif \n",A+="    specularIBL *= F * brdfLut.x + brdfLut.y;\n",A+="#else \n",A+="    vec3 specularIBL = vec3(0.0); \n",A+="#endif \n",A+="    color += diffuseIrradiance * diffuseColor + specularColor * specularIBL;\n",A+="#endif \n"):A+="    vec3 color = baseColor;\n",B||(Object(i["a"])(p.u_occlusionTexture)&&(A+=`    color *= texture2D(u_occlusionTexture, ${ee}).r;\n`),Object(i["a"])(p.u_emissiveTexture)?(A+=`    vec3 emissive = SRGBtoLINEAR3(texture2D(u_emissiveTexture, ${ne}).rgb);\n`,Object(i["a"])(p.u_emissiveFactor)&&(A+="    emissive *= u_emissiveFactor;\n"),A+="    color += emissive;\n"):Object(i["a"])(p.u_emissiveFactor)&&(A+="    color += u_emissiveFactor;\n")),B||(A+="    color = applyTonemapping(color);\n"),A+="    color = LINEARtoSRGB(color);\n",V&&(A+="    float outlineness = max(\n",A+="        texture2D(u_outlineTexture, vec2(v_outlineCoordinates.x, 0.5)).r,\n",A+="        max(\n",A+="          texture2D(u_outlineTexture, vec2(v_outlineCoordinates.y, 0.5)).r,\n",A+="          texture2D(u_outlineTexture, vec2(v_outlineCoordinates.z, 0.5)).r));\n",A+="    color = mix(color, vec3(0.0, 0.0, 0.0), outlineness);\n"),Object(i["a"])($)?"MASK"===$?(A+="    if (baseColorWithAlpha.a < u_alphaCutoff) {\n",A+="        discard;\n",A+="    }\n",A+="    gl_FragColor = vec4(color, 1.0);\n"):A+="BLEND"===$?"    gl_FragColor = vec4(color, baseColorWithAlpha.a);\n":"    gl_FragColor = vec4(color, 1.0);\n":A+="    gl_FragColor = vec4(color, 1.0);\n",A+="}\n";const oe=Object(s["a"])(T,{type:a["a"].VERTEX_SHADER,extras:{_pipeline:{source:I,extension:".glsl"}}}),ie=Object(s["a"])(T,{type:a["a"].FRAGMENT_SHADER,extras:{_pipeline:{source:A,extension:".glsl"}}}),ae=Object(s["a"])(y,{fragmentShader:ie,vertexShader:oe}),re=Object(s["a"])(g,{attributes:q,program:ae,uniforms:W});return re}function b(e){if(-1!==e.indexOf("Offset"))return a["a"].FLOAT_VEC2;if(-1!==e.indexOf("Rotation"))return a["a"].FLOAT;if(-1!==e.indexOf("Scale"))return a["a"].FLOAT_VEC2;if(-1!==e.indexOf("Texture"))return a["a"].SAMPLER_2D;switch(e){case"u_baseColorFactor":return a["a"].FLOAT_VEC4;case"u_metallicFactor":return a["a"].FLOAT;case"u_roughnessFactor":return a["a"].FLOAT;case"u_emissiveFactor":return a["a"].FLOAT_VEC3;case"u_diffuseFactor":return a["a"].FLOAT_VEC4;case"u_specularFactor":return a["a"].FLOAT_VEC3;case"u_glossinessFactor":return a["a"].FLOAT}}n["a"]=u},d3d4:function(e,n,t){"use strict";n["a"]="#ifdef INSTANCED\nattribute vec2 direction;\n#endif\nattribute vec4 positionHighAndScale;\nattribute vec4 positionLowAndRotation;\nattribute vec4 compressedAttribute0;                       // pixel offset, translate, horizontal origin, vertical origin, show, direction, texture coordinates (texture offset)\nattribute vec4 compressedAttribute1;                       // aligned axis, translucency by distance, image width\nattribute vec4 compressedAttribute2;                       // label horizontal origin, image height, color, pick color, size in meters, valid aligned axis, 13 bits free\nattribute vec4 eyeOffset;                                  // eye offset in meters, 4 bytes free (texture range)\nattribute vec4 scaleByDistance;                            // near, nearScale, far, farScale\nattribute vec4 pixelOffsetScaleByDistance;                 // near, nearScale, far, farScale\nattribute vec4 compressedAttribute3;                       // distance display condition near, far, disableDepthTestDistance, dimensions\nattribute vec2 sdf;                                        // sdf outline color (rgb) and width (w)\n#if defined(VERTEX_DEPTH_CHECK) || defined(FRAGMENT_DEPTH_CHECK)\nattribute vec4 textureCoordinateBoundsOrLabelTranslate;    // the min and max x and y values for the texture coordinates\n#endif\n#ifdef VECTOR_TILE\nattribute float a_batchId;\n#endif\n\nvarying vec2 v_textureCoordinates;\n#ifdef FRAGMENT_DEPTH_CHECK\nvarying vec4 v_textureCoordinateBounds;\nvarying vec4 v_originTextureCoordinateAndTranslate;\nvarying vec4 v_compressed;                                 // x: eyeDepth, y: applyTranslate & enableDepthCheck, z: dimensions, w: imageSize\nvarying mat2 v_rotationMatrix;\n#endif\n\nvarying vec4 v_pickColor;\nvarying vec4 v_color;\n#ifdef SDF\nvarying vec4 v_outlineColor;\nvarying float v_outlineWidth;\n#endif\n\nconst float UPPER_BOUND = 32768.0;\n\nconst float SHIFT_LEFT16 = 65536.0;\nconst float SHIFT_LEFT12 = 4096.0;\nconst float SHIFT_LEFT8 = 256.0;\nconst float SHIFT_LEFT7 = 128.0;\nconst float SHIFT_LEFT5 = 32.0;\nconst float SHIFT_LEFT3 = 8.0;\nconst float SHIFT_LEFT2 = 4.0;\nconst float SHIFT_LEFT1 = 2.0;\n\nconst float SHIFT_RIGHT12 = 1.0 / 4096.0;\nconst float SHIFT_RIGHT8 = 1.0 / 256.0;\nconst float SHIFT_RIGHT7 = 1.0 / 128.0;\nconst float SHIFT_RIGHT5 = 1.0 / 32.0;\nconst float SHIFT_RIGHT3 = 1.0 / 8.0;\nconst float SHIFT_RIGHT2 = 1.0 / 4.0;\nconst float SHIFT_RIGHT1 = 1.0 / 2.0;\n\nvec4 addScreenSpaceOffset(vec4 positionEC, vec2 imageSize, float scale, vec2 direction, vec2 origin, vec2 translate, vec2 pixelOffset, vec3 alignedAxis, bool validAlignedAxis, float rotation, bool sizeInMeters, out mat2 rotationMatrix, out float mpp)\n{\n    // Note the halfSize cannot be computed in JavaScript because it is sent via\n    // compressed vertex attributes that coerce it to an integer.\n    vec2 halfSize = imageSize * scale * 0.5;\n    halfSize *= ((direction * 2.0) - 1.0);\n\n    vec2 originTranslate = origin * abs(halfSize);\n\n#if defined(ROTATION) || defined(ALIGNED_AXIS)\n    if (validAlignedAxis || rotation != 0.0)\n    {\n        float angle = rotation;\n        if (validAlignedAxis)\n        {\n            vec4 projectedAlignedAxis = czm_modelViewProjection * vec4(alignedAxis, 0.0);\n            angle += sign(-projectedAlignedAxis.x) * acos(sign(projectedAlignedAxis.y) * (projectedAlignedAxis.y * projectedAlignedAxis.y) /\n                    (projectedAlignedAxis.x * projectedAlignedAxis.x + projectedAlignedAxis.y * projectedAlignedAxis.y));\n        }\n\n        float cosTheta = cos(angle);\n        float sinTheta = sin(angle);\n        rotationMatrix = mat2(cosTheta, sinTheta, -sinTheta, cosTheta);\n        halfSize = rotationMatrix * halfSize;\n    }\n    else\n    {\n        rotationMatrix = mat2(1.0, 0.0, 0.0, 1.0);\n    }\n#endif\n\n    mpp = czm_metersPerPixel(positionEC);\n    positionEC.xy += (originTranslate + halfSize) * czm_branchFreeTernary(sizeInMeters, 1.0, mpp);\n    positionEC.xy += (translate + pixelOffset) * mpp;\n\n    return positionEC;\n}\n\n#ifdef VERTEX_DEPTH_CHECK\nfloat getGlobeDepth(vec4 positionEC)\n{\n    vec4 posWC = czm_eyeToWindowCoordinates(positionEC);\n\n    float globeDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, posWC.xy / czm_viewport.zw));\n\n    if (globeDepth == 0.0)\n    {\n        return 0.0; // not on the globe\n    }\n\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(posWC.xy, globeDepth);\n    return eyeCoordinate.z / eyeCoordinate.w;\n}\n#endif\nvoid main()\n{\n    // Modifying this shader may also require modifications to Billboard._computeScreenSpacePosition\n\n    // unpack attributes\n    vec3 positionHigh = positionHighAndScale.xyz;\n    vec3 positionLow = positionLowAndRotation.xyz;\n    float scale = positionHighAndScale.w;\n\n#if defined(ROTATION) || defined(ALIGNED_AXIS)\n    float rotation = positionLowAndRotation.w;\n#else\n    float rotation = 0.0;\n#endif\n\n    float compressed = compressedAttribute0.x;\n\n    vec2 pixelOffset;\n    pixelOffset.x = floor(compressed * SHIFT_RIGHT7);\n    compressed -= pixelOffset.x * SHIFT_LEFT7;\n    pixelOffset.x -= UPPER_BOUND;\n\n    vec2 origin;\n    origin.x = floor(compressed * SHIFT_RIGHT5);\n    compressed -= origin.x * SHIFT_LEFT5;\n\n    origin.y = floor(compressed * SHIFT_RIGHT3);\n    compressed -= origin.y * SHIFT_LEFT3;\n\n#ifdef FRAGMENT_DEPTH_CHECK\n    vec2 depthOrigin = origin.xy;\n#endif\n    origin -= vec2(1.0);\n\n    float show = floor(compressed * SHIFT_RIGHT2);\n    compressed -= show * SHIFT_LEFT2;\n\n#ifdef INSTANCED\n    vec2 textureCoordinatesBottomLeft = czm_decompressTextureCoordinates(compressedAttribute0.w);\n    vec2 textureCoordinatesRange = czm_decompressTextureCoordinates(eyeOffset.w);\n    vec2 textureCoordinates = textureCoordinatesBottomLeft + direction * textureCoordinatesRange;\n#else\n    vec2 direction;\n    direction.x = floor(compressed * SHIFT_RIGHT1);\n    direction.y = compressed - direction.x * SHIFT_LEFT1;\n\n    vec2 textureCoordinates = czm_decompressTextureCoordinates(compressedAttribute0.w);\n#endif\n\n    float temp = compressedAttribute0.y  * SHIFT_RIGHT8;\n    pixelOffset.y = -(floor(temp) - UPPER_BOUND);\n\n    vec2 translate;\n    translate.y = (temp - floor(temp)) * SHIFT_LEFT16;\n\n    temp = compressedAttribute0.z * SHIFT_RIGHT8;\n    translate.x = floor(temp) - UPPER_BOUND;\n\n    translate.y += (temp - floor(temp)) * SHIFT_LEFT8;\n    translate.y -= UPPER_BOUND;\n\n    temp = compressedAttribute1.x * SHIFT_RIGHT8;\n    float temp2 = floor(compressedAttribute2.w * SHIFT_RIGHT2);\n\n    vec2 imageSize = vec2(floor(temp), temp2);\n\n#ifdef FRAGMENT_DEPTH_CHECK\n    float labelHorizontalOrigin = floor(compressedAttribute2.w - (temp2 * SHIFT_LEFT2));\n    float applyTranslate = 0.0;\n    if (labelHorizontalOrigin != 0.0) // is a billboard, so set apply translate to false\n    {\n        applyTranslate = 1.0;\n        labelHorizontalOrigin -= 2.0;\n        depthOrigin.x = labelHorizontalOrigin + 1.0;\n    }\n\n    depthOrigin = vec2(1.0) - (depthOrigin * 0.5);\n#endif\n\n#ifdef EYE_DISTANCE_TRANSLUCENCY\n    vec4 translucencyByDistance;\n    translucencyByDistance.x = compressedAttribute1.z;\n    translucencyByDistance.z = compressedAttribute1.w;\n\n    translucencyByDistance.y = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;\n\n    temp = compressedAttribute1.y * SHIFT_RIGHT8;\n    translucencyByDistance.w = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;\n#endif\n\n#if defined(VERTEX_DEPTH_CHECK) || defined(FRAGMENT_DEPTH_CHECK)\n    temp = compressedAttribute3.w;\n    temp = temp * SHIFT_RIGHT12;\n\n    vec2 dimensions;\n    dimensions.y = (temp - floor(temp)) * SHIFT_LEFT12;\n    dimensions.x = floor(temp);\n#endif\n\n#ifdef ALIGNED_AXIS\n    vec3 alignedAxis = czm_octDecode(floor(compressedAttribute1.y * SHIFT_RIGHT8));\n    temp = compressedAttribute2.z * SHIFT_RIGHT5;\n    bool validAlignedAxis = (temp - floor(temp)) * SHIFT_LEFT1 > 0.0;\n#else\n    vec3 alignedAxis = vec3(0.0);\n    bool validAlignedAxis = false;\n#endif\n\n    vec4 pickColor;\n    vec4 color;\n\n    temp = compressedAttribute2.y;\n    temp = temp * SHIFT_RIGHT8;\n    pickColor.b = (temp - floor(temp)) * SHIFT_LEFT8;\n    temp = floor(temp) * SHIFT_RIGHT8;\n    pickColor.g = (temp - floor(temp)) * SHIFT_LEFT8;\n    pickColor.r = floor(temp);\n\n    temp = compressedAttribute2.x;\n    temp = temp * SHIFT_RIGHT8;\n    color.b = (temp - floor(temp)) * SHIFT_LEFT8;\n    temp = floor(temp) * SHIFT_RIGHT8;\n    color.g = (temp - floor(temp)) * SHIFT_LEFT8;\n    color.r = floor(temp);\n\n    temp = compressedAttribute2.z * SHIFT_RIGHT8;\n    bool sizeInMeters = floor((temp - floor(temp)) * SHIFT_LEFT7) > 0.0;\n    temp = floor(temp) * SHIFT_RIGHT8;\n\n    pickColor.a = (temp - floor(temp)) * SHIFT_LEFT8;\n    pickColor /= 255.0;\n\n    color.a = floor(temp);\n    color /= 255.0;\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\n    vec4 positionEC = czm_modelViewRelativeToEye * p;\n\n#if defined(FRAGMENT_DEPTH_CHECK) || defined(VERTEX_DEPTH_CHECK)\n    float eyeDepth = positionEC.z;\n#endif\n\n    positionEC = czm_eyeOffset(positionEC, eyeOffset.xyz);\n    positionEC.xyz *= show;\n\n    ///////////////////////////////////////////////////////////////////////////\n\n#if defined(EYE_DISTANCE_SCALING) || defined(EYE_DISTANCE_TRANSLUCENCY) || defined(EYE_DISTANCE_PIXEL_OFFSET) || defined(DISTANCE_DISPLAY_CONDITION) || defined(DISABLE_DEPTH_DISTANCE)\n    float lengthSq;\n    if (czm_sceneMode == czm_sceneMode2D)\n    {\n        // 2D camera distance is a special case\n        // treat all billboards as flattened to the z=0.0 plane\n        lengthSq = czm_eyeHeight2D.y;\n    }\n    else\n    {\n        lengthSq = dot(positionEC.xyz, positionEC.xyz);\n    }\n#endif\n\n#ifdef EYE_DISTANCE_SCALING\n    float distanceScale = czm_nearFarScalar(scaleByDistance, lengthSq);\n    scale *= distanceScale;\n    translate *= distanceScale;\n    // push vertex behind near plane for clipping\n    if (scale == 0.0)\n    {\n        positionEC.xyz = vec3(0.0);\n    }\n#endif\n\n    float translucency = 1.0;\n#ifdef EYE_DISTANCE_TRANSLUCENCY\n    translucency = czm_nearFarScalar(translucencyByDistance, lengthSq);\n    // push vertex behind near plane for clipping\n    if (translucency == 0.0)\n    {\n        positionEC.xyz = vec3(0.0);\n    }\n#endif\n\n#ifdef EYE_DISTANCE_PIXEL_OFFSET\n    float pixelOffsetScale = czm_nearFarScalar(pixelOffsetScaleByDistance, lengthSq);\n    pixelOffset *= pixelOffsetScale;\n#endif\n\n#ifdef DISTANCE_DISPLAY_CONDITION\n    float nearSq = compressedAttribute3.x;\n    float farSq = compressedAttribute3.y;\n    if (lengthSq < nearSq || lengthSq > farSq)\n    {\n        positionEC.xyz = vec3(0.0);\n    }\n#endif\n\n    mat2 rotationMatrix;\n    float mpp;\n\n#ifdef DISABLE_DEPTH_DISTANCE\n    float disableDepthTestDistance = compressedAttribute3.z;\n#endif\n\n#ifdef VERTEX_DEPTH_CHECK\nif (lengthSq < disableDepthTestDistance) {\n    float depthsilon = 10.0;\n\n    vec2 labelTranslate = textureCoordinateBoundsOrLabelTranslate.xy;\n    vec4 pEC1 = addScreenSpaceOffset(positionEC, dimensions, scale, vec2(0.0), origin, labelTranslate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);\n    float globeDepth1 = getGlobeDepth(pEC1);\n\n    if (globeDepth1 != 0.0 && pEC1.z + depthsilon < globeDepth1)\n    {\n        vec4 pEC2 = addScreenSpaceOffset(positionEC, dimensions, scale, vec2(0.0, 1.0), origin, labelTranslate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);\n        float globeDepth2 = getGlobeDepth(pEC2);\n\n        if (globeDepth2 != 0.0 && pEC2.z + depthsilon < globeDepth2)\n        {\n            vec4 pEC3 = addScreenSpaceOffset(positionEC, dimensions, scale, vec2(1.0), origin, labelTranslate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);\n            float globeDepth3 = getGlobeDepth(pEC3);\n            if (globeDepth3 != 0.0 && pEC3.z + depthsilon < globeDepth3)\n            {\n                positionEC.xyz = vec3(0.0);\n            }\n        }\n    }\n}\n#endif\n\n    positionEC = addScreenSpaceOffset(positionEC, imageSize, scale, direction, origin, translate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);\n    gl_Position = czm_projection * positionEC;\n    v_textureCoordinates = textureCoordinates;\n\n#ifdef LOG_DEPTH\n    czm_vertexLogDepth();\n#endif\n\n#ifdef DISABLE_DEPTH_DISTANCE\n    if (disableDepthTestDistance == 0.0 && czm_minimumDisableDepthTestDistance != 0.0)\n    {\n        disableDepthTestDistance = czm_minimumDisableDepthTestDistance;\n    }\n\n    if (disableDepthTestDistance != 0.0)\n    {\n        // Don't try to \"multiply both sides\" by w.  Greater/less-than comparisons won't work for negative values of w.\n        float zclip = gl_Position.z / gl_Position.w;\n        bool clipped = (zclip < -1.0 || zclip > 1.0);\n        if (!clipped && (disableDepthTestDistance < 0.0 || (lengthSq > 0.0 && lengthSq < disableDepthTestDistance)))\n        {\n            // Position z on the near plane.\n            gl_Position.z = -gl_Position.w;\n#ifdef LOG_DEPTH\n            v_depthFromNearPlusOne = 1.0;\n#endif\n        }\n    }\n#endif\n\n#ifdef FRAGMENT_DEPTH_CHECK\n    if (sizeInMeters) {\n        translate /= mpp;\n        dimensions /= mpp;\n        imageSize /= mpp;\n    }\n\n#if defined(ROTATION) || defined(ALIGNED_AXIS)\n    v_rotationMatrix = rotationMatrix;\n#else\n    v_rotationMatrix = mat2(1.0, 0.0, 0.0, 1.0);\n#endif\n\n    float enableDepthCheck = 0.0;\n    if (lengthSq < disableDepthTestDistance)\n    {\n        enableDepthCheck = 1.0;\n    }\n\n    float dw = floor(clamp(dimensions.x, 0.0, SHIFT_LEFT12));\n    float dh = floor(clamp(dimensions.y, 0.0, SHIFT_LEFT12));\n\n    float iw = floor(clamp(imageSize.x, 0.0, SHIFT_LEFT12));\n    float ih = floor(clamp(imageSize.y, 0.0, SHIFT_LEFT12));\n\n    v_compressed.x = eyeDepth;\n    v_compressed.y = applyTranslate * SHIFT_LEFT1 + enableDepthCheck;\n    v_compressed.z = dw * SHIFT_LEFT12 + dh;\n    v_compressed.w = iw * SHIFT_LEFT12 + ih;\n    v_originTextureCoordinateAndTranslate.xy = depthOrigin;\n    v_originTextureCoordinateAndTranslate.zw = translate;\n    v_textureCoordinateBounds = textureCoordinateBoundsOrLabelTranslate;\n\n#endif\n\n#ifdef SDF\n    vec4 outlineColor;\n    float outlineWidth;\n\n    temp = sdf.x;\n    temp = temp * SHIFT_RIGHT8;\n    outlineColor.b = (temp - floor(temp)) * SHIFT_LEFT8;\n    temp = floor(temp) * SHIFT_RIGHT8;\n    outlineColor.g = (temp - floor(temp)) * SHIFT_LEFT8;\n    outlineColor.r = floor(temp);\n\n    temp = sdf.y;\n    temp = temp * SHIFT_RIGHT8;\n    float temp3 = (temp - floor(temp)) * SHIFT_LEFT8;\n    temp = floor(temp) * SHIFT_RIGHT8;\n    outlineWidth = (temp - floor(temp)) * SHIFT_LEFT8;\n    outlineColor.a = floor(temp);\n    outlineColor /= 255.0;\n\n    v_outlineWidth = outlineWidth / 255.0;\n    v_outlineColor = outlineColor;\n    v_outlineColor.a *= translucency;\n#endif\n\n    v_pickColor = pickColor;\n\n    v_color = color;\n    v_color.a *= translucency;\n\n}\n"},d3f9:function(e,n,t){"use strict";n["a"]="varying vec4 v_color;\n\nvoid main()\n{\n    gl_FragColor = czm_gammaCorrect(v_color);\n}\n"},f533:function(e,n,t){"use strict";n["a"]="varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec4 v_color;\n\nvoid main()\n{\n    vec3 positionToEyeEC = -v_positionEC;\n\n    vec3 normalEC = normalize(v_normalEC);\n#ifdef FACE_FORWARD\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n#endif\n\n    vec4 color = czm_gammaCorrect(v_color);\n\n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n}\n"},fa74:function(e,n,t){"use strict";t.d(n,"a",(function(){return b}));var o=t("abab"),i=t("2f63"),a=t("535a"),r=t("45c5"),s=t("283e"),c=t("67b9"),l=t("fdb7"),p=t("9c90"),u=t("a7eb"),m=t("c13c"),f=t("53c8"),d=t("21d4"),_=t("5637"),v=t("3899"),h=t("8bde"),g=t("60e0");function b(e){const n=e.count,t=e.batchTable,o=e.binaryBody,i=Object(a["a"])(e.parseAsPropertyAttributes,!1),r=e.customAttributeOutput,s=T(t),c=new f["a"]({count:n,properties:s.jsonProperties}),m=O(s.hierarchy,o),_=d["a"].BATCH_TABLE_CLASS_NAME;let h,g,b;if(i){const e=C(n,_,s.binaryProperties,o,r);b=e.transcodedSchema;const t=new p["a"]({propertyAttribute:e.propertyAttributeJson,class:e.transcodedClass});g=[t]}else{const e=y(n,_,s.binaryProperties,o);b=e.transcodedSchema;const t=e.featureTableJson;h=new v["a"]({count:t.count,properties:t.properties,class:e.transcodedClass,bufferViews:e.bufferViewsTypedArrays}),g=[]}const x=new u["a"]({id:0,name:"Batch Table",count:n,metadataTable:h,jsonMetadataTable:c,batchTableHierarchy:m}),E={schema:b,propertyTables:[x],propertyAttributes:g,extensions:s.extensions,extras:s.extras};return new l["a"](E)}function T(e){const n=e.HIERARCHY,t=e.extras,o=e.extensions;let a;Object(i["a"])(n)?(b._deprecationWarning("batchTableHierarchyExtension","The batch table HIERARCHY property has been moved to an extension. Use extensions.3DTILES_batch_table_hierarchy instead."),a=n):Object(i["a"])(o)&&(a=o["3DTILES_batch_table_hierarchy"]);const r={},s={};for(const i in e){if(!e.hasOwnProperty(i)||"HIERARCHY"===i||"extensions"===i||"extras"===i)continue;const n=e[i];Array.isArray(n)?r[i]=n:s[i]=n}return{binaryProperties:s,jsonProperties:r,hierarchy:a,extras:t,extensions:o}}function y(e,n,t,o){const a={},r={},c={};let l=0;for(const d in t){if(!t.hasOwnProperty(d))continue;if(!Object(i["a"])(o))throw new s["a"](`Property ${d} requires a batch table binary.`);const n=t[d],p=Object(m["a"])(n);r[d]={bufferView:l},a[d]=x(n),c[l]=p.createArrayBufferView(o.buffer,o.byteOffset+n.byteOffset,e),l++}const p={classes:{}};p.classes[n]={properties:a};const u=new _["a"](p),f={class:n,count:e,properties:r};return{featureTableJson:f,bufferViewsTypedArrays:c,transcodedSchema:u,transcodedClass:u.classes[n]}}function C(e,n,t,a,r){const c={},l={};let p=0;for(const _ in t){if(!t.hasOwnProperty(_))continue;const n=t[_];if(!Object(i["a"])(a)&&!Object(i["a"])(n.typedArray))throw new s["a"](`Property ${_} requires a batch table binary.`);let u=g["a"].sanitizeGlslIdentifier(_);(""===u||c.hasOwnProperty(u))&&(u="property_"+p,p++);const f=x(n);f.name=_,c[u]=f;let d=u.toUpperCase();d.startsWith("_")||(d="_"+d);let v=n.typedArray;if(!Object(i["a"])(v)){const t=Object(m["a"])(n);v=t.createArrayBufferView(a.buffer,a.byteOffset+n.byteOffset,e)}const b=new h["a"].Attribute;b.name=d,b.count=e,b.type=n.type,b.componentDatatype=o["a"].fromTypedArray(v),b.typedArray=v,r.push(b),l[u]={attribute:d}}const u={classes:{}};u.classes[n]={properties:c};const f=new _["a"](u),d={properties:l};return{class:n,propertyAttributeJson:d,transcodedSchema:f,transcodedClass:f.classes[n]}}function x(e){const n=E(e.componentType);return{type:e.type,componentType:n}}function E(e){switch(e){case"BYTE":return"INT8";case"UNSIGNED_BYTE":return"UINT8";case"SHORT":return"INT16";case"UNSIGNED_SHORT":return"UINT16";case"INT":return"INT32";case"UNSIGNED_INT":return"UINT32";case"FLOAT":return"FLOAT32";case"DOUBLE":return"FLOAT64"}}function O(e,n){if(Object(i["a"])(e))return new c["a"]({extension:e,binaryBody:n})}b._deprecationWarning=r["a"]}}]);