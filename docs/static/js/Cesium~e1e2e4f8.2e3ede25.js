(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["Cesium~e1e2e4f8"],{1757:function(e,t,a){"use strict";var n=a("2f63");function o(e,t){this.positions=Object(n["a"])(e)?e:[],this.holes=Object(n["a"])(t)?t:[]}t["a"]=o},"188e":function(e,t,a){"use strict";var n=a("be18"),o=a("a561"),r=a("2f63"),i=a("52f0");function s(e,t){this.normal=n["a"].clone(e),this.distance=t}s.fromPointNormal=function(e,t,a){const o=-n["a"].dot(t,e);return Object(r["a"])(a)?(n["a"].clone(t,a.normal),a.distance=o,a):new s(t,o)};const c=new n["a"];s.fromCartesian4=function(e,t){const a=n["a"].fromCartesian4(e,c),o=e.w;return Object(r["a"])(t)?(n["a"].clone(a,t.normal),t.distance=o,t):new s(a,o)},s.getPointDistance=function(e,t){return n["a"].dot(e.normal,t)+e.distance};const l=new n["a"];s.projectPointOntoPlane=function(e,t,a){Object(r["a"])(a)||(a=new n["a"]);const o=s.getPointDistance(e,t),i=n["a"].multiplyByScalar(e.normal,o,l);return n["a"].subtract(t,i,a)};const u=new i["a"],p=new o["a"],h=new n["a"];s.transform=function(e,t,a){const r=e.normal,c=e.distance,l=i["a"].inverseTranspose(t,u);let d=o["a"].fromElements(r.x,r.y,r.z,c,p);d=i["a"].multiplyByVector(l,d,d);const g=n["a"].fromCartesian4(d,h);return d=o["a"].divideByScalar(d,n["a"].magnitude(g),d),s.fromCartesian4(d,a)},s.clone=function(e,t){return Object(r["a"])(t)?(n["a"].clone(e.normal,t.normal),t.distance=e.distance,t):new s(e.normal,e.distance)},s.equals=function(e,t){return e.distance===t.distance&&n["a"].equals(e.normal,t.normal)},s.ORIGIN_XY_PLANE=Object.freeze(new s(n["a"].UNIT_Z,0)),s.ORIGIN_YZ_PLANE=Object.freeze(new s(n["a"].UNIT_X,0)),s.ORIGIN_ZX_PLANE=Object.freeze(new s(n["a"].UNIT_Y,0)),t["a"]=s},"1b8d":function(e,t,a){"use strict";var n=a("daa2");const o={POINTS:n["a"].POINTS,LINES:n["a"].LINES,LINE_LOOP:n["a"].LINE_LOOP,LINE_STRIP:n["a"].LINE_STRIP,TRIANGLES:n["a"].TRIANGLES,TRIANGLE_STRIP:n["a"].TRIANGLE_STRIP,TRIANGLE_FAN:n["a"].TRIANGLE_FAN,isLines:function(e){return e===o.LINES||e===o.LINE_LOOP||e===o.LINE_STRIP},isTriangles:function(e){return e===o.TRIANGLES||e===o.TRIANGLE_STRIP||e===o.TRIANGLE_FAN},validate:function(e){return e===o.POINTS||e===o.LINES||e===o.LINE_LOOP||e===o.LINE_STRIP||e===o.TRIANGLES||e===o.TRIANGLE_STRIP||e===o.TRIANGLE_FAN}};t["a"]=Object.freeze(o)},2105:function(e,t,a){"use strict";var n=a("cef5"),o=a("be18"),r=a("abab"),i=a("535a"),s=a("2f63"),c=a("d2c7"),l=a("81d7"),u=a("473c"),p=a("1b8d"),h=a("0541");function d(e){e=Object(i["a"])(e,i["a"].EMPTY_OBJECT);const t=Object(i["a"])(e.vertexFormat,h["a"].DEFAULT);this._vertexFormat=t,this._workerName="createPlaneGeometry"}d.packedLength=h["a"].packedLength,d.pack=function(e,t,a){return a=Object(i["a"])(a,0),h["a"].pack(e._vertexFormat,t,a),t};const g=new h["a"],y={vertexFormat:g};d.unpack=function(e,t,a){t=Object(i["a"])(t,0);const n=h["a"].unpack(e,t,g);return Object(s["a"])(a)?(a._vertexFormat=h["a"].clone(n,a._vertexFormat),a):new d(y)};const f=new o["a"](-.5,-.5,0),m=new o["a"](.5,.5,0);d.createGeometry=function(e){const t=e._vertexFormat,a=new u["a"];let i,s;if(t.position){if(s=new Float64Array(12),s[0]=f.x,s[1]=f.y,s[2]=0,s[3]=m.x,s[4]=f.y,s[5]=0,s[6]=m.x,s[7]=m.y,s[8]=0,s[9]=f.x,s[10]=m.y,s[11]=0,a.position=new l["a"]({componentDatatype:r["a"].DOUBLE,componentsPerAttribute:3,values:s}),t.normal){const e=new Float32Array(12);e[0]=0,e[1]=0,e[2]=1,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=1,e[9]=0,e[10]=0,e[11]=1,a.normal=new l["a"]({componentDatatype:r["a"].FLOAT,componentsPerAttribute:3,values:e})}if(t.st){const e=new Float32Array(8);e[0]=0,e[1]=0,e[2]=1,e[3]=0,e[4]=1,e[5]=1,e[6]=0,e[7]=1,a.st=new l["a"]({componentDatatype:r["a"].FLOAT,componentsPerAttribute:2,values:e})}if(t.tangent){const e=new Float32Array(12);e[0]=1,e[1]=0,e[2]=0,e[3]=1,e[4]=0,e[5]=0,e[6]=1,e[7]=0,e[8]=0,e[9]=1,e[10]=0,e[11]=0,a.tangent=new l["a"]({componentDatatype:r["a"].FLOAT,componentsPerAttribute:3,values:e})}if(t.bitangent){const e=new Float32Array(12);e[0]=0,e[1]=1,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=1,e[8]=0,e[9]=0,e[10]=1,e[11]=0,a.bitangent=new l["a"]({componentDatatype:r["a"].FLOAT,componentsPerAttribute:3,values:e})}i=new Uint16Array(6),i[0]=0,i[1]=1,i[2]=2,i[3]=0,i[4]=2,i[5]=3}return new c["a"]({attributes:a,indices:i,primitiveType:p["a"].TRIANGLES,boundingSphere:new n["a"](o["a"].ZERO,Math.sqrt(2))})},t["a"]=d},"24e4":function(e,t,a){"use strict";var n=a("9201"),o=a("ee1e"),r=a("670c"),i=a("be18"),s=a("bef8"),c=a("abab"),l=a("535a"),u=a("2f63"),p=a("c52f"),h=a("cef8"),d=a("d2c7"),g=a("81d7"),y=a("473c"),f=a("c1e2"),m=a("0123"),b=a("93da"),w=a("df07"),O=a("9251"),_=a("1b8d"),T=a("0260"),A=a("9410"),E=a("b48e");const P={computeHierarchyPackedLength:function(e,t){let a=0;const n=[e];while(n.length>0){const e=n.pop();if(!Object(u["a"])(e))continue;a+=2;const o=e.positions,r=e.holes;if(Object(u["a"])(o)&&o.length>0&&(a+=o.length*t.packedLength),Object(u["a"])(r)){const e=r.length;for(let t=0;t<e;++t)n.push(r[t])}}return a},packPolygonHierarchy:function(e,t,a,n){const o=[e];while(o.length>0){const e=o.pop();if(!Object(u["a"])(e))continue;const r=e.positions,i=e.holes;if(t[a++]=Object(u["a"])(r)?r.length:0,t[a++]=Object(u["a"])(i)?i.length:0,Object(u["a"])(r)){const e=r.length;for(let o=0;o<e;++o,a+=n.packedLength)n.pack(r[o],t,a)}if(Object(u["a"])(i)){const e=i.length;for(let t=0;t<e;++t)o.push(i[t])}}return a},unpackPolygonHierarchy:function(e,t,a){const n=e[t++],o=e[t++],r=new Array(n),i=o>0?new Array(o):void 0;for(let s=0;s<n;++s,t+=a.packedLength)r[s]=a.unpack(e,t);for(let s=0;s<o;++s)i[s]=P.unpackPolygonHierarchy(e,t,a),t=i[s].startingIndex,delete i[s].startingIndex;return{positions:r,holes:i,startingIndex:t}}},v=new r["a"];function x(e,t,a,n){return r["a"].subtract(t,e,v),r["a"].multiplyByScalar(v,a/n,v),r["a"].add(e,v,v),[v.x,v.y]}const L=new i["a"];function I(e,t,a,n){return i["a"].subtract(t,e,L),i["a"].multiplyByScalar(L,a/n,L),i["a"].add(e,L,L),[L.x,L.y,L.z]}P.subdivideLineCount=function(e,t,a){const n=i["a"].distance(e,t),o=n/a,r=Math.max(0,Math.ceil(b["a"].log2(o)));return Math.pow(2,r)};const S=new s["a"],N=new s["a"],j=new s["a"],D=new i["a"],R=new h["a"];P.subdivideRhumbLineCount=function(e,t,a,n){const o=e.cartesianToCartographic(t,S),r=e.cartesianToCartographic(a,N),i=new h["a"](o,r,e),s=i.surfaceDistance/n,c=Math.max(0,Math.ceil(b["a"].log2(s)));return Math.pow(2,c)},P.subdivideTexcoordLine=function(e,t,a,n,o,i){const s=P.subdivideLineCount(a,n,o),c=r["a"].distance(e,t),l=c/s,u=i;u.length=2*s;let p=0;for(let r=0;r<s;r++){const a=x(e,t,r*l,c);u[p++]=a[0],u[p++]=a[1]}return u},P.subdivideLine=function(e,t,a,n){const o=P.subdivideLineCount(e,t,a),r=i["a"].distance(e,t),s=r/o;Object(u["a"])(n)||(n=[]);const c=n;c.length=3*o;let l=0;for(let i=0;i<o;i++){const a=I(e,t,i*s,r);c[l++]=a[0],c[l++]=a[1],c[l++]=a[2]}return c},P.subdivideTexcoordRhumbLine=function(e,t,a,n,o,i,s){const c=a.cartesianToCartographic(n,S),l=a.cartesianToCartographic(o,N);R.setEndPoints(c,l);const u=R.surfaceDistance/i,p=Math.max(0,Math.ceil(b["a"].log2(u))),h=Math.pow(2,p),d=r["a"].distance(e,t),g=d/h,y=s;y.length=2*h;let f=0;for(let r=0;r<h;r++){const a=x(e,t,r*g,d);y[f++]=a[0],y[f++]=a[1]}return y},P.subdivideRhumbLine=function(e,t,a,n,o){const r=e.cartesianToCartographic(t,S),i=e.cartesianToCartographic(a,N),s=new h["a"](r,i,e),c=s.surfaceDistance/n,l=Math.max(0,Math.ceil(b["a"].log2(c))),p=Math.pow(2,l),d=s.surfaceDistance/p;Object(u["a"])(o)||(o=[]);const g=o;g.length=3*p;let y=0;for(let u=0;u<p;u++){const t=s.interpolateUsingSurfaceDistance(u*d,j),a=e.cartographicToCartesian(t,D);g[y++]=a.x,g[y++]=a.y,g[y++]=a.z}return g};const k=new i["a"],G=new i["a"],C=new i["a"],F=new i["a"];P.scaleToGeodeticHeightExtruded=function(e,t,a,n,o){n=Object(l["a"])(n,p["a"].WGS84);const r=k;let s=G;const c=C;let h=F;if(Object(u["a"])(e)&&Object(u["a"])(e.attributes)&&Object(u["a"])(e.attributes.position)){const l=e.attributes.position.values,u=l.length/2;for(let e=0;e<u;e+=3)i["a"].fromArray(l,e,c),n.geodeticSurfaceNormal(c,r),h=n.scaleToGeodeticSurface(c,h),s=i["a"].multiplyByScalar(r,a,s),s=i["a"].add(h,s,s),l[e+u]=s.x,l[e+1+u]=s.y,l[e+2+u]=s.z,o&&(h=i["a"].clone(c,h)),s=i["a"].multiplyByScalar(r,t,s),s=i["a"].add(h,s,s),l[e]=s.x,l[e+1]=s.y,l[e+2]=s.z}return e},P.polygonOutlinesFromHierarchy=function(e,t,a){const n=[],r=new A["a"];let s,c,l;r.enqueue(e);while(0!==r.length){const e=r.dequeue();let p=e.positions;if(t)for(l=p.length,s=0;s<l;s++)a.scaleToGeodeticSurface(p[s],p[s]);if(p=Object(o["a"])(p,i["a"].equalsEpsilon,!0),p.length<3)continue;const h=e.holes?e.holes.length:0;for(s=0;s<h;s++){const p=e.holes[s];let h=p.positions;if(t)for(l=h.length,c=0;c<l;++c)a.scaleToGeodeticSurface(h[c],h[c]);if(h=Object(o["a"])(h,i["a"].equalsEpsilon,!0),h.length<3)continue;n.push(h);let d=0;for(Object(u["a"])(p.holes)&&(d=p.holes.length),c=0;c<d;c++)r.enqueue(p.holes[c])}n.push(p)}return n},P.polygonsFromHierarchy=function(e,t,a,n,r){const s=[],c=[],l=new A["a"];l.enqueue(e);while(0!==l.length){const e=l.dequeue();let p=e.positions;const h=e.holes;let d,g;if(n)for(g=p.length,d=0;d<g;d++)r.scaleToGeodeticSurface(p[d],p[d]);if(t||(p=Object(o["a"])(p,i["a"].equalsEpsilon,!0)),p.length<3)continue;let y=a(p);if(!Object(u["a"])(y))continue;const f=[];let m=O["a"].computeWindingOrder2D(y);m===E["a"].CLOCKWISE&&(y.reverse(),p=p.slice().reverse());let b=p.slice();const w=Object(u["a"])(h)?h.length:0,_=[];let T;for(d=0;d<w;d++){const e=h[d];let s=e.positions;if(n)for(g=s.length,T=0;T<g;++T)r.scaleToGeodeticSurface(s[T],s[T]);if(t||(s=Object(o["a"])(s,i["a"].equalsEpsilon,!0)),s.length<3)continue;const c=a(s);if(!Object(u["a"])(c))continue;m=O["a"].computeWindingOrder2D(c),m===E["a"].CLOCKWISE&&(c.reverse(),s=s.slice().reverse()),_.push(s),f.push(b.length),b=b.concat(s),y=y.concat(c);let p=0;for(Object(u["a"])(e.holes)&&(p=e.holes.length),T=0;T<p;T++)l.enqueue(e.holes[T])}s.push({outerRing:p,holes:_}),c.push({positions:b,positions2D:y,holes:f})}return{hierarchy:s,polygons:c}};const H=new r["a"],B=new i["a"],z=new T["a"],M=new w["a"];P.computeBoundingRectangle=function(e,t,a,n,o){const r=T["a"].fromAxisAngle(e,n,z),s=w["a"].fromQuaternion(r,M);let c=Number.POSITIVE_INFINITY,l=Number.NEGATIVE_INFINITY,p=Number.POSITIVE_INFINITY,h=Number.NEGATIVE_INFINITY;const d=a.length;for(let g=0;g<d;++g){const e=i["a"].clone(a[g],B);w["a"].multiplyByVector(s,e,e);const n=t(e,H);Object(u["a"])(n)&&(c=Math.min(c,n.x),l=Math.max(l,n.x),p=Math.min(p,n.y),h=Math.max(h,n.y))}return o.x=c,o.y=p,o.width=l-c,o.height=h-p,o},P.createGeometryFromPositions=function(e,t,a,o,i,s,l){let p=O["a"].triangulate(t.positions2D,t.holes);p.length<3&&(p=[0,1,2]);const h=t.positions,y=Object(u["a"])(a),m=y?a.positions:void 0;if(i){const e=h.length,t=new Array(3*e);let a=0;for(let r=0;r<e;r++){const e=h[r];t[a++]=e.x,t[a++]=e.y,t[a++]=e.z}const n={attributes:{position:new g["a"]({componentDatatype:c["a"].DOUBLE,componentsPerAttribute:3,values:t})},indices:p,primitiveType:_["a"].TRIANGLES};y&&(n.attributes.st=new g["a"]({componentDatatype:c["a"].FLOAT,componentsPerAttribute:2,values:r["a"].packArray(m)}));const o=new d["a"](n);return s.normal?f["a"].computeNormal(o):o}return l===n["a"].GEODESIC?O["a"].computeSubdivision(e,h,p,m,o):l===n["a"].RHUMB?O["a"].computeRhumbLineSubdivision(e,h,p,m,o):void 0};const U=[],V=[],W=new i["a"],q=new i["a"];P.computeWallGeometry=function(e,t,a,o,r,s){let l,p,h,f,w,O,T,A,E,v=e.length,x=0,L=0;const I=Object(u["a"])(t),S=I?t.positions:void 0;if(r)for(p=3*v*2,l=new Array(2*p),I&&(E=2*v*2,A=new Array(2*E)),h=0;h<v;h++)f=e[h],w=e[(h+1)%v],l[x]=l[x+p]=f.x,++x,l[x]=l[x+p]=f.y,++x,l[x]=l[x+p]=f.z,++x,l[x]=l[x+p]=w.x,++x,l[x]=l[x+p]=w.y,++x,l[x]=l[x+p]=w.z,++x,I&&(O=S[h],T=S[(h+1)%v],A[L]=A[L+E]=O.x,++L,A[L]=A[L+E]=O.y,++L,A[L]=A[L+E]=T.x,++L,A[L]=A[L+E]=T.y,++L);else{const t=b["a"].chordLength(o,a.maximumRadius);let r=0;if(s===n["a"].GEODESIC)for(h=0;h<v;h++)r+=P.subdivideLineCount(e[h],e[(h+1)%v],t);else if(s===n["a"].RHUMB)for(h=0;h<v;h++)r+=P.subdivideRhumbLineCount(a,e[h],e[(h+1)%v],t);for(p=3*(r+v),l=new Array(2*p),I&&(E=2*(r+v),A=new Array(2*E)),h=0;h<v;h++){let o,r;f=e[h],w=e[(h+1)%v],I&&(O=S[h],T=S[(h+1)%v]),s===n["a"].GEODESIC?(o=P.subdivideLine(f,w,t,V),I&&(r=P.subdivideTexcoordLine(O,T,f,w,t,U))):s===n["a"].RHUMB&&(o=P.subdivideRhumbLine(a,f,w,t,V),I&&(r=P.subdivideTexcoordRhumbLine(O,T,a,f,w,t,U)));const i=o.length;for(let e=0;e<i;++e,++x)l[x]=o[e],l[x+p]=o[e];if(l[x]=w.x,l[x+p]=w.x,++x,l[x]=w.y,l[x+p]=w.y,++x,l[x]=w.z,l[x+p]=w.z,++x,I){const e=r.length;for(let t=0;t<e;++t,++L)A[L]=r[t],A[L+E]=r[t];A[L]=T.x,A[L+E]=T.x,++L,A[L]=T.y,A[L+E]=T.y,++L}}}v=l.length;const N=m["a"].createTypedArray(v/3,v-6*e.length);let j=0;for(v/=6,h=0;h<v;h++){const e=h,t=e+1,a=e+v,n=a+1;f=i["a"].fromArray(l,3*e,W),w=i["a"].fromArray(l,3*t,q),i["a"].equalsEpsilon(f,w,b["a"].EPSILON10,b["a"].EPSILON10)||(N[j++]=e,N[j++]=a,N[j++]=t,N[j++]=t,N[j++]=a,N[j++]=n)}const D={attributes:new y["a"]({position:new g["a"]({componentDatatype:c["a"].DOUBLE,componentsPerAttribute:3,values:l})}),indices:N,primitiveType:_["a"].TRIANGLES};I&&(D.attributes.st=new g["a"]({componentDatatype:c["a"].FLOAT,componentsPerAttribute:2,values:A}));const R=new d["a"](D);return R},t["a"]=P},"29bd":function(e,t,a){"use strict";var n=a("670c"),o=a("be18"),r=a("a561"),i=a("bef8"),s=a("d0c2"),c=a("a3bd"),l=a("93da"),u=a("df07"),p=a("52f0"),h=a("31af"),d=a("0260"),g=a("f806"),y=a("b639");const f=[new o["a"],new o["a"]],m=new o["a"],b=new o["a"],w=new o["a"],O=new o["a"],_=new o["a"],T=new o["a"],A=new o["a"],E=new o["a"],P=new o["a"],v=new o["a"],x=new o["a"],L={};let I=new i["a"];function S(e,t){const a=new Array(e.length);for(let n=0;n<e.length;n++){const o=e[n];I=t.cartesianToCartographic(o,I),a[n]=I.height,e[n]=t.scaleToGeodeticSurface(o,o)}return a}function N(e,t,a,n){const r=e[0],i=e[1],s=o["a"].angleBetween(r,i),c=Math.ceil(s/n),l=new Array(c);let u;if(t===a){for(u=0;u<c;u++)l[u]=t;return l.push(a),l}const p=a-t,h=p/c;for(u=1;u<c;u++){const e=t+u*h;l[u]=e}return l[0]=t,l.push(a),l}const j=new o["a"],D=new o["a"];function R(e,t,a,r){const i=new c["a"](a,r),s=i.projectPointOntoPlane(o["a"].add(a,e,j),j),l=i.projectPointOntoPlane(o["a"].add(a,t,D),D),u=n["a"].angleBetween(s,l);return l.x*s.y-l.y*s.x>=0?-u:u}const k=new o["a"](-1,0,0);let G=new p["a"];const C=new p["a"];let F=new u["a"];const H=u["a"].IDENTITY.clone(),B=new o["a"],z=new r["a"],M=new o["a"];function U(e,t,a,n,r,i,s,c){let l=B,h=z;G=g["a"].eastNorthUpToFixedFrame(e,r,G),l=p["a"].multiplyByPointAsVector(G,k,l),l=o["a"].normalize(l,l);const d=R(l,t,e,r);F=u["a"].fromRotationZ(d,F),M.z=i,G=p["a"].multiplyTransformation(G,p["a"].fromRotationTranslation(F,M,C),G);const y=H;y[0]=s;for(let g=0;g<c;g++)for(let e=0;e<a.length;e+=3)h=o["a"].fromArray(a,e,h),h=u["a"].multiplyByVector(y,h,h),h=p["a"].multiplyByPoint(G,h,h),n.push(h.x,h.y,h.z);return n}const V=new o["a"];function W(e,t,a,n,r,i,s){for(let c=0;c<e.length;c+=3){const l=o["a"].fromArray(e,c,V);n=U(l,t,a,n,r,i[c/3],s,1)}return n}function q(e,t){const a=e.length,n=new Array(6*a);let o=0;const r=t.x+t.width/2,i=t.y+t.height/2;let s=e[0];n[o++]=s.x-r,n[o++]=0,n[o++]=s.y-i;for(let c=1;c<a;c++){s=e[c];const t=s.x-r,a=s.y-i;n[o++]=t,n[o++]=0,n[o++]=a,n[o++]=t,n[o++]=0,n[o++]=a}return s=e[0],n[o++]=s.x-r,n[o++]=0,n[o++]=s.y-i,n}function Y(e,t){const a=e.length,n=new Array(3*a);let o=0;const r=t.x+t.width/2,i=t.y+t.height/2;for(let s=0;s<a;s++)n[o++]=e[s].x-r,n[o++]=0,n[o++]=e[s].y-i;return n}const $=new d["a"],K=new o["a"],Z=new u["a"];function J(e,t,a,n,r,i,c,p,h,g){const y=o["a"].angleBetween(o["a"].subtract(t,e,v),o["a"].subtract(a,e,x)),f=n===s["a"].BEVELED?0:Math.ceil(y/l["a"].toRadians(5));let m,b,w;if(m=r?u["a"].fromQuaternion(d["a"].fromAxisAngle(o["a"].negate(e,v),y/(f+1),$),Z):u["a"].fromQuaternion(d["a"].fromAxisAngle(e,y/(f+1),$),Z),t=o["a"].clone(t,K),f>0){const a=g?2:1;for(let n=0;n<f;n++)t=u["a"].multiplyByVector(m,t,t),b=o["a"].subtract(t,e,v),b=o["a"].normalize(b,b),r||(b=o["a"].negate(b,b)),w=i.scaleToGeodeticSurface(t,x),c=U(w,b,p,c,i,h,1,a)}else b=o["a"].subtract(t,e,v),b=o["a"].normalize(b,b),r||(b=o["a"].negate(b,b)),w=i.scaleToGeodeticSurface(t,x),c=U(w,b,p,c,i,h,1,1),a=o["a"].clone(a,K),b=o["a"].subtract(a,e,v),b=o["a"].normalize(b,b),r||(b=o["a"].negate(b,b)),w=i.scaleToGeodeticSurface(a,x),c=U(w,b,p,c,i,h,1,1);return c}L.removeDuplicatesFromShape=function(e){const t=e.length,a=[];for(let o=t-1,r=0;r<t;o=r++){const t=e[o],i=e[r];n["a"].equals(t,i)||a.push(i)}return a},L.angleIsGreaterThanPi=function(e,t,a,n){const r=new c["a"](a,n),i=r.projectPointOntoPlane(o["a"].add(a,e,j),j),s=r.projectPointOntoPlane(o["a"].add(a,t,D),D);return s.x*i.y-s.y*i.x>=0};const X=new o["a"],Q=new o["a"];L.computePositions=function(e,t,a,n,r){const i=n._ellipsoid,c=S(e,i),u=n._granularity,p=n._cornerType,d=r?q(t,a):Y(t,a),g=r?Y(t,a):void 0,x=a.height/2,I=a.width/2;let j=e.length,D=[],R=r?[]:void 0,k=m,G=b,C=w,F=O,H=_,B=T,z=A,M=E,V=P,$=e[0],K=e[1];F=i.geodeticSurfaceNormal($,F),k=o["a"].subtract(K,$,k),k=o["a"].normalize(k,k),M=o["a"].cross(F,k,M),M=o["a"].normalize(M,M);let Z,ee,te=c[0],ae=c[1];r&&(R=U($,M,g,R,i,te+x,1,1)),V=o["a"].clone($,V),$=K,G=o["a"].negate(k,G);for(let m=1;m<j-1;m++){const t=r?2:1;if(K=e[m+1],$.equals(K)){Object(y["a"])("Positions are too close and are considered equivalent with rounding error.");continue}k=o["a"].subtract(K,$,k),k=o["a"].normalize(k,k),C=o["a"].add(k,G,C),C=o["a"].normalize(C,C),F=i.geodeticSurfaceNormal($,F);const a=o["a"].multiplyByScalar(F,o["a"].dot(k,F),X);o["a"].subtract(k,a,a),o["a"].normalize(a,a);const n=o["a"].multiplyByScalar(F,o["a"].dot(G,F),Q);o["a"].subtract(G,n,n),o["a"].normalize(n,n);const g=!l["a"].equalsEpsilon(Math.abs(o["a"].dot(a,n)),1,l["a"].EPSILON7);if(g){C=o["a"].cross(C,F,C),C=o["a"].cross(F,C,C),C=o["a"].normalize(C,C);const e=1/Math.max(.25,o["a"].magnitude(o["a"].cross(C,G,v))),a=L.angleIsGreaterThanPi(k,G,$,i);a?(H=o["a"].add($,o["a"].multiplyByScalar(C,e*I,C),H),B=o["a"].add(H,o["a"].multiplyByScalar(M,I,B),B),f[0]=o["a"].clone(V,f[0]),f[1]=o["a"].clone(B,f[1]),Z=N(f,te+x,ae+x,u),ee=h["a"].generateArc({positions:f,granularity:u,ellipsoid:i}),D=W(ee,M,d,D,i,Z,1),M=o["a"].cross(F,k,M),M=o["a"].normalize(M,M),z=o["a"].add(H,o["a"].multiplyByScalar(M,I,z),z),p===s["a"].ROUNDED||p===s["a"].BEVELED?J(H,B,z,p,a,i,D,d,ae+x,r):(C=o["a"].negate(C,C),D=U($,C,d,D,i,ae+x,e,t)),V=o["a"].clone(z,V)):(H=o["a"].add($,o["a"].multiplyByScalar(C,e*I,C),H),B=o["a"].add(H,o["a"].multiplyByScalar(M,-I,B),B),f[0]=o["a"].clone(V,f[0]),f[1]=o["a"].clone(B,f[1]),Z=N(f,te+x,ae+x,u),ee=h["a"].generateArc({positions:f,granularity:u,ellipsoid:i}),D=W(ee,M,d,D,i,Z,1),M=o["a"].cross(F,k,M),M=o["a"].normalize(M,M),z=o["a"].add(H,o["a"].multiplyByScalar(M,-I,z),z),p===s["a"].ROUNDED||p===s["a"].BEVELED?J(H,B,z,p,a,i,D,d,ae+x,r):D=U($,C,d,D,i,ae+x,e,t),V=o["a"].clone(z,V)),G=o["a"].negate(k,G)}else D=U(V,M,d,D,i,te+x,1,1),V=$;te=ae,ae=c[m+1],$=K}f[0]=o["a"].clone(V,f[0]),f[1]=o["a"].clone($,f[1]),Z=N(f,te+x,ae+x,u),ee=h["a"].generateArc({positions:f,granularity:u,ellipsoid:i}),D=W(ee,M,d,D,i,Z,1),r&&(R=U($,M,g,R,i,ae+x,1,1)),j=D.length;const ne=r?j+R.length:j,oe=new Float64Array(ne);return oe.set(D),r&&oe.set(R,j),oe},t["a"]=L},"31af":function(e,t,a){"use strict";var n=a("be18"),o=a("bef8"),r=a("535a"),i=a("2f63"),s=a("c52f"),c=a("1e13"),l=a("cef8"),u=a("5410"),p=a("93da"),h=a("52f0"),d=a("188e");const g={numberOfPoints:function(e,t,a){const o=n["a"].distance(e,t);return Math.ceil(o/a)},numberOfPointsRhumbLine:function(e,t,a){const n=Math.pow(e.longitude-t.longitude,2)+Math.pow(e.latitude-t.latitude,2);return Math.max(1,Math.ceil(Math.sqrt(n/(a*a))))}},y=new o["a"];g.extractHeights=function(e,t){const a=e.length,n=new Array(a);for(let o=0;o<a;o++){const a=e[o];n[o]=t.cartesianToCartographic(a,y).height}return n};const f=new h["a"],m=new n["a"],b=new n["a"],w=new d["a"](n["a"].UNIT_X,0),O=new n["a"],_=new d["a"](n["a"].UNIT_X,0),T=new n["a"],A=new n["a"],E=[];function P(e,t,a){const n=E;let o;if(n.length=e,t===a){for(o=0;o<e;o++)n[o]=t;return n}const r=a-t,i=r/e;for(o=0;o<e;o++){const e=t+o*i;n[o]=e}return n}const v=new o["a"],x=new o["a"],L=new n["a"],I=new n["a"],S=new n["a"],N=new c["a"];let j=new l["a"];function D(e,t,a,o,r,i,s,c){const l=o.scaleToGeodeticSurface(e,I),u=o.scaleToGeodeticSurface(t,S),p=g.numberOfPoints(e,t,a),h=o.cartesianToCartographic(l,v),d=o.cartesianToCartographic(u,x),y=P(p,r,i);N.setEndPoints(h,d);const f=N.surfaceDistance/p;let m=c;h.height=r;let b=o.cartographicToCartesian(h,L);n["a"].pack(b,s,m),m+=3;for(let g=1;g<p;g++){const e=N.interpolateUsingSurfaceDistance(g*f,x);e.height=y[g],b=o.cartographicToCartesian(e,L),n["a"].pack(b,s,m),m+=3}return m}function R(e,t,a,o,r,i,s,c){const u=o.cartesianToCartographic(e,v),p=o.cartesianToCartographic(t,x),h=g.numberOfPointsRhumbLine(u,p,a);u.height=0,p.height=0;const d=P(h,r,i);j.ellipsoid.equals(o)||(j=new l["a"](void 0,void 0,o)),j.setEndPoints(u,p);const y=j.surfaceDistance/h;let f=c;u.height=r;let m=o.cartographicToCartesian(u,L);n["a"].pack(m,s,f),f+=3;for(let l=1;l<h;l++){const e=j.interpolateUsingSurfaceDistance(l*y,x);e.height=d[l],m=o.cartographicToCartesian(e,L),n["a"].pack(m,s,f),f+=3}return f}g.wrapLongitude=function(e,t){const a=[],o=[];if(Object(i["a"])(e)&&e.length>0){t=Object(r["a"])(t,h["a"].IDENTITY);const s=h["a"].inverseTransformation(t,f),c=h["a"].multiplyByPoint(s,n["a"].ZERO,m),l=n["a"].normalize(h["a"].multiplyByPointAsVector(s,n["a"].UNIT_Y,b),b),p=d["a"].fromPointNormal(c,l,w),g=n["a"].normalize(h["a"].multiplyByPointAsVector(s,n["a"].UNIT_X,O),O),y=d["a"].fromPointNormal(c,g,_);let E=1;a.push(n["a"].clone(e[0]));let P=a[0];const v=e.length;for(let t=1;t<v;++t){const r=e[t];if(d["a"].getPointDistance(y,P)<0||d["a"].getPointDistance(y,r)<0){const e=u["a"].lineSegmentPlane(P,r,p,T);if(Object(i["a"])(e)){const t=n["a"].multiplyByScalar(l,5e-9,A);d["a"].getPointDistance(p,P)<0&&n["a"].negate(t,t),a.push(n["a"].add(e,t,new n["a"])),o.push(E+1),n["a"].negate(t,t),a.push(n["a"].add(e,t,new n["a"])),E=1}}a.push(n["a"].clone(e[t])),E++,P=r}o.push(E)}return{positions:a,lengths:o}},g.generateArc=function(e){Object(i["a"])(e)||(e={});const t=e.positions,a=t.length,o=Object(r["a"])(e.ellipsoid,s["a"].WGS84);let c=Object(r["a"])(e.height,0);const l=Array.isArray(c);if(a<1)return[];if(1===a){const e=o.scaleToGeodeticSurface(t[0],I);if(c=l?c[0]:c,0!==c){const t=o.geodeticSurfaceNormal(e,L);n["a"].multiplyByScalar(t,c,t),n["a"].add(e,t,e)}return[e.x,e.y,e.z]}let u=e.minDistance;if(!Object(i["a"])(u)){const t=Object(r["a"])(e.granularity,p["a"].RADIANS_PER_DEGREE);u=p["a"].chordLength(t,o.maximumRadius)}let h,d=0;for(h=0;h<a-1;h++)d+=g.numberOfPoints(t[h],t[h+1],u);const y=3*(d+1),f=new Array(y);let m=0;for(h=0;h<a-1;h++){const e=t[h],a=t[h+1],n=l?c[h]:c,r=l?c[h+1]:c;m=D(e,a,u,o,n,r,f,m)}E.length=0;const b=t[a-1],w=o.cartesianToCartographic(b,v);w.height=l?c[a-1]:c;const O=o.cartographicToCartesian(w,L);return n["a"].pack(O,f,y-3),f};const k=new o["a"],G=new o["a"];g.generateRhumbArc=function(e){Object(i["a"])(e)||(e={});const t=e.positions,a=t.length,c=Object(r["a"])(e.ellipsoid,s["a"].WGS84);let l=Object(r["a"])(e.height,0);const u=Array.isArray(l);if(a<1)return[];if(1===a){const e=c.scaleToGeodeticSurface(t[0],I);if(l=u?l[0]:l,0!==l){const t=c.geodeticSurfaceNormal(e,L);n["a"].multiplyByScalar(t,l,t),n["a"].add(e,t,e)}return[e.x,e.y,e.z]}const h=Object(r["a"])(e.granularity,p["a"].RADIANS_PER_DEGREE);let d,y,f=0,m=c.cartesianToCartographic(t[0],k);for(d=0;d<a-1;d++)y=c.cartesianToCartographic(t[d+1],G),f+=g.numberOfPointsRhumbLine(m,y,h),m=o["a"].clone(y,k);const b=3*(f+1),w=new Array(b);let O=0;for(d=0;d<a-1;d++){const e=t[d],a=t[d+1],n=u?l[d]:l,o=u?l[d+1]:l;O=R(e,a,h,c,n,o,w,O)}E.length=0;const _=t[a-1],T=c.cartesianToCartographic(_,v);T.height=u?l[a-1]:l;const A=c.cartographicToCartesian(T,L);return n["a"].pack(A,w,b-3),w},g.generateCartesianArc=function(e){const t=g.generateArc(e),a=t.length/3,o=new Array(a);for(let r=0;r<a;r++)o[r]=n["a"].unpack(t,3*r);return o},g.generateCartesianRhumbArc=function(e){const t=g.generateRhumbArc(e),a=t.length/3,o=new Array(a);for(let r=0;r<a;r++)o[r]=n["a"].unpack(t,3*r);return o},t["a"]=g},4914:function(e,t,a){"use strict";var n=a("9201"),o=a("77af"),r=a("cef5"),i=a("670c"),s=a("be18"),c=a("bef8"),l=a("abab"),u=a("535a"),p=a("2f63"),h=a("c52f"),d=a("1e13"),g=a("a3bd"),y=a("d2c7"),f=a("81d7"),m=a("d940"),b=a("0276"),w=a("c1e2"),O=a("0123"),_=a("93da"),T=a("df07"),A=a("24e4"),E=a("9251"),P=a("0260"),v=a("eace"),x=a("0541"),L=a("b48e");const I=new c["a"],S=new c["a"];function N(e,t,a,n){const o=n.cartesianToCartographic(e,I),r=o.height,i=n.cartesianToCartographic(t,S);i.height=r,n.cartographicToCartesian(i,t);const s=n.cartesianToCartographic(a,S);s.height=r-100,n.cartographicToCartesian(s,a)}const j=new o["a"],D=new s["a"],R=new s["a"],k=new s["a"],G=new s["a"],C=new s["a"],F=new s["a"];let H=new s["a"],B=new s["a"],z=new s["a"];const M=new i["a"],U=new i["a"],V=new s["a"],W=new P["a"],q=new T["a"],Y=new T["a"];function $(e){const t=e.vertexFormat,a=e.geometry,n=e.shadowVolume,o=a.attributes.position.values,r=Object(p["a"])(a.attributes.st)?a.attributes.st.values:void 0;let c=o.length;const u=e.wall,h=e.top||u,d=e.bottom||u;if(t.st||t.normal||t.tangent||t.bitangent||n){const g=e.boundingRectangle,y=e.tangentPlane,m=e.ellipsoid,b=e.stRotation,w=e.perPositionHeight,O=M;O.x=g.x,O.y=g.y;const A=t.st?new Float32Array(c/3*2):void 0;let E;t.normal&&(E=w&&h&&!u?a.attributes.normal.values:new Float32Array(c));const v=t.tangent?new Float32Array(c):void 0,x=t.bitangent?new Float32Array(c):void 0,L=n?new Float32Array(c):void 0;let I=0,S=0,j=R,$=k,K=G,Z=!0,J=q,X=Y;if(0!==b){let e=P["a"].fromAxisAngle(y._plane.normal,b,W);J=T["a"].fromQuaternion(e,J),e=P["a"].fromAxisAngle(y._plane.normal,-b,W),X=T["a"].fromQuaternion(e,X)}else J=T["a"].clone(T["a"].IDENTITY,J),X=T["a"].clone(T["a"].IDENTITY,X);let Q=0,ee=0;h&&d&&(Q=c/2,ee=c/3,c/=2);for(let a=0;a<c;a+=3){const l=s["a"].fromArray(o,a,V);if(t.st&&!Object(p["a"])(r)){let e=T["a"].multiplyByVector(J,l,D);e=m.scaleToGeodeticSurface(e,e);const t=y.projectPointOntoPlane(e,U);i["a"].subtract(t,O,t);const a=_["a"].clamp(t.x/g.width,0,1),n=_["a"].clamp(t.y/g.height,0,1);d&&(A[I+ee]=a,A[I+1+ee]=n),h&&(A[I]=a,A[I+1]=n),I+=2}if(t.normal||t.tangent||t.bitangent||n){const r=S+1,i=S+2;if(u){if(a+3<c){const e=s["a"].fromArray(o,a+3,C);if(Z){const t=s["a"].fromArray(o,a+c,F);w&&N(l,e,t,m),s["a"].subtract(e,l,e),s["a"].subtract(t,l,t),j=s["a"].normalize(s["a"].cross(t,e,j),j),Z=!1}s["a"].equalsEpsilon(e,l,_["a"].EPSILON10)&&(Z=!0)}(t.tangent||t.bitangent)&&(K=m.geodeticSurfaceNormal(l,K),t.tangent&&($=s["a"].normalize(s["a"].cross(K,j,$),$)))}else j=m.geodeticSurfaceNormal(l,j),(t.tangent||t.bitangent)&&(w&&(H=s["a"].fromArray(E,S,H),B=s["a"].cross(s["a"].UNIT_Z,H,B),B=s["a"].normalize(T["a"].multiplyByVector(X,B,B),B),t.bitangent&&(z=s["a"].normalize(s["a"].cross(H,B,z),z))),$=s["a"].cross(s["a"].UNIT_Z,j,$),$=s["a"].normalize(T["a"].multiplyByVector(X,$,$),$),t.bitangent&&(K=s["a"].normalize(s["a"].cross(j,$,K),K)));t.normal&&(e.wall?(E[S+Q]=j.x,E[r+Q]=j.y,E[i+Q]=j.z):d&&(E[S+Q]=-j.x,E[r+Q]=-j.y,E[i+Q]=-j.z),(h&&!w||u)&&(E[S]=j.x,E[r]=j.y,E[i]=j.z)),n&&(u&&(j=m.geodeticSurfaceNormal(l,j)),L[S+Q]=-j.x,L[r+Q]=-j.y,L[i+Q]=-j.z),t.tangent&&(e.wall?(v[S+Q]=$.x,v[r+Q]=$.y,v[i+Q]=$.z):d&&(v[S+Q]=-$.x,v[r+Q]=-$.y,v[i+Q]=-$.z),h&&(w?(v[S]=B.x,v[r]=B.y,v[i]=B.z):(v[S]=$.x,v[r]=$.y,v[i]=$.z))),t.bitangent&&(d&&(x[S+Q]=K.x,x[r+Q]=K.y,x[i+Q]=K.z),h&&(w?(x[S]=z.x,x[r]=z.y,x[i]=z.z):(x[S]=K.x,x[r]=K.y,x[i]=K.z))),S+=3}}t.st&&!Object(p["a"])(r)&&(a.attributes.st=new f["a"]({componentDatatype:l["a"].FLOAT,componentsPerAttribute:2,values:A})),t.normal&&(a.attributes.normal=new f["a"]({componentDatatype:l["a"].FLOAT,componentsPerAttribute:3,values:E})),t.tangent&&(a.attributes.tangent=new f["a"]({componentDatatype:l["a"].FLOAT,componentsPerAttribute:3,values:v})),t.bitangent&&(a.attributes.bitangent=new f["a"]({componentDatatype:l["a"].FLOAT,componentsPerAttribute:3,values:x})),n&&(a.attributes.extrudeDirection=new f["a"]({componentDatatype:l["a"].FLOAT,componentsPerAttribute:3,values:L}))}if(e.extrude&&Object(p["a"])(e.offsetAttribute)){const t=o.length/3;let n=new Uint8Array(t);if(e.offsetAttribute===b["a"].TOP)h&&d||u?n=n.fill(1,0,t/2):h&&(n=n.fill(1));else{const t=e.offsetAttribute===b["a"].NONE?0:1;n=n.fill(t)}a.attributes.applyOffset=new f["a"]({componentDatatype:l["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}return a}const K=new c["a"],Z=new c["a"],J={westOverIDL:0,eastOverIDL:0};let X=new d["a"];function Q(e,t,a,o,r){if(r=Object(u["a"])(r,new v["a"]),!Object(p["a"])(e)||e.length<3)return r.west=0,r.north=0,r.south=0,r.east=0,r;if(a===n["a"].RHUMB)return v["a"].fromCartesianArray(e,t,r);X.ellipsoid.equals(t)||(X=new d["a"](void 0,void 0,t)),r.west=Number.POSITIVE_INFINITY,r.east=Number.NEGATIVE_INFINITY,r.south=Number.POSITIVE_INFINITY,r.north=Number.NEGATIVE_INFINITY,J.westOverIDL=Number.POSITIVE_INFINITY,J.eastOverIDL=Number.NEGATIVE_INFINITY;const i=1/_["a"].chordLength(o,t.maximumRadius),s=e.length;let c,l=t.cartesianToCartographic(e[0],Z),h=K;for(let n=1;n<s;n++)c=h,h=l,l=t.cartesianToCartographic(e[n],c),X.setEndPoints(h,l),te(X,i,r,J);return c=h,h=l,l=t.cartesianToCartographic(e[0],c),X.setEndPoints(h,l),te(X,i,r,J),r.east-r.west>J.eastOverIDL-J.westOverIDL&&(r.west=J.westOverIDL,r.east=J.eastOverIDL,r.east>_["a"].PI&&(r.east=r.east-_["a"].TWO_PI),r.west>_["a"].PI&&(r.west=r.west-_["a"].TWO_PI)),r}const ee=new c["a"];function te(e,t,a,n){const o=e.surfaceDistance,r=Math.ceil(o*t),i=r>0?o/(r-1):Number.POSITIVE_INFINITY;let s=0;for(let c=0;c<r;c++){const t=e.interpolateUsingSurfaceDistance(s,ee);s+=i;const o=t.longitude,r=t.latitude;a.west=Math.min(a.west,o),a.east=Math.max(a.east,o),a.south=Math.min(a.south,r),a.north=Math.max(a.north,r);const c=o>=0?o:o+_["a"].TWO_PI;n.westOverIDL=Math.min(n.westOverIDL,c),n.eastOverIDL=Math.max(n.eastOverIDL,c)}}const ae=[];function ne(e,t,a,n,o,r,i,s,c,l){const u={walls:[]};let h;if(i||s){const o=A["a"].createGeometryFromPositions(e,t,a,n,r,c,l),d=o.attributes.position.values,g=o.indices;let y,f;if(i&&s){const e=d.concat(d);y=e.length/3,f=O["a"].createTypedArray(y,2*g.length),f.set(g);const t=g.length,n=y/2;for(h=0;h<t;h+=3){const e=f[h]+n,a=f[h+1]+n,o=f[h+2]+n;f[h+t]=o,f[h+1+t]=a,f[h+2+t]=e}if(o.attributes.position.values=e,r&&c.normal){const t=o.attributes.normal.values;o.attributes.normal.values=new Float32Array(e.length),o.attributes.normal.values.set(t)}if(c.st&&Object(p["a"])(a)){const e=o.attributes.st.values;o.attributes.st.values=new Float32Array(2*y),o.attributes.st.values=e.concat(e)}o.indices=f}else if(s){for(y=d.length/3,f=O["a"].createTypedArray(y,g.length),h=0;h<g.length;h+=3)f[h]=g[h+2],f[h+1]=g[h+1],f[h+2]=g[h];o.indices=f}u.topAndBottom=new m["a"]({geometry:o})}let d=o.outerRing,y=g["a"].fromPoints(d,e),f=y.projectPointsOntoPlane(d,ae),b=E["a"].computeWindingOrder2D(f);b===L["a"].CLOCKWISE&&(d=d.slice().reverse());let w=A["a"].computeWallGeometry(d,a,e,n,r,l);u.walls.push(new m["a"]({geometry:w}));const _=o.holes;for(h=0;h<_.length;h++){let t=_[h];y=g["a"].fromPoints(t,e),f=y.projectPointsOntoPlane(t,ae),b=E["a"].computeWindingOrder2D(f),b===L["a"].COUNTER_CLOCKWISE&&(t=t.slice().reverse()),w=A["a"].computeWallGeometry(t,a,e,n,r,l),u.walls.push(new m["a"]({geometry:w}))}return u}function oe(e){const t=e.polygonHierarchy,a=Object(u["a"])(e.vertexFormat,x["a"].DEFAULT),o=Object(u["a"])(e.ellipsoid,h["a"].WGS84),r=Object(u["a"])(e.granularity,_["a"].RADIANS_PER_DEGREE),c=Object(u["a"])(e.stRotation,0),l=e.textureCoordinates,d=Object(u["a"])(e.perPositionHeight,!1),g=d&&Object(p["a"])(e.extrudedHeight);let y=Object(u["a"])(e.height,0),f=Object(u["a"])(e.extrudedHeight,y);if(!g){const e=Math.max(y,f);f=Math.min(y,f),y=e}this._vertexFormat=x["a"].clone(a),this._ellipsoid=h["a"].clone(o),this._granularity=r,this._stRotation=c,this._height=y,this._extrudedHeight=f,this._closeTop=Object(u["a"])(e.closeTop,!0),this._closeBottom=Object(u["a"])(e.closeBottom,!0),this._polygonHierarchy=t,this._perPositionHeight=d,this._perPositionHeightExtrude=g,this._shadowVolume=Object(u["a"])(e.shadowVolume,!1),this._workerName="createPolygonGeometry",this._offsetAttribute=e.offsetAttribute,this._arcType=Object(u["a"])(e.arcType,n["a"].GEODESIC),this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0,this._textureCoordinates=l,this.packedLength=A["a"].computeHierarchyPackedLength(t,s["a"])+h["a"].packedLength+x["a"].packedLength+(l?A["a"].computeHierarchyPackedLength(l,i["a"]):1)+12}oe.fromPositions=function(e){e=Object(u["a"])(e,u["a"].EMPTY_OBJECT);const t={polygonHierarchy:{positions:e.positions},height:e.height,extrudedHeight:e.extrudedHeight,vertexFormat:e.vertexFormat,stRotation:e.stRotation,ellipsoid:e.ellipsoid,granularity:e.granularity,perPositionHeight:e.perPositionHeight,closeTop:e.closeTop,closeBottom:e.closeBottom,offsetAttribute:e.offsetAttribute,arcType:e.arcType,textureCoordinates:e.textureCoordinates};return new oe(t)},oe.pack=function(e,t,a){return a=Object(u["a"])(a,0),a=A["a"].packPolygonHierarchy(e._polygonHierarchy,t,a,s["a"]),h["a"].pack(e._ellipsoid,t,a),a+=h["a"].packedLength,x["a"].pack(e._vertexFormat,t,a),a+=x["a"].packedLength,t[a++]=e._height,t[a++]=e._extrudedHeight,t[a++]=e._granularity,t[a++]=e._stRotation,t[a++]=e._perPositionHeightExtrude?1:0,t[a++]=e._perPositionHeight?1:0,t[a++]=e._closeTop?1:0,t[a++]=e._closeBottom?1:0,t[a++]=e._shadowVolume?1:0,t[a++]=Object(u["a"])(e._offsetAttribute,-1),t[a++]=e._arcType,Object(p["a"])(e._textureCoordinates)?a=A["a"].packPolygonHierarchy(e._textureCoordinates,t,a,i["a"]):t[a++]=-1,t[a++]=e.packedLength,t};const re=h["a"].clone(h["a"].UNIT_SPHERE),ie=new x["a"],se={polygonHierarchy:{}};function ce(e){const t=-e._stRotation;if(0===t)return[0,0,0,1,1,0];const a=e._ellipsoid,n=e._polygonHierarchy.positions,o=e.rectangle;return y["a"]._textureCoordinateRotationPoints(n,t,a,o)}oe.unpack=function(e,t,a){t=Object(u["a"])(t,0);const n=A["a"].unpackPolygonHierarchy(e,t,s["a"]);t=n.startingIndex,delete n.startingIndex;const o=h["a"].unpack(e,t,re);t+=h["a"].packedLength;const r=x["a"].unpack(e,t,ie);t+=x["a"].packedLength;const c=e[t++],l=e[t++],d=e[t++],g=e[t++],y=1===e[t++],f=1===e[t++],m=1===e[t++],b=1===e[t++],w=1===e[t++],O=e[t++],_=e[t++],T=-1===e[t]?void 0:A["a"].unpackPolygonHierarchy(e,t,i["a"]);Object(p["a"])(T)?(t=T.startingIndex,delete T.startingIndex):t++;const E=e[t++];return Object(p["a"])(a)||(a=new oe(se)),a._polygonHierarchy=n,a._ellipsoid=h["a"].clone(o,a._ellipsoid),a._vertexFormat=x["a"].clone(r,a._vertexFormat),a._height=c,a._extrudedHeight=l,a._granularity=d,a._stRotation=g,a._perPositionHeightExtrude=y,a._perPositionHeight=f,a._closeTop=m,a._closeBottom=b,a._shadowVolume=w,a._offsetAttribute=-1===O?void 0:O,a._arcType=_,a._textureCoordinates=T,a.packedLength=E,a},oe.computeRectangle=function(e,t){const a=Object(u["a"])(e.granularity,_["a"].RADIANS_PER_DEGREE),o=Object(u["a"])(e.arcType,n["a"].GEODESIC),r=e.polygonHierarchy,i=Object(u["a"])(e.ellipsoid,h["a"].WGS84);return Q(r.positions,i,o,a,t)},oe.createGeometry=function(e){const t=e._vertexFormat,a=e._ellipsoid,n=e._granularity,o=e._stRotation,i=e._polygonHierarchy,s=e._perPositionHeight,c=e._closeTop,u=e._closeBottom,h=e._arcType,d=e._textureCoordinates,T=Object(p["a"])(d);let P=i.positions;if(P.length<3)return;const v=g["a"].fromPoints(P,a),x=A["a"].polygonsFromHierarchy(i,T,v.projectPointsOntoPlane.bind(v),!s,a),L=x.hierarchy,I=x.polygons,S=function(e){return e},N=T?A["a"].polygonsFromHierarchy(d,!0,S,!1).polygons:void 0;if(0===L.length)return;P=L[0].outerRing;const D=A["a"].computeBoundingRectangle(v.plane.normal,v.projectPointOntoPlane.bind(v),P,o,j),R=[],k=e._height,G=e._extrudedHeight,C=e._perPositionHeightExtrude||!_["a"].equalsEpsilon(k,G,0,_["a"].EPSILON2),F={perPositionHeight:s,vertexFormat:t,geometry:void 0,tangentPlane:v,boundingRectangle:D,ellipsoid:a,stRotation:o,textureCoordinates:void 0,bottom:!1,top:!0,wall:!1,extrude:!1,arcType:h};let H;if(C)for(F.extrude=!0,F.top=c,F.bottom=u,F.shadowVolume=e._shadowVolume,F.offsetAttribute=e._offsetAttribute,H=0;H<I.length;H++){const e=ne(a,I[H],T?N[H]:void 0,n,L[H],s,c,u,t,h);let o;c&&u?(o=e.topAndBottom,F.geometry=A["a"].scaleToGeodeticHeightExtruded(o.geometry,k,G,a,s)):c?(o=e.topAndBottom,o.geometry.attributes.position.values=E["a"].scaleToGeodeticHeight(o.geometry.attributes.position.values,k,a,!s),F.geometry=o.geometry):u&&(o=e.topAndBottom,o.geometry.attributes.position.values=E["a"].scaleToGeodeticHeight(o.geometry.attributes.position.values,G,a,!0),F.geometry=o.geometry),(c||u)&&(F.wall=!1,o.geometry=$(F),R.push(o));const r=e.walls;F.wall=!0;for(let t=0;t<r.length;t++){const e=r[t];F.geometry=A["a"].scaleToGeodeticHeightExtruded(e.geometry,k,G,a,s),e.geometry=$(F),R.push(e)}}else for(H=0;H<I.length;H++){const o=new m["a"]({geometry:A["a"].createGeometryFromPositions(a,I[H],T?N[H]:void 0,n,s,t,h)});if(o.geometry.attributes.position.values=E["a"].scaleToGeodeticHeight(o.geometry.attributes.position.values,k,a,!s),F.geometry=o.geometry,o.geometry=$(F),Object(p["a"])(e._offsetAttribute)){const t=o.geometry.attributes.position.values.length,a=e._offsetAttribute===b["a"].NONE?0:1,n=new Uint8Array(t/3).fill(a);o.geometry.attributes.applyOffset=new f["a"]({componentDatatype:l["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}R.push(o)}const B=w["a"].combineInstances(R)[0];B.attributes.position.values=new Float64Array(B.attributes.position.values),B.indices=O["a"].createTypedArray(B.attributes.position.values.length/3,B.indices);const z=B.attributes,M=r["a"].fromVertices(z.position.values);return t.position||delete z.position,new y["a"]({attributes:z,indices:B.indices,primitiveType:B.primitiveType,boundingSphere:M,offsetAttribute:e._offsetAttribute})},oe.createShadowVolume=function(e,t,a){const n=e._granularity,o=e._ellipsoid,r=t(n,o),i=a(n,o);return new oe({polygonHierarchy:e._polygonHierarchy,ellipsoid:o,stRotation:e._stRotation,granularity:n,perPositionHeight:!1,extrudedHeight:r,height:i,vertexFormat:x["a"].POSITION_ONLY,shadowVolume:!0,arcType:e._arcType})},Object.defineProperties(oe.prototype,{rectangle:{get:function(){if(!Object(p["a"])(this._rectangle)){const e=this._polygonHierarchy.positions;this._rectangle=Q(e,this._ellipsoid,this._arcType,this._granularity)}return this._rectangle}},textureCoordinateRotationPoints:{get:function(){return Object(p["a"])(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=ce(this)),this._textureCoordinateRotationPoints}}}),t["a"]=oe},"7bf4":function(e,t,a){"use strict";var n=a("9201"),o=a("cef5"),r=a("be18"),i=a("abab"),s=a("535a"),c=a("2f63"),l=a("c52f"),u=a("a3bd"),p=a("d2c7"),h=a("81d7"),d=a("473c"),g=a("d940"),y=a("0276"),f=a("c1e2"),m=a("0123"),b=a("93da"),w=a("24e4"),O=a("9251"),_=a("1b8d"),T=a("b48e");const A=[],E=[];function P(e,t,a,o,r){const s=u["a"].fromPoints(t,e),c=s.projectPointsOntoPlane(t,A),l=O["a"].computeWindingOrder2D(c);let y,f;l===T["a"].CLOCKWISE&&(c.reverse(),t=t.slice().reverse());let b=t.length,P=0;if(o)for(y=new Float64Array(2*b*3),f=0;f<b;f++){const e=t[f],a=t[(f+1)%b];y[P++]=e.x,y[P++]=e.y,y[P++]=e.z,y[P++]=a.x,y[P++]=a.y,y[P++]=a.z}else{let o=0;if(r===n["a"].GEODESIC)for(f=0;f<b;f++)o+=w["a"].subdivideLineCount(t[f],t[(f+1)%b],a);else if(r===n["a"].RHUMB)for(f=0;f<b;f++)o+=w["a"].subdivideRhumbLineCount(e,t[f],t[(f+1)%b],a);for(y=new Float64Array(3*o),f=0;f<b;f++){let o;r===n["a"].GEODESIC?o=w["a"].subdivideLine(t[f],t[(f+1)%b],a,E):r===n["a"].RHUMB&&(o=w["a"].subdivideRhumbLine(e,t[f],t[(f+1)%b],a,E));const i=o.length;for(let e=0;e<i;++e)y[P++]=o[e]}}b=y.length/3;const v=2*b,x=m["a"].createTypedArray(b,v);for(P=0,f=0;f<b-1;f++)x[P++]=f,x[P++]=f+1;return x[P++]=b-1,x[P++]=0,new g["a"]({geometry:new p["a"]({attributes:new d["a"]({position:new h["a"]({componentDatatype:i["a"].DOUBLE,componentsPerAttribute:3,values:y})}),indices:x,primitiveType:_["a"].LINES})})}function v(e,t,a,o,r){const s=u["a"].fromPoints(t,e),c=s.projectPointsOntoPlane(t,A),l=O["a"].computeWindingOrder2D(c);let y,f;l===T["a"].CLOCKWISE&&(c.reverse(),t=t.slice().reverse());let b=t.length;const P=new Array(b);let v=0;if(o)for(y=new Float64Array(2*b*3*2),f=0;f<b;++f){P[f]=v/3;const e=t[f],a=t[(f+1)%b];y[v++]=e.x,y[v++]=e.y,y[v++]=e.z,y[v++]=a.x,y[v++]=a.y,y[v++]=a.z}else{let o=0;if(r===n["a"].GEODESIC)for(f=0;f<b;f++)o+=w["a"].subdivideLineCount(t[f],t[(f+1)%b],a);else if(r===n["a"].RHUMB)for(f=0;f<b;f++)o+=w["a"].subdivideRhumbLineCount(e,t[f],t[(f+1)%b],a);for(y=new Float64Array(3*o*2),f=0;f<b;++f){let o;P[f]=v/3,r===n["a"].GEODESIC?o=w["a"].subdivideLine(t[f],t[(f+1)%b],a,E):r===n["a"].RHUMB&&(o=w["a"].subdivideRhumbLine(e,t[f],t[(f+1)%b],a,E));const i=o.length;for(let e=0;e<i;++e)y[v++]=o[e]}}b=y.length/6;const x=P.length,L=2*(2*b+x),I=m["a"].createTypedArray(b+x,L);for(v=0,f=0;f<b;++f)I[v++]=f,I[v++]=(f+1)%b,I[v++]=f+b,I[v++]=(f+1)%b+b;for(f=0;f<x;f++){const e=P[f];I[v++]=e,I[v++]=e+b}return new g["a"]({geometry:new p["a"]({attributes:new d["a"]({position:new h["a"]({componentDatatype:i["a"].DOUBLE,componentsPerAttribute:3,values:y})}),indices:I,primitiveType:_["a"].LINES})})}function x(e){const t=e.polygonHierarchy,a=Object(s["a"])(e.ellipsoid,l["a"].WGS84),o=Object(s["a"])(e.granularity,b["a"].RADIANS_PER_DEGREE),i=Object(s["a"])(e.perPositionHeight,!1),u=i&&Object(c["a"])(e.extrudedHeight),p=Object(s["a"])(e.arcType,n["a"].GEODESIC);let h=Object(s["a"])(e.height,0),d=Object(s["a"])(e.extrudedHeight,h);if(!u){const e=Math.max(h,d);d=Math.min(h,d),h=e}this._ellipsoid=l["a"].clone(a),this._granularity=o,this._height=h,this._extrudedHeight=d,this._arcType=p,this._polygonHierarchy=t,this._perPositionHeight=i,this._perPositionHeightExtrude=u,this._offsetAttribute=e.offsetAttribute,this._workerName="createPolygonOutlineGeometry",this.packedLength=w["a"].computeHierarchyPackedLength(t,r["a"])+l["a"].packedLength+8}x.pack=function(e,t,a){return a=Object(s["a"])(a,0),a=w["a"].packPolygonHierarchy(e._polygonHierarchy,t,a,r["a"]),l["a"].pack(e._ellipsoid,t,a),a+=l["a"].packedLength,t[a++]=e._height,t[a++]=e._extrudedHeight,t[a++]=e._granularity,t[a++]=e._perPositionHeightExtrude?1:0,t[a++]=e._perPositionHeight?1:0,t[a++]=e._arcType,t[a++]=Object(s["a"])(e._offsetAttribute,-1),t[a]=e.packedLength,t};const L=l["a"].clone(l["a"].UNIT_SPHERE),I={polygonHierarchy:{}};x.unpack=function(e,t,a){t=Object(s["a"])(t,0);const n=w["a"].unpackPolygonHierarchy(e,t,r["a"]);t=n.startingIndex,delete n.startingIndex;const o=l["a"].unpack(e,t,L);t+=l["a"].packedLength;const i=e[t++],u=e[t++],p=e[t++],h=1===e[t++],d=1===e[t++],g=e[t++],y=e[t++],f=e[t];return Object(c["a"])(a)||(a=new x(I)),a._polygonHierarchy=n,a._ellipsoid=l["a"].clone(o,a._ellipsoid),a._height=i,a._extrudedHeight=u,a._granularity=p,a._perPositionHeight=d,a._perPositionHeightExtrude=h,a._arcType=g,a._offsetAttribute=-1===y?void 0:y,a.packedLength=f,a},x.fromPositions=function(e){e=Object(s["a"])(e,s["a"].EMPTY_OBJECT);const t={polygonHierarchy:{positions:e.positions},height:e.height,extrudedHeight:e.extrudedHeight,ellipsoid:e.ellipsoid,granularity:e.granularity,perPositionHeight:e.perPositionHeight,arcType:e.arcType,offsetAttribute:e.offsetAttribute};return new x(t)},x.createGeometry=function(e){const t=e._ellipsoid,a=e._granularity,n=e._polygonHierarchy,r=e._perPositionHeight,s=e._arcType,l=w["a"].polygonOutlinesFromHierarchy(n,!r,t);if(0===l.length)return;let u;const d=[],g=b["a"].chordLength(a,t.maximumRadius),m=e._height,_=e._extrudedHeight,T=e._perPositionHeightExtrude||!b["a"].equalsEpsilon(m,_,0,b["a"].EPSILON2);let A,E;if(T)for(E=0;E<l.length;E++){if(u=v(t,l[E],g,r,s),u.geometry=w["a"].scaleToGeodeticHeightExtruded(u.geometry,m,_,t,r),Object(c["a"])(e._offsetAttribute)){const t=u.geometry.attributes.position.values.length/3;let a=new Uint8Array(t);e._offsetAttribute===y["a"].TOP?a=a.fill(1,0,t/2):(A=e._offsetAttribute===y["a"].NONE?0:1,a=a.fill(A)),u.geometry.attributes.applyOffset=new h["a"]({componentDatatype:i["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:a})}d.push(u)}else for(E=0;E<l.length;E++){if(u=P(t,l[E],g,r,s),u.geometry.attributes.position.values=O["a"].scaleToGeodeticHeight(u.geometry.attributes.position.values,m,t,!r),Object(c["a"])(e._offsetAttribute)){const t=u.geometry.attributes.position.values.length;A=e._offsetAttribute===y["a"].NONE?0:1;const a=new Uint8Array(t/3).fill(A);u.geometry.attributes.applyOffset=new h["a"]({componentDatatype:i["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:a})}d.push(u)}const x=f["a"].combineInstances(d)[0],L=o["a"].fromVertices(x.attributes.position.values);return new p["a"]({attributes:x.attributes,indices:x.indices,primitiveType:x.primitiveType,boundingSphere:L,offsetAttribute:e._offsetAttribute})},t["a"]=x},9251:function(e,t,a){"use strict";var n=a("5664"),o=a.n(n),r=a("670c"),i=a("be18"),s=a("bef8"),c=a("abab"),l=a("535a"),u=a("2f63"),p=a("c52f"),h=a("cef8"),d=a("d2c7"),g=a("81d7"),y=a("93da"),f=a("1b8d"),m=a("b48e");const b=new i["a"],w=new i["a"],O={computeArea2D:function(e){const t=e.length;let a=0;for(let n=t-1,o=0;o<t;n=o++){const t=e[n],r=e[o];a+=t.x*r.y-r.x*t.y}return.5*a},computeWindingOrder2D:function(e){const t=O.computeArea2D(e);return t>0?m["a"].COUNTER_CLOCKWISE:m["a"].CLOCKWISE},triangulate:function(e,t){const a=r["a"].packArray(e);return o()(a,t,2)}},_=new i["a"],T=new i["a"],A=new i["a"],E=new i["a"],P=new i["a"],v=new i["a"],x=new i["a"],L=new r["a"],I=new r["a"],S=new r["a"],N=new r["a"];O.computeSubdivision=function(e,t,a,n,o){o=Object(l["a"])(o,y["a"].RADIANS_PER_DEGREE);const s=Object(u["a"])(n),p=a.slice(0);let h;const m=t.length,b=new Array(3*m),w=new Array(2*m);let O=0,j=0;for(h=0;h<m;h++){const e=t[h];if(b[O++]=e.x,b[O++]=e.y,b[O++]=e.z,s){const e=n[h];w[j++]=e.x,w[j++]=e.y}}const D=[],R={},k=e.maximumRadius,G=y["a"].chordLength(o,k),C=G*G;while(p.length>0){const e=p.pop(),t=p.pop(),a=p.pop(),n=i["a"].fromArray(b,3*a,_),o=i["a"].fromArray(b,3*t,T),c=i["a"].fromArray(b,3*e,A);let l,d,g;s&&(l=r["a"].fromArray(w,2*a,L),d=r["a"].fromArray(w,2*t,I),g=r["a"].fromArray(w,2*e,S));const y=i["a"].multiplyByScalar(i["a"].normalize(n,E),k,E),f=i["a"].multiplyByScalar(i["a"].normalize(o,P),k,P),m=i["a"].multiplyByScalar(i["a"].normalize(c,v),k,v),O=i["a"].magnitudeSquared(i["a"].subtract(y,f,x)),j=i["a"].magnitudeSquared(i["a"].subtract(f,m,x)),G=i["a"].magnitudeSquared(i["a"].subtract(m,y,x)),F=Math.max(O,j,G);let H,B,z;F>C?O===F?(H=`${Math.min(a,t)} ${Math.max(a,t)}`,h=R[H],Object(u["a"])(h)||(B=i["a"].add(n,o,x),i["a"].multiplyByScalar(B,.5,B),b.push(B.x,B.y,B.z),h=b.length/3-1,R[H]=h,s&&(z=r["a"].add(l,d,N),r["a"].multiplyByScalar(z,.5,z),w.push(z.x,z.y))),p.push(a,h,e),p.push(h,t,e)):j===F?(H=`${Math.min(t,e)} ${Math.max(t,e)}`,h=R[H],Object(u["a"])(h)||(B=i["a"].add(o,c,x),i["a"].multiplyByScalar(B,.5,B),b.push(B.x,B.y,B.z),h=b.length/3-1,R[H]=h,s&&(z=r["a"].add(d,g,N),r["a"].multiplyByScalar(z,.5,z),w.push(z.x,z.y))),p.push(t,h,a),p.push(h,e,a)):G===F&&(H=`${Math.min(e,a)} ${Math.max(e,a)}`,h=R[H],Object(u["a"])(h)||(B=i["a"].add(c,n,x),i["a"].multiplyByScalar(B,.5,B),b.push(B.x,B.y,B.z),h=b.length/3-1,R[H]=h,s&&(z=r["a"].add(g,l,N),r["a"].multiplyByScalar(z,.5,z),w.push(z.x,z.y))),p.push(e,h,t),p.push(h,a,t)):(D.push(a),D.push(t),D.push(e))}const F={attributes:{position:new g["a"]({componentDatatype:c["a"].DOUBLE,componentsPerAttribute:3,values:b})},indices:D,primitiveType:f["a"].TRIANGLES};return s&&(F.attributes.st=new g["a"]({componentDatatype:c["a"].FLOAT,componentsPerAttribute:2,values:w})),new d["a"](F)};const j=new s["a"],D=new s["a"],R=new s["a"],k=new s["a"];O.computeRhumbLineSubdivision=function(e,t,a,n,o){o=Object(l["a"])(o,y["a"].RADIANS_PER_DEGREE);const s=Object(u["a"])(n),p=a.slice(0);let m;const b=t.length,w=new Array(3*b),O=new Array(2*b);let E=0,P=0;for(m=0;m<b;m++){const e=t[m];if(w[E++]=e.x,w[E++]=e.y,w[E++]=e.z,s){const e=n[m];O[P++]=e.x,O[P++]=e.y}}const v=[],G={},C=e.maximumRadius,F=y["a"].chordLength(o,C),H=new h["a"](void 0,void 0,e),B=new h["a"](void 0,void 0,e),z=new h["a"](void 0,void 0,e);while(p.length>0){const t=p.pop(),a=p.pop(),n=p.pop(),o=i["a"].fromArray(w,3*n,_),c=i["a"].fromArray(w,3*a,T),l=i["a"].fromArray(w,3*t,A);let h,d,g;s&&(h=r["a"].fromArray(O,2*n,L),d=r["a"].fromArray(O,2*a,I),g=r["a"].fromArray(O,2*t,S));const y=e.cartesianToCartographic(o,j),f=e.cartesianToCartographic(c,D),b=e.cartesianToCartographic(l,R);H.setEndPoints(y,f);const E=H.surfaceDistance;B.setEndPoints(f,b);const P=B.surfaceDistance;z.setEndPoints(b,y);const C=z.surfaceDistance,M=Math.max(E,P,C);let U,V,W,q,Y;M>F?E===M?(U=`${Math.min(n,a)} ${Math.max(n,a)}`,m=G[U],Object(u["a"])(m)||(V=H.interpolateUsingFraction(.5,k),W=.5*(y.height+f.height),q=i["a"].fromRadians(V.longitude,V.latitude,W,e,x),w.push(q.x,q.y,q.z),m=w.length/3-1,G[U]=m,s&&(Y=r["a"].add(h,d,N),r["a"].multiplyByScalar(Y,.5,Y),O.push(Y.x,Y.y))),p.push(n,m,t),p.push(m,a,t)):P===M?(U=`${Math.min(a,t)} ${Math.max(a,t)}`,m=G[U],Object(u["a"])(m)||(V=B.interpolateUsingFraction(.5,k),W=.5*(f.height+b.height),q=i["a"].fromRadians(V.longitude,V.latitude,W,e,x),w.push(q.x,q.y,q.z),m=w.length/3-1,G[U]=m,s&&(Y=r["a"].add(d,g,N),r["a"].multiplyByScalar(Y,.5,Y),O.push(Y.x,Y.y))),p.push(a,m,n),p.push(m,t,n)):C===M&&(U=`${Math.min(t,n)} ${Math.max(t,n)}`,m=G[U],Object(u["a"])(m)||(V=z.interpolateUsingFraction(.5,k),W=.5*(b.height+y.height),q=i["a"].fromRadians(V.longitude,V.latitude,W,e,x),w.push(q.x,q.y,q.z),m=w.length/3-1,G[U]=m,s&&(Y=r["a"].add(g,h,N),r["a"].multiplyByScalar(Y,.5,Y),O.push(Y.x,Y.y))),p.push(t,m,a),p.push(m,n,a)):(v.push(n),v.push(a),v.push(t))}const M={attributes:{position:new g["a"]({componentDatatype:c["a"].DOUBLE,componentsPerAttribute:3,values:w})},indices:v,primitiveType:f["a"].TRIANGLES};return s&&(M.attributes.st=new g["a"]({componentDatatype:c["a"].FLOAT,componentsPerAttribute:2,values:O})),new d["a"](M)},O.scaleToGeodeticHeight=function(e,t,a,n){a=Object(l["a"])(a,p["a"].WGS84);let o=b,r=w;if(t=Object(l["a"])(t,0),n=Object(l["a"])(n,!0),Object(u["a"])(e)){const s=e.length;for(let c=0;c<s;c+=3)i["a"].fromArray(e,c,r),n&&(r=a.scaleToGeodeticSurface(r,r)),0!==t&&(o=a.geodeticSurfaceNormal(r,o),i["a"].multiplyByScalar(o,t,o),i["a"].add(r,o,r)),e[c]=r.x,e[c+1]=r.y,e[c+2]=r.z}return e},t["a"]=O},af94:function(e,t,a){"use strict";var n=a("ee1e"),o=a("77af"),r=a("cef5"),i=a("670c"),s=a("be18"),c=a("abab"),l=a("d0c2"),u=a("535a"),p=a("2f63"),h=a("c52f"),d=a("d2c7"),g=a("81d7"),y=a("473c"),f=a("c1e2"),m=a("0123"),b=a("93da"),w=a("b639"),O=a("9251"),_=a("29bd"),T=a("1b8d"),A=a("0541"),E=a("b48e");function P(e,t,a,n){const o=new y["a"];n.position&&(o.position=new g["a"]({componentDatatype:c["a"].DOUBLE,componentsPerAttribute:3,values:e}));const i=t.length,s=e.length/3,l=(s-2*i)/(2*i),u=O["a"].triangulate(t),p=(l-1)*i*6+2*u.length,h=m["a"].createTypedArray(s,p);let b,_,A,E,P,v;const x=2*i;let L=0;for(b=0;b<l-1;b++){for(_=0;_<i-1;_++)A=2*_+b*i*2,v=A+x,E=A+1,P=E+x,h[L++]=E,h[L++]=A,h[L++]=P,h[L++]=P,h[L++]=A,h[L++]=v;A=2*i-2+b*i*2,E=A+1,P=E+x,v=A+x,h[L++]=E,h[L++]=A,h[L++]=P,h[L++]=P,h[L++]=A,h[L++]=v}if(n.st||n.tangent||n.bitangent){const e=new Float32Array(2*s),n=1/(l-1),r=1/a.height,u=a.height/2;let p,h,d=0;for(b=0;b<l;b++){for(p=b*n,h=r*(t[0].y+u),e[d++]=p,e[d++]=h,_=1;_<i;_++)h=r*(t[_].y+u),e[d++]=p,e[d++]=h,e[d++]=p,e[d++]=h;h=r*(t[0].y+u),e[d++]=p,e[d++]=h}for(_=0;_<i;_++)p=0,h=r*(t[_].y+u),e[d++]=p,e[d++]=h;for(_=0;_<i;_++)p=(l-1)*n,h=r*(t[_].y+u),e[d++]=p,e[d++]=h;o.st=new g["a"]({componentDatatype:c["a"].FLOAT,componentsPerAttribute:2,values:new Float32Array(e)})}const I=s-2*i;for(b=0;b<u.length;b+=3){const e=u[b]+I,t=u[b+1]+I,a=u[b+2]+I;h[L++]=e,h[L++]=t,h[L++]=a,h[L++]=a+i,h[L++]=t+i,h[L++]=e+i}let S=new d["a"]({attributes:o,indices:h,boundingSphere:r["a"].fromVertices(e),primitiveType:T["a"].TRIANGLES});if(n.normal&&(S=f["a"].computeNormal(S)),n.tangent||n.bitangent){try{S=f["a"].computeTangentAndBitangent(S)}catch(N){Object(w["a"])("polyline-volume-tangent-bitangent","Unable to compute tangents and bitangents for polyline volume geometry")}n.tangent||(S.attributes.tangent=void 0),n.bitangent||(S.attributes.bitangent=void 0),n.st||(S.attributes.st=void 0)}return S}function v(e){e=Object(u["a"])(e,u["a"].EMPTY_OBJECT);const t=e.polylinePositions,a=e.shapePositions;this._positions=t,this._shape=a,this._ellipsoid=h["a"].clone(Object(u["a"])(e.ellipsoid,h["a"].WGS84)),this._cornerType=Object(u["a"])(e.cornerType,l["a"].ROUNDED),this._vertexFormat=A["a"].clone(Object(u["a"])(e.vertexFormat,A["a"].DEFAULT)),this._granularity=Object(u["a"])(e.granularity,b["a"].RADIANS_PER_DEGREE),this._workerName="createPolylineVolumeGeometry";let n=1+t.length*s["a"].packedLength;n+=1+a.length*i["a"].packedLength,this.packedLength=n+h["a"].packedLength+A["a"].packedLength+2}v.pack=function(e,t,a){let n;a=Object(u["a"])(a,0);const o=e._positions;let r=o.length;for(t[a++]=r,n=0;n<r;++n,a+=s["a"].packedLength)s["a"].pack(o[n],t,a);const c=e._shape;for(r=c.length,t[a++]=r,n=0;n<r;++n,a+=i["a"].packedLength)i["a"].pack(c[n],t,a);return h["a"].pack(e._ellipsoid,t,a),a+=h["a"].packedLength,A["a"].pack(e._vertexFormat,t,a),a+=A["a"].packedLength,t[a++]=e._cornerType,t[a]=e._granularity,t};const x=h["a"].clone(h["a"].UNIT_SPHERE),L=new A["a"],I={polylinePositions:void 0,shapePositions:void 0,ellipsoid:x,vertexFormat:L,cornerType:void 0,granularity:void 0};v.unpack=function(e,t,a){let n;t=Object(u["a"])(t,0);let o=e[t++];const r=new Array(o);for(n=0;n<o;++n,t+=s["a"].packedLength)r[n]=s["a"].unpack(e,t);o=e[t++];const c=new Array(o);for(n=0;n<o;++n,t+=i["a"].packedLength)c[n]=i["a"].unpack(e,t);const l=h["a"].unpack(e,t,x);t+=h["a"].packedLength;const d=A["a"].unpack(e,t,L);t+=A["a"].packedLength;const g=e[t++],y=e[t];return Object(p["a"])(a)?(a._positions=r,a._shape=c,a._ellipsoid=h["a"].clone(l,a._ellipsoid),a._vertexFormat=A["a"].clone(d,a._vertexFormat),a._cornerType=g,a._granularity=y,a):(I.polylinePositions=r,I.shapePositions=c,I.cornerType=g,I.granularity=y,new v(I))};const S=new o["a"];v.createGeometry=function(e){const t=e._positions,a=Object(n["a"])(t,s["a"].equalsEpsilon);let r=e._shape;if(r=_["a"].removeDuplicatesFromShape(r),a.length<2||r.length<3)return;O["a"].computeWindingOrder2D(r)===E["a"].CLOCKWISE&&r.reverse();const i=o["a"].fromPoints(r,S),c=_["a"].computePositions(a,r,i,e,!0);return P(c,r,i,e._vertexFormat)},t["a"]=v},b999:function(e,t,a){"use strict";var n=a("cef5"),o=a("be18"),r=a("abab"),i=a("2f63"),s=a("d2c7"),c=a("81d7"),l=a("473c"),u=a("1b8d");function p(){this._workerName="createPlaneOutlineGeometry"}p.packedLength=0,p.pack=function(e,t){return t},p.unpack=function(e,t,a){return Object(i["a"])(a)?a:new p};const h=new o["a"](-.5,-.5,0),d=new o["a"](.5,.5,0);p.createGeometry=function(){const e=new l["a"],t=new Uint16Array(8),a=new Float64Array(12);return a[0]=h.x,a[1]=h.y,a[2]=h.z,a[3]=d.x,a[4]=h.y,a[5]=h.z,a[6]=d.x,a[7]=d.y,a[8]=h.z,a[9]=h.x,a[10]=d.y,a[11]=h.z,e.position=new c["a"]({componentDatatype:r["a"].DOUBLE,componentsPerAttribute:3,values:a}),t[0]=0,t[1]=1,t[2]=1,t[3]=2,t[4]=2,t[5]=3,t[6]=3,t[7]=0,new s["a"]({attributes:e,indices:t,primitiveType:u["a"].LINES,boundingSphere:new n["a"](o["a"].ZERO,Math.sqrt(2))})},t["a"]=p},bb71:function(e,t,a){"use strict";var n=a("9201"),o=a("ee1e"),r=a("cef5"),i=a("be18"),s=a("bd8d"),c=a("abab"),l=a("535a"),u=a("2f63"),p=a("c52f"),h=a("d2c7"),d=a("81d7"),g=a("473c"),y=a("3740"),f=a("0123"),m=a("93da"),b=a("31af"),w=a("1b8d"),O=a("0541");const _=[];function T(e,t,a,n,o){const r=_;let i;r.length=o;const c=a.red,l=a.green,u=a.blue,p=a.alpha,h=n.red,d=n.green,g=n.blue,y=n.alpha;if(s["a"].equals(a,n)){for(i=0;i<o;i++)r[i]=s["a"].clone(a);return r}const f=(h-c)/o,m=(d-l)/o,b=(g-u)/o,w=(y-p)/o;for(i=0;i<o;i++)r[i]=new s["a"](c+i*f,l+i*m,u+i*b,p+i*w);return r}function A(e){e=Object(l["a"])(e,l["a"].EMPTY_OBJECT);const t=e.positions,a=e.colors,o=Object(l["a"])(e.width,1),r=Object(l["a"])(e.colorsPerVertex,!1);this._positions=t,this._colors=a,this._width=o,this._colorsPerVertex=r,this._vertexFormat=O["a"].clone(Object(l["a"])(e.vertexFormat,O["a"].DEFAULT)),this._arcType=Object(l["a"])(e.arcType,n["a"].GEODESIC),this._granularity=Object(l["a"])(e.granularity,m["a"].RADIANS_PER_DEGREE),this._ellipsoid=p["a"].clone(Object(l["a"])(e.ellipsoid,p["a"].WGS84)),this._workerName="createPolylineGeometry";let c=1+t.length*i["a"].packedLength;c+=Object(u["a"])(a)?1+a.length*s["a"].packedLength:1,this.packedLength=c+p["a"].packedLength+O["a"].packedLength+4}A.pack=function(e,t,a){let n;a=Object(l["a"])(a,0);const o=e._positions;let r=o.length;for(t[a++]=r,n=0;n<r;++n,a+=i["a"].packedLength)i["a"].pack(o[n],t,a);const c=e._colors;for(r=Object(u["a"])(c)?c.length:0,t[a++]=r,n=0;n<r;++n,a+=s["a"].packedLength)s["a"].pack(c[n],t,a);return p["a"].pack(e._ellipsoid,t,a),a+=p["a"].packedLength,O["a"].pack(e._vertexFormat,t,a),a+=O["a"].packedLength,t[a++]=e._width,t[a++]=e._colorsPerVertex?1:0,t[a++]=e._arcType,t[a]=e._granularity,t};const E=p["a"].clone(p["a"].UNIT_SPHERE),P=new O["a"],v={positions:void 0,colors:void 0,ellipsoid:E,vertexFormat:P,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};A.unpack=function(e,t,a){let n;t=Object(l["a"])(t,0);let o=e[t++];const r=new Array(o);for(n=0;n<o;++n,t+=i["a"].packedLength)r[n]=i["a"].unpack(e,t);o=e[t++];const c=o>0?new Array(o):void 0;for(n=0;n<o;++n,t+=s["a"].packedLength)c[n]=s["a"].unpack(e,t);const h=p["a"].unpack(e,t,E);t+=p["a"].packedLength;const d=O["a"].unpack(e,t,P);t+=O["a"].packedLength;const g=e[t++],y=1===e[t++],f=e[t++],m=e[t];return Object(u["a"])(a)?(a._positions=r,a._colors=c,a._ellipsoid=p["a"].clone(h,a._ellipsoid),a._vertexFormat=O["a"].clone(d,a._vertexFormat),a._width=g,a._colorsPerVertex=y,a._arcType=f,a._granularity=m,a):(v.positions=r,v.colors=c,v.width=g,v.colorsPerVertex=y,v.arcType=f,v.granularity=m,new A(v))};const x=new i["a"],L=new i["a"],I=new i["a"],S=new i["a"];A.createGeometry=function(e){const t=e._width,a=e._vertexFormat;let l=e._colors;const p=e._colorsPerVertex,O=e._arcType,A=e._granularity,E=e._ellipsoid;let P,v,N;const j=[];let D=Object(o["a"])(e._positions,i["a"].equalsEpsilon,!1,j);if(Object(u["a"])(l)&&j.length>0){let e=0,t=j[0];l=l.filter((function(a,n){let o=!1;return o=p?n===t||0===n&&1===t:n+1===t,!o||(e++,t=j[e],!1)}))}let R=D.length;if(R<2||t<=0)return;if(O===n["a"].GEODESIC||O===n["a"].RHUMB){let e,t;O===n["a"].GEODESIC?(e=m["a"].chordLength(A,E.maximumRadius),t=b["a"].numberOfPoints):(e=A,t=b["a"].numberOfPointsRhumbLine);const a=b["a"].extractHeights(D,E);if(Object(u["a"])(l)){let a=1;for(P=0;P<R-1;++P)a+=t(D[P],D[P+1],e);const n=new Array(a);let o=0;for(P=0;P<R-1;++P){const r=D[P],i=D[P+1],c=l[P],u=t(r,i,e);if(p&&P<a){const e=l[P+1],t=T(r,i,c,e,u),a=t.length;for(v=0;v<a;++v)n[o++]=t[v]}else for(v=0;v<u;++v)n[o++]=s["a"].clone(c)}n[o]=s["a"].clone(l[l.length-1]),l=n,_.length=0}D=O===n["a"].GEODESIC?b["a"].generateCartesianArc({positions:D,minDistance:e,ellipsoid:E,height:a}):b["a"].generateCartesianRhumbArc({positions:D,granularity:e,ellipsoid:E,height:a})}R=D.length;const k=4*R-4,G=new Float64Array(3*k),C=new Float64Array(3*k),F=new Float64Array(3*k),H=new Float32Array(2*k),B=a.st?new Float32Array(2*k):void 0,z=Object(u["a"])(l)?new Uint8Array(4*k):void 0;let M,U=0,V=0,W=0,q=0;for(v=0;v<R;++v){let e,n;0===v?(M=x,i["a"].subtract(D[0],D[1],M),i["a"].add(D[0],M,M)):M=D[v-1],i["a"].clone(M,I),i["a"].clone(D[v],L),v===R-1?(M=x,i["a"].subtract(D[R-1],D[R-2],M),i["a"].add(D[R-1],M,M)):M=D[v+1],i["a"].clone(M,S),Object(u["a"])(z)&&(e=0===v||p?l[v]:l[v-1],v!==R-1&&(n=l[v]));const o=0===v?2:0,r=v===R-1?2:4;for(N=o;N<r;++N){i["a"].pack(L,G,U),i["a"].pack(I,C,U),i["a"].pack(S,F,U),U+=3;const o=N-2<0?-1:1;if(H[V++]=N%2*2-1,H[V++]=o*t,a.st&&(B[W++]=v/(R-1),B[W++]=Math.max(H[V-2],0)),Object(u["a"])(z)){const t=N<2?e:n;z[q++]=s["a"].floatToByte(t.red),z[q++]=s["a"].floatToByte(t.green),z[q++]=s["a"].floatToByte(t.blue),z[q++]=s["a"].floatToByte(t.alpha)}}}const Y=new g["a"];Y.position=new d["a"]({componentDatatype:c["a"].DOUBLE,componentsPerAttribute:3,values:G}),Y.prevPosition=new d["a"]({componentDatatype:c["a"].DOUBLE,componentsPerAttribute:3,values:C}),Y.nextPosition=new d["a"]({componentDatatype:c["a"].DOUBLE,componentsPerAttribute:3,values:F}),Y.expandAndWidth=new d["a"]({componentDatatype:c["a"].FLOAT,componentsPerAttribute:2,values:H}),a.st&&(Y.st=new d["a"]({componentDatatype:c["a"].FLOAT,componentsPerAttribute:2,values:B})),Object(u["a"])(z)&&(Y.color=new d["a"]({componentDatatype:c["a"].UNSIGNED_BYTE,componentsPerAttribute:4,values:z,normalize:!0}));const $=f["a"].createTypedArray(k,6*R-6);let K=0,Z=0;const J=R-1;for(v=0;v<J;++v)$[Z++]=K,$[Z++]=K+2,$[Z++]=K+1,$[Z++]=K+1,$[Z++]=K+2,$[Z++]=K+3,K+=4;return new h["a"]({attributes:Y,indices:$,primitiveType:w["a"].TRIANGLES,boundingSphere:r["a"].fromPoints(D),geometryType:y["a"].POLYLINES})},t["a"]=A},e53f:function(e,t,a){"use strict";var n=a("ee1e"),o=a("77af"),r=a("cef5"),i=a("670c"),s=a("be18"),c=a("abab"),l=a("d0c2"),u=a("535a"),p=a("2f63"),h=a("c52f"),d=a("d2c7"),g=a("81d7"),y=a("473c"),f=a("0123"),m=a("93da"),b=a("9251"),w=a("29bd"),O=a("1b8d"),_=a("b48e");function T(e,t){const a=new y["a"];a.position=new g["a"]({componentDatatype:c["a"].DOUBLE,componentsPerAttribute:3,values:e});const n=t.length,o=a.position.values.length/3,i=e.length/3,s=i/n,l=f["a"].createTypedArray(o,2*n*(s+1));let u,p,h=0;u=0;let m=u*n;for(p=0;p<n-1;p++)l[h++]=p+m,l[h++]=p+m+1;for(l[h++]=n-1+m,l[h++]=m,u=s-1,m=u*n,p=0;p<n-1;p++)l[h++]=p+m,l[h++]=p+m+1;for(l[h++]=n-1+m,l[h++]=m,u=0;u<s-1;u++){const e=n*u,t=e+n;for(p=0;p<n;p++)l[h++]=p+e,l[h++]=p+t}const b=new d["a"]({attributes:a,indices:f["a"].createTypedArray(o,l),boundingSphere:r["a"].fromVertices(e),primitiveType:O["a"].LINES});return b}function A(e){e=Object(u["a"])(e,u["a"].EMPTY_OBJECT);const t=e.polylinePositions,a=e.shapePositions;this._positions=t,this._shape=a,this._ellipsoid=h["a"].clone(Object(u["a"])(e.ellipsoid,h["a"].WGS84)),this._cornerType=Object(u["a"])(e.cornerType,l["a"].ROUNDED),this._granularity=Object(u["a"])(e.granularity,m["a"].RADIANS_PER_DEGREE),this._workerName="createPolylineVolumeOutlineGeometry";let n=1+t.length*s["a"].packedLength;n+=1+a.length*i["a"].packedLength,this.packedLength=n+h["a"].packedLength+2}A.pack=function(e,t,a){let n;a=Object(u["a"])(a,0);const o=e._positions;let r=o.length;for(t[a++]=r,n=0;n<r;++n,a+=s["a"].packedLength)s["a"].pack(o[n],t,a);const c=e._shape;for(r=c.length,t[a++]=r,n=0;n<r;++n,a+=i["a"].packedLength)i["a"].pack(c[n],t,a);return h["a"].pack(e._ellipsoid,t,a),a+=h["a"].packedLength,t[a++]=e._cornerType,t[a]=e._granularity,t};const E=h["a"].clone(h["a"].UNIT_SPHERE),P={polylinePositions:void 0,shapePositions:void 0,ellipsoid:E,height:void 0,cornerType:void 0,granularity:void 0};A.unpack=function(e,t,a){let n;t=Object(u["a"])(t,0);let o=e[t++];const r=new Array(o);for(n=0;n<o;++n,t+=s["a"].packedLength)r[n]=s["a"].unpack(e,t);o=e[t++];const c=new Array(o);for(n=0;n<o;++n,t+=i["a"].packedLength)c[n]=i["a"].unpack(e,t);const l=h["a"].unpack(e,t,E);t+=h["a"].packedLength;const d=e[t++],g=e[t];return Object(p["a"])(a)?(a._positions=r,a._shape=c,a._ellipsoid=h["a"].clone(l,a._ellipsoid),a._cornerType=d,a._granularity=g,a):(P.polylinePositions=r,P.shapePositions=c,P.cornerType=d,P.granularity=g,new A(P))};const v=new o["a"];A.createGeometry=function(e){const t=e._positions,a=Object(n["a"])(t,s["a"].equalsEpsilon);let r=e._shape;if(r=w["a"].removeDuplicatesFromShape(r),a.length<2||r.length<3)return;b["a"].computeWindingOrder2D(r)===_["a"].CLOCKWISE&&r.reverse();const i=o["a"].fromPoints(r,v),c=w["a"].computePositions(a,r,i,e,!1);return T(c,r)},t["a"]=A}}]);