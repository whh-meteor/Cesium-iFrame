(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["Cesium~7978149b"],{"1ac2":function(t,e,a){"use strict";var i=a("cef5"),n=a("be18"),o=a("abab"),r=a("535a"),s=a("2f63"),c=a("cfdc"),u=a("c52f"),l=a("d2c7"),d=a("81d7"),h=a("473c"),m=a("0276"),f=a("0123"),_=a("93da"),p=a("1b8d");const g=new n["a"];let O=new n["a"];function y(t){const e=t.center;O=n["a"].multiplyByScalar(t.ellipsoid.geodeticSurfaceNormal(e,O),t.height,O),O=n["a"].add(e,O,O);const a=new i["a"](O,t.semiMajorAxis),r=c["a"].computeEllipsePositions(t,!1,!0).outerPositions,s=new h["a"]({position:new d["a"]({componentDatatype:o["a"].DOUBLE,componentsPerAttribute:3,values:c["a"].raisePositionsToHeight(r,t,!1)})}),u=r.length/3,l=f["a"].createTypedArray(u,2*u);let m=0;for(let i=0;i<u;++i)l[m++]=i,l[m++]=(i+1)%u;return{boundingSphere:a,attributes:s,indices:l}}const b=new i["a"],x=new i["a"];function P(t){const e=t.center,a=t.ellipsoid,u=t.semiMajorAxis;let l=n["a"].multiplyByScalar(a.geodeticSurfaceNormal(e,g),t.height,g);b.center=n["a"].add(e,l,b.center),b.radius=u,l=n["a"].multiplyByScalar(a.geodeticSurfaceNormal(e,l),t.extrudedHeight,l),x.center=n["a"].add(e,l,x.center),x.radius=u;let p=c["a"].computeEllipsePositions(t,!1,!0).outerPositions;const O=new h["a"]({position:new d["a"]({componentDatatype:o["a"].DOUBLE,componentsPerAttribute:3,values:c["a"].raisePositionsToHeight(p,t,!0)})});p=O.position.values;const y=i["a"].union(b,x);let P=p.length/3;if(Object(s["a"])(t.offsetAttribute)){let e=new Uint8Array(P);if(t.offsetAttribute===m["a"].TOP)e=e.fill(1,0,P/2);else{const a=t.offsetAttribute===m["a"].NONE?0:1;e=e.fill(a)}O.applyOffset=new d["a"]({componentDatatype:o["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}let A=Object(r["a"])(t.numberOfVerticalLines,16);A=_["a"].clamp(A,0,P/2);const w=f["a"].createTypedArray(P,2*P+2*A);P/=2;let M,E,S=0;for(M=0;M<P;++M)w[S++]=M,w[S++]=(M+1)%P,w[S++]=M+P,w[S++]=(M+1)%P+P;if(A>0){const t=Math.min(A,P);E=Math.round(P/t);const e=Math.min(E*A,P);for(M=0;M<e;M+=E)w[S++]=M,w[S++]=M+P}return{boundingSphere:y,attributes:O,indices:w}}function A(t){t=Object(r["a"])(t,r["a"].EMPTY_OBJECT);const e=t.center,a=Object(r["a"])(t.ellipsoid,u["a"].WGS84),i=t.semiMajorAxis,o=t.semiMinorAxis,s=Object(r["a"])(t.granularity,_["a"].RADIANS_PER_DEGREE),c=Object(r["a"])(t.height,0),l=Object(r["a"])(t.extrudedHeight,c);this._center=n["a"].clone(e),this._semiMajorAxis=i,this._semiMinorAxis=o,this._ellipsoid=u["a"].clone(a),this._rotation=Object(r["a"])(t.rotation,0),this._height=Math.max(l,c),this._granularity=s,this._extrudedHeight=Math.min(l,c),this._numberOfVerticalLines=Math.max(Object(r["a"])(t.numberOfVerticalLines,16),0),this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipseOutlineGeometry"}A.packedLength=n["a"].packedLength+u["a"].packedLength+8,A.pack=function(t,e,a){return a=Object(r["a"])(a,0),n["a"].pack(t._center,e,a),a+=n["a"].packedLength,u["a"].pack(t._ellipsoid,e,a),a+=u["a"].packedLength,e[a++]=t._semiMajorAxis,e[a++]=t._semiMinorAxis,e[a++]=t._rotation,e[a++]=t._height,e[a++]=t._granularity,e[a++]=t._extrudedHeight,e[a++]=t._numberOfVerticalLines,e[a]=Object(r["a"])(t._offsetAttribute,-1),e};const w=new n["a"],M=new u["a"],E={center:w,ellipsoid:M,semiMajorAxis:void 0,semiMinorAxis:void 0,rotation:void 0,height:void 0,granularity:void 0,extrudedHeight:void 0,numberOfVerticalLines:void 0,offsetAttribute:void 0};A.unpack=function(t,e,a){e=Object(r["a"])(e,0);const i=n["a"].unpack(t,e,w);e+=n["a"].packedLength;const o=u["a"].unpack(t,e,M);e+=u["a"].packedLength;const c=t[e++],l=t[e++],d=t[e++],h=t[e++],m=t[e++],f=t[e++],_=t[e++],p=t[e];return Object(s["a"])(a)?(a._center=n["a"].clone(i,a._center),a._ellipsoid=u["a"].clone(o,a._ellipsoid),a._semiMajorAxis=c,a._semiMinorAxis=l,a._rotation=d,a._height=h,a._granularity=m,a._extrudedHeight=f,a._numberOfVerticalLines=_,a._offsetAttribute=-1===p?void 0:p,a):(E.height=h,E.extrudedHeight=f,E.granularity=m,E.rotation=d,E.semiMajorAxis=c,E.semiMinorAxis=l,E.numberOfVerticalLines=_,E.offsetAttribute=-1===p?void 0:p,new A(E))},A.createGeometry=function(t){if(t._semiMajorAxis<=0||t._semiMinorAxis<=0)return;const e=t._height,a=t._extrudedHeight,i=!_["a"].equalsEpsilon(e,a,0,_["a"].EPSILON2);t._center=t._ellipsoid.scaleToGeodeticSurface(t._center,t._center);const n={center:t._center,semiMajorAxis:t._semiMajorAxis,semiMinorAxis:t._semiMinorAxis,ellipsoid:t._ellipsoid,rotation:t._rotation,height:e,granularity:t._granularity,numberOfVerticalLines:t._numberOfVerticalLines};let r;if(i)n.extrudedHeight=a,n.offsetAttribute=t._offsetAttribute,r=P(n);else if(r=y(n),Object(s["a"])(t._offsetAttribute)){const e=r.attributes.position.values.length,a=t._offsetAttribute===m["a"].NONE?0:1,i=new Uint8Array(e/3).fill(a);r.attributes.applyOffset=new d["a"]({componentDatatype:o["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}return new l["a"]({attributes:r.attributes,indices:r.indices,primitiveType:p["a"].LINES,boundingSphere:r.boundingSphere,offsetAttribute:t._offsetAttribute})},e["a"]=A},"1e13":function(t,e,a){"use strict";var i=a("be18"),n=a("bef8"),o=a("535a"),r=a("2f63"),s=a("c52f"),c=a("93da");function u(t){const e=t._uSquared,a=t._ellipsoid.maximumRadius,i=t._ellipsoid.minimumRadius,n=(a-i)/a,o=Math.cos(t._startHeading),r=Math.sin(t._startHeading),s=(1-n)*Math.tan(t._start.latitude),c=1/Math.sqrt(1+s*s),u=c*s,l=Math.atan2(s,o),d=c*r,h=d*d,m=1-h,f=Math.sqrt(m),_=e/4,p=_*_,g=p*_,O=p*p,y=1+_-3*p/4+5*g/4-175*O/64,b=1-_+15*p/8-35*g/8,x=1-3*_+35*p/4,P=1-5*_,A=y*l-b*Math.sin(2*l)*_/2-x*Math.sin(4*l)*p/16-P*Math.sin(6*l)*g/48-5*Math.sin(8*l)*O/512,w=t._constants;w.a=a,w.b=i,w.f=n,w.cosineHeading=o,w.sineHeading=r,w.tanU=s,w.cosineU=c,w.sineU=u,w.sigma=l,w.sineAlpha=d,w.sineSquaredAlpha=h,w.cosineSquaredAlpha=m,w.cosineAlpha=f,w.u2Over4=_,w.u4Over16=p,w.u6Over64=g,w.u8Over256=O,w.a0=y,w.a1=b,w.a2=x,w.a3=P,w.distanceRatio=A}function l(t,e){return t*e*(4+t*(4-3*e))/16}function d(t,e,a,i,n,o,r){const s=l(t,a);return(1-s)*t*e*(i+s*n*(r+s*o*(2*r*r-1)))}function h(t,e,a,i,n,o,r){const s=(e-a)/e,u=o-i,l=Math.atan((1-s)*Math.tan(n)),h=Math.atan((1-s)*Math.tan(r)),m=Math.cos(l),f=Math.sin(l),_=Math.cos(h),p=Math.sin(h),g=m*_,O=m*p,y=f*p,b=f*_;let x,P,A,w,M,E=u,S=c["a"].TWO_PI,v=Math.cos(E),T=Math.sin(E);do{v=Math.cos(E),T=Math.sin(E);const t=O-b*v;let e;A=Math.sqrt(_*_*T*T+t*t),P=y+g*v,x=Math.atan2(A,P),0===A?(e=0,w=1):(e=g*T/A,w=1-e*e),S=E,M=P-2*y/w,isFinite(M)||(M=0),E=u+d(s,e,w,x,A,P,M)}while(Math.abs(E-S)>c["a"].EPSILON12);const I=w*(e*e-a*a)/(a*a),j=1+I*(4096+I*(I*(320-175*I)-768))/16384,C=I*(256+I*(I*(74-47*I)-128))/1024,N=M*M,R=C*A*(M+C*(P*(2*N-1)-C*M*(4*A*A-3)*(4*N-3)/6)/4),L=a*j*(x-R),k=Math.atan2(_*T,O-b*v),U=Math.atan2(m*T,O*v-b);t._distance=L,t._startHeading=k,t._endHeading=U,t._uSquared=I}const m=new i["a"],f=new i["a"];function _(t,e,a,o){i["a"].normalize(o.cartographicToCartesian(e,f),m),i["a"].normalize(o.cartographicToCartesian(a,f),f);h(t,o.maximumRadius,o.minimumRadius,e.longitude,e.latitude,a.longitude,a.latitude),t._start=n["a"].clone(e,t._start),t._end=n["a"].clone(a,t._end),t._start.height=0,t._end.height=0,u(t)}function p(t,e,a){const i=Object(o["a"])(a,s["a"].WGS84);this._ellipsoid=i,this._start=new n["a"],this._end=new n["a"],this._constants={},this._startHeading=void 0,this._endHeading=void 0,this._distance=void 0,this._uSquared=void 0,Object(r["a"])(t)&&Object(r["a"])(e)&&_(this,t,e,i)}Object.defineProperties(p.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},surfaceDistance:{get:function(){return this._distance}},start:{get:function(){return this._start}},end:{get:function(){return this._end}},startHeading:{get:function(){return this._startHeading}},endHeading:{get:function(){return this._endHeading}}}),p.prototype.setEndPoints=function(t,e){_(this,t,e,this._ellipsoid)},p.prototype.interpolateUsingFraction=function(t,e){return this.interpolateUsingSurfaceDistance(this._distance*t,e)},p.prototype.interpolateUsingSurfaceDistance=function(t,e){const a=this._constants,i=a.distanceRatio+t/a.b,o=Math.cos(2*i),s=Math.cos(4*i),c=Math.cos(6*i),u=Math.sin(2*i),l=Math.sin(4*i),h=Math.sin(6*i),m=Math.sin(8*i),f=i*i,_=i*f,p=a.u8Over256,g=a.u2Over4,O=a.u6Over64,y=a.u4Over16;let b=2*_*p*o/3+i*(1-g+7*y/4-15*O/4+579*p/64-(y-15*O/4+187*p/16)*o-(5*O/4-115*p/16)*s-29*p*c/16)+(g/2-y+71*O/32-85*p/16)*u+(5*y/16-5*O/4+383*p/96)*l-f*((O-11*p/2)*u+5*p*l/2)+(29*O/96-29*p/16)*h+539*p*m/1536;const x=Math.asin(Math.sin(b)*a.cosineAlpha),P=Math.atan(a.a/a.b*Math.tan(x));b-=a.sigma;const A=Math.cos(2*a.sigma+b),w=Math.sin(b),M=Math.cos(b),E=a.cosineU*M,S=a.sineU*w,v=Math.atan2(w*a.sineHeading,E-S*a.cosineHeading),T=v-d(a.f,a.sineAlpha,a.cosineSquaredAlpha,b,w,M,A);return Object(r["a"])(e)?(e.longitude=this._start.longitude+T,e.latitude=P,e.height=0,e):new n["a"](this._start.longitude+T,P,0)},e["a"]=p},"204a":function(t,e,a){"use strict";var i=a("535a"),n=a("2f63"),o=a("c52f"),r=a("21d7"),s=a("5d5c"),c=a("af23"),u=a("1ee6");function l(t){t=Object(i["a"])(t,i["a"].EMPTY_OBJECT),this._tilingScheme=t.tilingScheme,Object(n["a"])(this._tilingScheme)||(this._tilingScheme=new s["a"]({ellipsoid:Object(i["a"])(t.ellipsoid,o["a"].WGS84)})),this._levelZeroMaximumGeometricError=u["a"].getEstimatedLevelZeroGeometricErrorForAHeightmap(this._tilingScheme.ellipsoid,64,this._tilingScheme.getNumberOfXTilesAtLevel(0)),this._errorEvent=new r["a"],this._readyPromise=Promise.resolve(!0)}Object.defineProperties(l.prototype,{errorEvent:{get:function(){return this._errorEvent}},credit:{get:function(){}},tilingScheme:{get:function(){return this._tilingScheme}},ready:{get:function(){return!0}},readyPromise:{get:function(){return this._readyPromise}},hasWaterMask:{get:function(){return!1}},hasVertexNormals:{get:function(){return!1}},availability:{get:function(){}}}),l.prototype.requestTileGeometry=function(t,e,a,i){const n=16,o=16;return Promise.resolve(new c["a"]({buffer:new Uint8Array(n*o),width:n,height:o}))},l.prototype.getLevelMaximumGeometricError=function(t){return this._levelZeroMaximumGeometricError/(1<<t)},l.prototype.getTileDataAvailable=function(t,e,a){},l.prototype.loadTileDataAvailability=function(t,e,a){},e["a"]=l},"4f04":function(t,e,a){"use strict";var i=a("2f63");function n(t){let e;this.name="DeveloperError",this.message=t;try{throw new Error}catch(a){e=a.stack}this.stack=e}Object(i["a"])(Object.create)&&(n.prototype=Object.create(Error.prototype),n.prototype.constructor=n),n.prototype.toString=function(){let t=`${this.name}: ${this.message}`;return Object(i["a"])(this.stack)&&(t+="\n"+this.stack.toString()),t},n.throwInstantiationError=function(){throw new n("This function defines an interface and should not be called directly.")},e["a"]=n},"55f9":function(t,e,a){"use strict";var i=a("3911"),n=a.n(i);const o={LINEAR_NONE:n.a.Easing.Linear.None,QUADRATIC_IN:n.a.Easing.Quadratic.In,QUADRATIC_OUT:n.a.Easing.Quadratic.Out,QUADRATIC_IN_OUT:n.a.Easing.Quadratic.InOut,CUBIC_IN:n.a.Easing.Cubic.In,CUBIC_OUT:n.a.Easing.Cubic.Out,CUBIC_IN_OUT:n.a.Easing.Cubic.InOut,QUARTIC_IN:n.a.Easing.Quartic.In,QUARTIC_OUT:n.a.Easing.Quartic.Out,QUARTIC_IN_OUT:n.a.Easing.Quartic.InOut,QUINTIC_IN:n.a.Easing.Quintic.In,QUINTIC_OUT:n.a.Easing.Quintic.Out,QUINTIC_IN_OUT:n.a.Easing.Quintic.InOut,SINUSOIDAL_IN:n.a.Easing.Sinusoidal.In,SINUSOIDAL_OUT:n.a.Easing.Sinusoidal.Out,SINUSOIDAL_IN_OUT:n.a.Easing.Sinusoidal.InOut,EXPONENTIAL_IN:n.a.Easing.Exponential.In,EXPONENTIAL_OUT:n.a.Easing.Exponential.Out,EXPONENTIAL_IN_OUT:n.a.Easing.Exponential.InOut,CIRCULAR_IN:n.a.Easing.Circular.In,CIRCULAR_OUT:n.a.Easing.Circular.Out,CIRCULAR_IN_OUT:n.a.Easing.Circular.InOut,ELASTIC_IN:n.a.Easing.Elastic.In,ELASTIC_OUT:n.a.Easing.Elastic.Out,ELASTIC_IN_OUT:n.a.Easing.Elastic.InOut,BACK_IN:n.a.Easing.Back.In,BACK_OUT:n.a.Easing.Back.Out,BACK_IN_OUT:n.a.Easing.Back.InOut,BOUNCE_IN:n.a.Easing.Bounce.In,BOUNCE_OUT:n.a.Easing.Bounce.Out,BOUNCE_IN_OUT:n.a.Easing.Bounce.InOut};e["a"]=Object.freeze(o)},5752:function(t,e,a){"use strict";function i(t,e,a,i,n){this.xPoleWander=t,this.yPoleWander=e,this.xPoleOffset=a,this.yPoleOffset=i,this.ut1MinusUtc=n}e["a"]=i},"6cae":function(t,e,a){"use strict";var i=a("cef5"),n=a("670c"),o=a("be18"),r=a("abab"),s=a("535a"),c=a("2f63"),u=a("c52f"),l=a("d2c7"),d=a("81d7"),h=a("473c"),m=a("0276"),f=a("0123"),_=a("93da"),p=a("1b8d"),g=a("0541");const O=new o["a"],y=new o["a"],b=new o["a"],x=new o["a"],P=new o["a"],A=new o["a"](1,1,1),w=Math.cos,M=Math.sin;function E(t){t=Object(s["a"])(t,s["a"].EMPTY_OBJECT);const e=Object(s["a"])(t.radii,A),a=Object(s["a"])(t.innerRadii,e),i=Object(s["a"])(t.minimumClock,0),n=Object(s["a"])(t.maximumClock,_["a"].TWO_PI),r=Object(s["a"])(t.minimumCone,0),c=Object(s["a"])(t.maximumCone,_["a"].PI),u=Math.round(Object(s["a"])(t.stackPartitions,64)),l=Math.round(Object(s["a"])(t.slicePartitions,64)),d=Object(s["a"])(t.vertexFormat,g["a"].DEFAULT);this._radii=o["a"].clone(e),this._innerRadii=o["a"].clone(a),this._minimumClock=i,this._maximumClock=n,this._minimumCone=r,this._maximumCone=c,this._stackPartitions=u,this._slicePartitions=l,this._vertexFormat=g["a"].clone(d),this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidGeometry"}E.packedLength=2*o["a"].packedLength+g["a"].packedLength+7,E.pack=function(t,e,a){return a=Object(s["a"])(a,0),o["a"].pack(t._radii,e,a),a+=o["a"].packedLength,o["a"].pack(t._innerRadii,e,a),a+=o["a"].packedLength,g["a"].pack(t._vertexFormat,e,a),a+=g["a"].packedLength,e[a++]=t._minimumClock,e[a++]=t._maximumClock,e[a++]=t._minimumCone,e[a++]=t._maximumCone,e[a++]=t._stackPartitions,e[a++]=t._slicePartitions,e[a]=Object(s["a"])(t._offsetAttribute,-1),e};const S=new o["a"],v=new o["a"],T=new g["a"],I={radii:S,innerRadii:v,vertexFormat:T,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,offsetAttribute:void 0};let j;E.unpack=function(t,e,a){e=Object(s["a"])(e,0);const i=o["a"].unpack(t,e,S);e+=o["a"].packedLength;const n=o["a"].unpack(t,e,v);e+=o["a"].packedLength;const r=g["a"].unpack(t,e,T);e+=g["a"].packedLength;const u=t[e++],l=t[e++],d=t[e++],h=t[e++],m=t[e++],f=t[e++],_=t[e];return Object(c["a"])(a)?(a._radii=o["a"].clone(i,a._radii),a._innerRadii=o["a"].clone(n,a._innerRadii),a._vertexFormat=g["a"].clone(r,a._vertexFormat),a._minimumClock=u,a._maximumClock=l,a._minimumCone=d,a._maximumCone=h,a._stackPartitions=m,a._slicePartitions=f,a._offsetAttribute=-1===_?void 0:_,a):(I.minimumClock=u,I.maximumClock=l,I.minimumCone=d,I.maximumCone=h,I.stackPartitions=m,I.slicePartitions=f,I.offsetAttribute=-1===_?void 0:_,new E(I))},E.createGeometry=function(t){const e=t._radii;if(e.x<=0||e.y<=0||e.z<=0)return;const a=t._innerRadii;if(a.x<=0||a.y<=0||a.z<=0)return;const s=t._minimumClock,g=t._maximumClock,A=t._minimumCone,E=t._maximumCone,S=t._vertexFormat;let v,T,I=t._slicePartitions+1,j=t._stackPartitions+1;I=Math.round(I*Math.abs(g-s)/_["a"].TWO_PI),j=Math.round(j*Math.abs(E-A)/_["a"].PI),I<2&&(I=2),j<2&&(j=2);let C=0;const N=[A],R=[s];for(v=0;v<j;v++)N.push(A+v*(E-A)/(j-1));for(N.push(E),T=0;T<I;T++)R.push(s+T*(g-s)/(I-1));R.push(g);const L=N.length,k=R.length;let U=0,z=1;const q=a.x!==e.x||a.y!==e.y||a.z!==e.z;let D=!1,F=!1,W=!1;q&&(z=2,A>0&&(D=!0,U+=I-1),E<Math.PI&&(F=!0,U+=I-1),(g-s)%_["a"].TWO_PI?(W=!0,U+=2*(j-1)+1):U+=1);const V=k*L*z,B=new Float64Array(3*V),G=new Array(V).fill(!1),H=new Array(V).fill(!1),Y=I*j*z,Q=6*(Y+U+1-(I+j)*z),Z=f["a"].createTypedArray(Y,Q),J=S.normal?new Float32Array(3*V):void 0,X=S.tangent?new Float32Array(3*V):void 0,K=S.bitangent?new Float32Array(3*V):void 0,$=S.st?new Float32Array(2*V):void 0,tt=new Array(L),et=new Array(L);for(v=0;v<L;v++)tt[v]=M(N[v]),et[v]=w(N[v]);const at=new Array(k),it=new Array(k);for(T=0;T<k;T++)it[T]=w(R[T]),at[T]=M(R[T]);for(v=0;v<L;v++)for(T=0;T<k;T++)B[C++]=e.x*tt[v]*it[T],B[C++]=e.y*tt[v]*at[T],B[C++]=e.z*et[v];let nt,ot,rt,st,ct=V/2;if(q)for(v=0;v<L;v++)for(T=0;T<k;T++)B[C++]=a.x*tt[v]*it[T],B[C++]=a.y*tt[v]*at[T],B[C++]=a.z*et[v],G[ct]=!0,v>0&&v!==L-1&&0!==T&&T!==k-1&&(H[ct]=!0),ct++;for(C=0,v=1;v<L-2;v++)for(nt=v*k,ot=(v+1)*k,T=1;T<k-2;T++)Z[C++]=ot+T,Z[C++]=ot+T+1,Z[C++]=nt+T+1,Z[C++]=ot+T,Z[C++]=nt+T+1,Z[C++]=nt+T;if(q){const t=L*k;for(v=1;v<L-2;v++)for(nt=t+v*k,ot=t+(v+1)*k,T=1;T<k-2;T++)Z[C++]=ot+T,Z[C++]=nt+T,Z[C++]=nt+T+1,Z[C++]=ot+T,Z[C++]=nt+T+1,Z[C++]=ot+T+1}if(q){if(D)for(st=L*k,v=1;v<k-2;v++)Z[C++]=v,Z[C++]=v+1,Z[C++]=st+v+1,Z[C++]=v,Z[C++]=st+v+1,Z[C++]=st+v;if(F)for(rt=L*k-k,st=L*k*z-k,v=1;v<k-2;v++)Z[C++]=rt+v+1,Z[C++]=rt+v,Z[C++]=st+v,Z[C++]=rt+v+1,Z[C++]=st+v,Z[C++]=st+v+1}if(W){for(v=1;v<L-2;v++)st=k*L+k*v,rt=k*v,Z[C++]=st,Z[C++]=rt+k,Z[C++]=rt,Z[C++]=st,Z[C++]=st+k,Z[C++]=rt+k;for(v=1;v<L-2;v++)st=k*L+k*(v+1)-1,rt=k*(v+1)-1,Z[C++]=rt+k,Z[C++]=st,Z[C++]=rt,Z[C++]=rt+k,Z[C++]=st+k,Z[C++]=st}const ut=new h["a"];S.position&&(ut.position=new d["a"]({componentDatatype:r["a"].DOUBLE,componentsPerAttribute:3,values:B}));let lt=0,dt=0,ht=0,mt=0;const ft=V/2;let _t;const pt=u["a"].fromCartesian3(e),gt=u["a"].fromCartesian3(a);if(S.st||S.normal||S.tangent||S.bitangent){for(v=0;v<V;v++){_t=G[v]?gt:pt;const t=o["a"].fromArray(B,3*v,O),e=_t.geodeticSurfaceNormal(t,y);if(H[v]&&o["a"].negate(e,e),S.st){const t=n["a"].negate(e,P);$[lt++]=Math.atan2(t.y,t.x)/_["a"].TWO_PI+.5,$[lt++]=Math.asin(e.z)/Math.PI+.5}if(S.normal&&(J[dt++]=e.x,J[dt++]=e.y,J[dt++]=e.z),S.tangent||S.bitangent){const t=b;let a,i=0;if(G[v]&&(i=ft),a=!D&&v>=i&&v<i+2*k?o["a"].UNIT_X:o["a"].UNIT_Z,o["a"].cross(a,e,t),o["a"].normalize(t,t),S.tangent&&(X[ht++]=t.x,X[ht++]=t.y,X[ht++]=t.z),S.bitangent){const a=o["a"].cross(e,t,x);o["a"].normalize(a,a),K[mt++]=a.x,K[mt++]=a.y,K[mt++]=a.z}}}S.st&&(ut.st=new d["a"]({componentDatatype:r["a"].FLOAT,componentsPerAttribute:2,values:$})),S.normal&&(ut.normal=new d["a"]({componentDatatype:r["a"].FLOAT,componentsPerAttribute:3,values:J})),S.tangent&&(ut.tangent=new d["a"]({componentDatatype:r["a"].FLOAT,componentsPerAttribute:3,values:X})),S.bitangent&&(ut.bitangent=new d["a"]({componentDatatype:r["a"].FLOAT,componentsPerAttribute:3,values:K}))}if(Object(c["a"])(t._offsetAttribute)){const e=B.length,a=t._offsetAttribute===m["a"].NONE?0:1,i=new Uint8Array(e/3).fill(a);ut.applyOffset=new d["a"]({componentDatatype:r["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}return new l["a"]({attributes:ut,indices:Z,primitiveType:p["a"].TRIANGLES,boundingSphere:i["a"].fromEllipsoid(pt),offsetAttribute:t._offsetAttribute})},E.getUnitEllipsoid=function(){return Object(c["a"])(j)||(j=E.createGeometry(new E({radii:new o["a"](1,1,1),vertexFormat:g["a"].POSITION_ONLY}))),j},e["a"]=E},"6cbd":function(t,e,a){"use strict";var i=a("be18"),n=a("2f63");function o(){this.high=i["a"].clone(i["a"].ZERO),this.low=i["a"].clone(i["a"].ZERO)}o.encode=function(t,e){let a;return Object(n["a"])(e)||(e={high:0,low:0}),t>=0?(a=65536*Math.floor(t/65536),e.high=a,e.low=t-a):(a=65536*Math.floor(-t/65536),e.high=-a,e.low=t+a),e};const r={high:0,low:0};o.fromCartesian=function(t,e){Object(n["a"])(e)||(e=new o);const a=e.high,i=e.low;return o.encode(t.x,r),a.x=r.high,i.x=r.low,o.encode(t.y,r),a.y=r.high,i.y=r.low,o.encode(t.z,r),a.z=r.high,i.z=r.low,e};const s=new o;o.writeElements=function(t,e,a){o.fromCartesian(t,s);const i=s.high,n=s.low;e[a]=i.x,e[a+1]=i.y,e[a+2]=i.z,e[a+3]=n.x,e[a+4]=n.y,e[a+5]=n.z},e["a"]=o},7261:function(t,e,a){"use strict";var i=a("e438"),n=a("535a"),o=a("2f63"),r=a("5752"),s=a("5ed2"),c=a("a4d9"),u=a("d4ed"),l=a("283e"),d=a("dd17"),h=a("2b8c");function m(t){if(t=Object(n["a"])(t,n["a"].EMPTY_OBJECT),this._dates=void 0,this._samples=void 0,this._dateColumn=-1,this._xPoleWanderRadiansColumn=-1,this._yPoleWanderRadiansColumn=-1,this._ut1MinusUtcSecondsColumn=-1,this._xCelestialPoleOffsetRadiansColumn=-1,this._yCelestialPoleOffsetRadiansColumn=-1,this._taiMinusUtcSecondsColumn=-1,this._columnCount=0,this._lastIndex=-1,this._downloadPromise=void 0,this._dataError=void 0,this._addNewLeapSeconds=Object(n["a"])(t.addNewLeapSeconds,!0),Object(o["a"])(t.data))_(this,t.data);else if(Object(o["a"])(t.url)){const e=u["a"].createIfNeeded(t.url),a=this;this._downloadPromise=e.fetchJson().then((function(t){_(a,t)})).catch((function(){a._dataError=`An error occurred while retrieving the EOP data from the URL ${e.url}.`}))}else _(this,{columnNames:["dateIso8601","modifiedJulianDateUtc","xPoleWanderRadians","yPoleWanderRadians","ut1MinusUtcSeconds","lengthOfDayCorrectionSeconds","xCelestialPoleOffsetRadians","yCelestialPoleOffsetRadians","taiMinusUtcSeconds"],samples:[]})}function f(t,e){return s["a"].compare(t.julianDate,e)}function _(t,e){if(!Object(o["a"])(e.columnNames))return void(t._dataError="Error in loaded EOP data: The columnNames property is required.");if(!Object(o["a"])(e.samples))return void(t._dataError="Error in loaded EOP data: The samples property is required.");const a=e.columnNames.indexOf("modifiedJulianDateUtc"),n=e.columnNames.indexOf("xPoleWanderRadians"),r=e.columnNames.indexOf("yPoleWanderRadians"),u=e.columnNames.indexOf("ut1MinusUtcSeconds"),l=e.columnNames.indexOf("xCelestialPoleOffsetRadians"),m=e.columnNames.indexOf("yCelestialPoleOffsetRadians"),_=e.columnNames.indexOf("taiMinusUtcSeconds");if(a<0||n<0||r<0||u<0||l<0||m<0||_<0)return void(t._dataError="Error in loaded EOP data: The columnNames property must include modifiedJulianDateUtc, xPoleWanderRadians, yPoleWanderRadians, ut1MinusUtcSeconds, xCelestialPoleOffsetRadians, yCelestialPoleOffsetRadians, and taiMinusUtcSeconds columns");const p=t._samples=e.samples,g=t._dates=[];let O;t._dateColumn=a,t._xPoleWanderRadiansColumn=n,t._yPoleWanderRadiansColumn=r,t._ut1MinusUtcSecondsColumn=u,t._xCelestialPoleOffsetRadiansColumn=l,t._yCelestialPoleOffsetRadiansColumn=m,t._taiMinusUtcSecondsColumn=_,t._columnCount=e.columnNames.length,t._lastIndex=void 0;const y=t._addNewLeapSeconds;for(let b=0,x=p.length;b<x;b+=t._columnCount){const t=p[b+a],e=p[b+_],n=t+d["a"].MODIFIED_JULIAN_DATE_DIFFERENCE,r=new s["a"](n,e,h["a"].TAI);if(g.push(r),y){if(e!==O&&Object(o["a"])(O)){const t=s["a"].leapSeconds,a=Object(i["a"])(t,r,f);if(a<0){const i=new c["a"](r,e);t.splice(~a,0,i)}}O=e}}}function p(t,e,a,i,n){const o=a*i;n.xPoleWander=e[o+t._xPoleWanderRadiansColumn],n.yPoleWander=e[o+t._yPoleWanderRadiansColumn],n.xPoleOffset=e[o+t._xCelestialPoleOffsetRadiansColumn],n.yPoleOffset=e[o+t._yCelestialPoleOffsetRadiansColumn],n.ut1MinusUtc=e[o+t._ut1MinusUtcSecondsColumn]}function g(t,e,a){return e+t*(a-e)}function O(t,e,a,i,n,o,r){const c=t._columnCount;if(o>e.length-1)return r.xPoleWander=0,r.yPoleWander=0,r.xPoleOffset=0,r.yPoleOffset=0,r.ut1MinusUtc=0,r;const u=e[n],l=e[o];if(u.equals(l)||i.equals(u))return p(t,a,n,c,r),r;if(i.equals(l))return p(t,a,o,c,r),r;const d=s["a"].secondsDifference(i,u)/s["a"].secondsDifference(l,u),h=n*c,m=o*c;let f=a[h+t._ut1MinusUtcSecondsColumn],_=a[m+t._ut1MinusUtcSecondsColumn];const O=_-f;if(O>.5||O<-.5){const e=a[h+t._taiMinusUtcSecondsColumn],n=a[m+t._taiMinusUtcSecondsColumn];e!==n&&(l.equals(i)?f=_:_-=n-e)}return r.xPoleWander=g(d,a[h+t._xPoleWanderRadiansColumn],a[m+t._xPoleWanderRadiansColumn]),r.yPoleWander=g(d,a[h+t._yPoleWanderRadiansColumn],a[m+t._yPoleWanderRadiansColumn]),r.xPoleOffset=g(d,a[h+t._xCelestialPoleOffsetRadiansColumn],a[m+t._xCelestialPoleOffsetRadiansColumn]),r.yPoleOffset=g(d,a[h+t._yCelestialPoleOffsetRadiansColumn],a[m+t._yCelestialPoleOffsetRadiansColumn]),r.ut1MinusUtc=g(d,f,_),r}m.NONE=Object.freeze({getPromiseToLoad:function(){return Promise.resolve()},compute:function(t,e){return Object(o["a"])(e)?(e.xPoleWander=0,e.yPoleWander=0,e.xPoleOffset=0,e.yPoleOffset=0,e.ut1MinusUtc=0):e=new r["a"](0,0,0,0,0),e}}),m.prototype.getPromiseToLoad=function(){return Promise.resolve(this._downloadPromise)},m.prototype.compute=function(t,e){if(!Object(o["a"])(this._samples)){if(Object(o["a"])(this._dataError))throw new l["a"](this._dataError);return}if(Object(o["a"])(e)||(e=new r["a"](0,0,0,0,0)),0===this._samples.length)return e.xPoleWander=0,e.yPoleWander=0,e.xPoleOffset=0,e.yPoleOffset=0,e.ut1MinusUtc=0,e;const a=this._dates,n=this._lastIndex;let c=0,u=0;if(Object(o["a"])(n)){const i=a[n],r=a[n+1],l=s["a"].lessThanOrEquals(i,t),d=!Object(o["a"])(r),h=d||s["a"].greaterThanOrEquals(r,t);if(l&&h)return c=n,!d&&r.equals(t)&&++c,u=c+1,O(this,a,this._samples,t,c,u,e),e}let d=Object(i["a"])(a,t,s["a"].compare,this._dateColumn);return d>=0?(d<a.length-1&&a[d+1].equals(t)&&++d,c=d,u=d):(u=~d,c=u-1,c<0&&(c=0)),this._lastIndex=c,O(this,a,this._samples,t,c,u,e),e},e["a"]=m},"77bc":function(t,e,a){"use strict";var i=a("abab"),n=a("535a"),o=a("2f63");function r(t,e){t=Object(n["a"])(t,0),e=Object(n["a"])(e,Number.MAX_VALUE),this.value=new Float32Array([t,e])}Object.defineProperties(r.prototype,{componentDatatype:{get:function(){return i["a"].FLOAT}},componentsPerAttribute:{get:function(){return 2}},normalize:{get:function(){return!1}}}),r.fromDistanceDisplayCondition=function(t){return new r(t.near,t.far)},r.toValue=function(t,e){return Object(o["a"])(e)?(e[0]=t.near,e[1]=t.far,e):new Float32Array([t.near,t.far])},e["a"]=r},"82d9":function(t,e,a){"use strict";var i=a("cef5"),n=a("be18"),o=a("535a"),r=a("2f63"),s=a("c52f"),c=a("eace");function u(t,e){this._ellipsoid=t,this._cameraPosition=new n["a"],this._cameraPositionInScaledSpace=new n["a"],this._distanceToLimbInScaledSpaceSquared=0,Object(r["a"])(e)&&(this.cameraPosition=e)}Object.defineProperties(u.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},cameraPosition:{get:function(){return this._cameraPosition},set:function(t){const e=this._ellipsoid,a=e.transformPositionToScaledSpace(t,this._cameraPositionInScaledSpace),i=n["a"].magnitudeSquared(a)-1;n["a"].clone(t,this._cameraPosition),this._cameraPositionInScaledSpace=a,this._distanceToLimbInScaledSpaceSquared=i}}});const l=new n["a"];u.prototype.isPointVisible=function(t){const e=this._ellipsoid,a=e.transformPositionToScaledSpace(t,l);return y(a,this._cameraPositionInScaledSpace,this._distanceToLimbInScaledSpaceSquared)},u.prototype.isScaledSpacePointVisible=function(t){return y(t,this._cameraPositionInScaledSpace,this._distanceToLimbInScaledSpaceSquared)};const d=new n["a"];u.prototype.isScaledSpacePointVisiblePossiblyUnderEllipsoid=function(t,e){const a=this._ellipsoid;let i,n;return Object(r["a"])(e)&&e<0&&a.minimumRadius>-e?(n=d,n.x=this._cameraPosition.x/(a.radii.x+e),n.y=this._cameraPosition.y/(a.radii.y+e),n.z=this._cameraPosition.z/(a.radii.z+e),i=n.x*n.x+n.y*n.y+n.z*n.z-1):(n=this._cameraPositionInScaledSpace,i=this._distanceToLimbInScaledSpaceSquared),y(t,n,i)},u.prototype.computeHorizonCullingPoint=function(t,e,a){return p(this._ellipsoid,t,e,a)};const h=s["a"].clone(s["a"].UNIT_SPHERE);u.prototype.computeHorizonCullingPointPossiblyUnderEllipsoid=function(t,e,a,i){const n=_(this._ellipsoid,a,h);return p(n,t,e,i)},u.prototype.computeHorizonCullingPointFromVertices=function(t,e,a,i,n){return O(this._ellipsoid,t,e,a,i,n)},u.prototype.computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid=function(t,e,a,i,n,o){const r=_(this._ellipsoid,n,h);return O(r,t,e,a,i,o)};const m=[];u.prototype.computeHorizonCullingPointFromRectangle=function(t,e,a){const o=c["a"].subsample(t,e,0,m),r=i["a"].fromPoints(o);if(!(n["a"].magnitude(r.center)<.1*e.minimumRadius))return this.computeHorizonCullingPoint(r.center,o,a)};const f=new n["a"];function _(t,e,a){if(Object(r["a"])(e)&&e<0&&t.minimumRadius>-e){const i=n["a"].fromElements(t.radii.x+e,t.radii.y+e,t.radii.z+e,f);t=s["a"].fromCartesian3(i,a)}return t}function p(t,e,a,i){Object(r["a"])(i)||(i=new n["a"]);const o=M(t,e);let s=0;for(let n=0,r=a.length;n<r;++n){const e=a[n],i=P(t,e,o);if(i<0)return;s=Math.max(s,i)}return A(o,s,i)}const g=new n["a"];function O(t,e,a,i,s,c){Object(r["a"])(c)||(c=new n["a"]),i=Object(o["a"])(i,3),s=Object(o["a"])(s,n["a"].ZERO);const u=M(t,e);let l=0;for(let n=0,o=a.length;n<o;n+=i){g.x=a[n]+s.x,g.y=a[n+1]+s.y,g.z=a[n+2]+s.z;const e=P(t,g,u);if(e<0)return;l=Math.max(l,e)}return A(u,l,c)}function y(t,e,a){const i=e,o=a,r=n["a"].subtract(t,i,l),s=-n["a"].dot(r,i),c=o<0?s>0:s>o&&s*s/n["a"].magnitudeSquared(r)>o;return!c}const b=new n["a"],x=new n["a"];function P(t,e,a){const i=t.transformPositionToScaledSpace(e,b);let o=n["a"].magnitudeSquared(i),r=Math.sqrt(o);const s=n["a"].divideByScalar(i,r,x);o=Math.max(1,o),r=Math.max(1,r);const c=n["a"].dot(s,a),u=n["a"].magnitude(n["a"].cross(s,a,s)),l=1/r,d=Math.sqrt(o-1)*l;return 1/(c*l-u*d)}function A(t,e,a){if(!(e<=0||e===1/0||e!==e))return n["a"].multiplyByScalar(t,e,a)}const w=new n["a"];function M(t,e){return n["a"].equals(e,n["a"].ZERO)?e:(t.transformPositionToScaledSpace(e,w),n["a"].normalize(w,w))}e["a"]=u},"8f14":function(t,e,a){"use strict";var i=a("2f63");function n(){this.head=void 0,this.tail=void 0,this._length=0}function o(t,e,a){this.item=t,this.previous=e,this.next=a}function r(t,e){Object(i["a"])(e.previous)&&Object(i["a"])(e.next)?(e.previous.next=e.next,e.next.previous=e.previous):Object(i["a"])(e.previous)?(e.previous.next=void 0,t.tail=e.previous):Object(i["a"])(e.next)?(e.next.previous=void 0,t.head=e.next):(t.head=void 0,t.tail=void 0),e.next=void 0,e.previous=void 0}Object.defineProperties(n.prototype,{length:{get:function(){return this._length}}}),n.prototype.add=function(t){const e=new o(t,this.tail,void 0);return Object(i["a"])(this.tail)?(this.tail.next=e,this.tail=e):(this.head=e,this.tail=e),++this._length,e},n.prototype.remove=function(t){Object(i["a"])(t)&&(r(this,t),--this._length)},n.prototype.splice=function(t,e){if(t===e)return;r(this,e);const a=t.next;t.next=e,this.tail===t?this.tail=e:a.previous=e,e.next=a,e.previous=t},e["a"]=n},a3bd:function(t,e,a){"use strict";var i=a("7f9b"),n=a("670c"),o=a("be18"),r=a("a561"),s=a("535a"),c=a("2f63"),u=a("c52f"),l=a("5410"),d=a("52f0"),h=a("188e"),m=a("2ac3"),f=a("f806");const _=new r["a"];function p(t,e){e=Object(s["a"])(e,u["a"].WGS84),t=e.scaleToGeodeticSurface(t);const a=f["a"].eastNorthUpToFixedFrame(t,e);this._ellipsoid=e,this._origin=t,this._xAxis=o["a"].fromCartesian4(d["a"].getColumn(a,0,_)),this._yAxis=o["a"].fromCartesian4(d["a"].getColumn(a,1,_));const i=o["a"].fromCartesian4(d["a"].getColumn(a,2,_));this._plane=h["a"].fromPointNormal(t,i)}Object.defineProperties(p.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},origin:{get:function(){return this._origin}},plane:{get:function(){return this._plane}},xAxis:{get:function(){return this._xAxis}},yAxis:{get:function(){return this._yAxis}},zAxis:{get:function(){return this._plane.normal}}});const g=new i["a"];p.fromPoints=function(t,e){const a=i["a"].fromPoints(t,g);return new p(a.center,e)};const O=new m["a"],y=new o["a"];p.prototype.projectPointOntoPlane=function(t,e){const a=O;a.origin=t,o["a"].normalize(t,a.direction);let i=l["a"].rayPlane(a,this._plane,y);if(Object(c["a"])(i)||(o["a"].negate(a.direction,a.direction),i=l["a"].rayPlane(a,this._plane,y)),Object(c["a"])(i)){const t=o["a"].subtract(i,this._origin,i),a=o["a"].dot(this._xAxis,t),r=o["a"].dot(this._yAxis,t);return Object(c["a"])(e)?(e.x=a,e.y=r,e):new n["a"](a,r)}},p.prototype.projectPointsOntoPlane=function(t,e){Object(c["a"])(e)||(e=[]);let a=0;const i=t.length;for(let n=0;n<i;n++){const i=this.projectPointOntoPlane(t[n],e[a]);Object(c["a"])(i)&&(e[a]=i,a++)}return e.length=a,e},p.prototype.projectPointToNearestOnPlane=function(t,e){Object(c["a"])(e)||(e=new n["a"]);const a=O;a.origin=t,o["a"].clone(this._plane.normal,a.direction);let i=l["a"].rayPlane(a,this._plane,y);Object(c["a"])(i)||(o["a"].negate(a.direction,a.direction),i=l["a"].rayPlane(a,this._plane,y));const r=o["a"].subtract(i,this._origin,i),s=o["a"].dot(this._xAxis,r),u=o["a"].dot(this._yAxis,r);return e.x=s,e.y=u,e},p.prototype.projectPointsToNearestOnPlane=function(t,e){Object(c["a"])(e)||(e=[]);const a=t.length;e.length=a;for(let i=0;i<a;i++)e[i]=this.projectPointToNearestOnPlane(t[i],e[i]);return e};const b=new o["a"];p.prototype.projectPointOntoEllipsoid=function(t,e){Object(c["a"])(e)||(e=new o["a"]);const a=this._ellipsoid,i=this._origin,n=this._xAxis,r=this._yAxis,s=b;return o["a"].multiplyByScalar(n,t.x,s),e=o["a"].add(i,s,e),o["a"].multiplyByScalar(r,t.y,s),o["a"].add(e,s,e),a.scaleToGeocentricSurface(e,e),e},p.prototype.projectPointsOntoEllipsoid=function(t,e){const a=t.length;Object(c["a"])(e)?e.length=a:e=new Array(a);for(let i=0;i<a;++i)e[i]=this.projectPointOntoEllipsoid(t[i],e[i]);return e},e["a"]=p},a6ac:function(t,e,a){"use strict";var i=a("cef5"),n=a("670c"),o=a("be18"),r=a("bef8"),s=a("abab"),c=a("535a"),u=a("2f63"),l=a("cfdc"),d=a("c52f"),h=a("3d7f"),m=a("d2c7"),f=a("81d7"),_=a("473c"),p=a("d940"),g=a("0276"),O=a("c1e2"),y=a("0123"),b=a("93da"),x=a("df07"),P=a("1b8d"),A=a("0260"),w=a("eace"),M=a("0541");const E=new o["a"],S=new o["a"],v=new o["a"],T=new o["a"],I=new n["a"],j=new x["a"],C=new x["a"],N=new A["a"],R=new o["a"],L=new o["a"],k=new o["a"],U=new r["a"],z=new o["a"],q=new n["a"],D=new n["a"];function F(t,e,a){const i=e.vertexFormat,r=e.center,c=e.semiMajorAxis,d=e.semiMinorAxis,m=e.ellipsoid,p=e.stRotation,O=a?t.length/3*2:t.length/3,y=e.shadowVolume,b=i.st?new Float32Array(2*O):void 0,P=i.normal?new Float32Array(3*O):void 0,w=i.tangent?new Float32Array(3*O):void 0,M=i.bitangent?new Float32Array(3*O):void 0,T=y?new Float32Array(3*O):void 0;let F=0,W=R,V=L,B=k;const G=new h["a"](m),H=G.project(m.cartesianToCartographic(r,U),z),Y=m.scaleToGeodeticSurface(r,E);m.geodeticSurfaceNormal(Y,Y);let Q=j,Z=C;if(0!==p){let t=A["a"].fromAxisAngle(Y,p,N);Q=x["a"].fromQuaternion(t,Q),t=A["a"].fromAxisAngle(Y,-p,N),Z=x["a"].fromQuaternion(t,Z)}else Q=x["a"].clone(x["a"].IDENTITY,Q),Z=x["a"].clone(x["a"].IDENTITY,Z);const J=n["a"].fromElements(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,q),X=n["a"].fromElements(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,D);let K=t.length;const $=a?K:0,tt=$/3*2;for(let n=0;n<K;n+=3){const e=n+1,r=n+2,s=o["a"].fromArray(t,n,E);if(i.st){const t=x["a"].multiplyByVector(Q,s,S),e=G.project(m.cartesianToCartographic(t,U),v);o["a"].subtract(e,H,e),I.x=(e.x+c)/(2*c),I.y=(e.y+d)/(2*d),J.x=Math.min(I.x,J.x),J.y=Math.min(I.y,J.y),X.x=Math.max(I.x,X.x),X.y=Math.max(I.y,X.y),a&&(b[F+tt]=I.x,b[F+1+tt]=I.y),b[F++]=I.x,b[F++]=I.y}(i.normal||i.tangent||i.bitangent||y)&&(W=m.geodeticSurfaceNormal(s,W),y&&(T[n+$]=-W.x,T[e+$]=-W.y,T[r+$]=-W.z),(i.normal||i.tangent||i.bitangent)&&((i.tangent||i.bitangent)&&(V=o["a"].normalize(o["a"].cross(o["a"].UNIT_Z,W,V),V),x["a"].multiplyByVector(Z,V,V)),i.normal&&(P[n]=W.x,P[e]=W.y,P[r]=W.z,a&&(P[n+$]=-W.x,P[e+$]=-W.y,P[r+$]=-W.z)),i.tangent&&(w[n]=V.x,w[e]=V.y,w[r]=V.z,a&&(w[n+$]=-V.x,w[e+$]=-V.y,w[r+$]=-V.z)),i.bitangent&&(B=o["a"].normalize(o["a"].cross(W,V,B),B),M[n]=B.x,M[e]=B.y,M[r]=B.z,a&&(M[n+$]=B.x,M[e+$]=B.y,M[r+$]=B.z))))}if(i.st){K=b.length;for(let t=0;t<K;t+=2)b[t]=(b[t]-J.x)/(X.x-J.x),b[t+1]=(b[t+1]-J.y)/(X.y-J.y)}const et=new _["a"];if(i.position){const i=l["a"].raisePositionsToHeight(t,e,a);et.position=new f["a"]({componentDatatype:s["a"].DOUBLE,componentsPerAttribute:3,values:i})}if(i.st&&(et.st=new f["a"]({componentDatatype:s["a"].FLOAT,componentsPerAttribute:2,values:b})),i.normal&&(et.normal=new f["a"]({componentDatatype:s["a"].FLOAT,componentsPerAttribute:3,values:P})),i.tangent&&(et.tangent=new f["a"]({componentDatatype:s["a"].FLOAT,componentsPerAttribute:3,values:w})),i.bitangent&&(et.bitangent=new f["a"]({componentDatatype:s["a"].FLOAT,componentsPerAttribute:3,values:M})),y&&(et.extrudeDirection=new f["a"]({componentDatatype:s["a"].FLOAT,componentsPerAttribute:3,values:T})),a&&Object(u["a"])(e.offsetAttribute)){let t=new Uint8Array(O);if(e.offsetAttribute===g["a"].TOP)t=t.fill(1,0,O/2);else{const a=e.offsetAttribute===g["a"].NONE?0:1;t=t.fill(a)}et.applyOffset=new f["a"]({componentDatatype:s["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}return et}function W(t){const e=new Array(t*(t+1)*12-6);let a,i,n,o,r,s=0;for(a=0,n=1,o=0;o<3;o++)e[s++]=n++,e[s++]=a,e[s++]=n;for(o=2;o<t+1;++o){for(n=o*(o+1)-1,a=(o-1)*o-1,e[s++]=n++,e[s++]=a,e[s++]=n,i=2*o,r=0;r<i-1;++r)e[s++]=n,e[s++]=a++,e[s++]=a,e[s++]=n++,e[s++]=a,e[s++]=n;e[s++]=n++,e[s++]=a,e[s++]=n}for(i=2*t,++n,++a,o=0;o<i-1;++o)e[s++]=n,e[s++]=a++,e[s++]=a,e[s++]=n++,e[s++]=a,e[s++]=n;for(e[s++]=n,e[s++]=a++,e[s++]=a,e[s++]=n++,e[s++]=a++,e[s++]=a,++a,o=t-1;o>1;--o){for(e[s++]=a++,e[s++]=a,e[s++]=n,i=2*o,r=0;r<i-1;++r)e[s++]=n,e[s++]=a++,e[s++]=a,e[s++]=n++,e[s++]=a,e[s++]=n;e[s++]=a++,e[s++]=a++,e[s++]=n++}for(o=0;o<3;o++)e[s++]=a++,e[s++]=a,e[s++]=n;return e}let V=new o["a"];function B(t){const e=t.center;V=o["a"].multiplyByScalar(t.ellipsoid.geodeticSurfaceNormal(e,V),t.height,V),V=o["a"].add(e,V,V);const a=new i["a"](V,t.semiMajorAxis),n=l["a"].computeEllipsePositions(t,!0,!1),r=n.positions,s=n.numPts,c=F(r,t,!1);let u=W(s);return u=y["a"].createTypedArray(r.length/3,u),{boundingSphere:a,attributes:c,indices:u}}function G(t,e){const a=e.vertexFormat,i=e.center,r=e.semiMajorAxis,c=e.semiMinorAxis,l=e.ellipsoid,d=e.height,m=e.extrudedHeight,p=e.stRotation,O=t.length/3*2,y=new Float64Array(3*O),b=a.st?new Float32Array(2*O):void 0,P=a.normal?new Float32Array(3*O):void 0,w=a.tangent?new Float32Array(3*O):void 0,M=a.bitangent?new Float32Array(3*O):void 0,C=e.shadowVolume,F=C?new Float32Array(3*O):void 0;let W=0,V=R,B=L,G=k;const H=new h["a"](l),Y=H.project(l.cartesianToCartographic(i,U),z),Q=l.scaleToGeodeticSurface(i,E);l.geodeticSurfaceNormal(Q,Q);const Z=A["a"].fromAxisAngle(Q,p,N),J=x["a"].fromQuaternion(Z,j),X=n["a"].fromElements(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,q),K=n["a"].fromElements(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,D);let $=t.length;const tt=$/3*2;for(let n=0;n<$;n+=3){const e=n+1,i=n+2;let s,u=o["a"].fromArray(t,n,E);if(a.st){const t=x["a"].multiplyByVector(J,u,S),e=H.project(l.cartesianToCartographic(t,U),v);o["a"].subtract(e,Y,e),I.x=(e.x+r)/(2*r),I.y=(e.y+c)/(2*c),X.x=Math.min(I.x,X.x),X.y=Math.min(I.y,X.y),K.x=Math.max(I.x,K.x),K.y=Math.max(I.y,K.y),b[W+tt]=I.x,b[W+1+tt]=I.y,b[W++]=I.x,b[W++]=I.y}u=l.scaleToGeodeticSurface(u,u),s=o["a"].clone(u,S),V=l.geodeticSurfaceNormal(u,V),C&&(F[n+$]=-V.x,F[e+$]=-V.y,F[i+$]=-V.z);let h=o["a"].multiplyByScalar(V,d,T);if(u=o["a"].add(u,h,u),h=o["a"].multiplyByScalar(V,m,h),s=o["a"].add(s,h,s),a.position&&(y[n+$]=s.x,y[e+$]=s.y,y[i+$]=s.z,y[n]=u.x,y[e]=u.y,y[i]=u.z),a.normal||a.tangent||a.bitangent){G=o["a"].clone(V,G);const r=o["a"].fromArray(t,(n+3)%$,T);o["a"].subtract(r,u,r);const c=o["a"].subtract(s,u,v);V=o["a"].normalize(o["a"].cross(c,r,V),V),a.normal&&(P[n]=V.x,P[e]=V.y,P[i]=V.z,P[n+$]=V.x,P[e+$]=V.y,P[i+$]=V.z),a.tangent&&(B=o["a"].normalize(o["a"].cross(G,V,B),B),w[n]=B.x,w[e]=B.y,w[i]=B.z,w[n+$]=B.x,w[n+1+$]=B.y,w[n+2+$]=B.z),a.bitangent&&(M[n]=G.x,M[e]=G.y,M[i]=G.z,M[n+$]=G.x,M[e+$]=G.y,M[i+$]=G.z)}}if(a.st){$=b.length;for(let t=0;t<$;t+=2)b[t]=(b[t]-X.x)/(K.x-X.x),b[t+1]=(b[t+1]-X.y)/(K.y-X.y)}const et=new _["a"];if(a.position&&(et.position=new f["a"]({componentDatatype:s["a"].DOUBLE,componentsPerAttribute:3,values:y})),a.st&&(et.st=new f["a"]({componentDatatype:s["a"].FLOAT,componentsPerAttribute:2,values:b})),a.normal&&(et.normal=new f["a"]({componentDatatype:s["a"].FLOAT,componentsPerAttribute:3,values:P})),a.tangent&&(et.tangent=new f["a"]({componentDatatype:s["a"].FLOAT,componentsPerAttribute:3,values:w})),a.bitangent&&(et.bitangent=new f["a"]({componentDatatype:s["a"].FLOAT,componentsPerAttribute:3,values:M})),C&&(et.extrudeDirection=new f["a"]({componentDatatype:s["a"].FLOAT,componentsPerAttribute:3,values:F})),Object(u["a"])(e.offsetAttribute)){let t=new Uint8Array(O);if(e.offsetAttribute===g["a"].TOP)t=t.fill(1,0,O/2);else{const a=e.offsetAttribute===g["a"].NONE?0:1;t=t.fill(a)}et.applyOffset=new f["a"]({componentDatatype:s["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}return et}function H(t){const e=t.length/3,a=y["a"].createTypedArray(e,6*e);let i=0;for(let n=0;n<e;n++){const t=n,o=n+e,r=(t+1)%e,s=r+e;a[i++]=t,a[i++]=o,a[i++]=r,a[i++]=r,a[i++]=o,a[i++]=s}return a}const Y=new i["a"],Q=new i["a"];function Z(t){const e=t.center,a=t.ellipsoid,n=t.semiMajorAxis;let r=o["a"].multiplyByScalar(a.geodeticSurfaceNormal(e,E),t.height,E);Y.center=o["a"].add(e,r,Y.center),Y.radius=n,r=o["a"].multiplyByScalar(a.geodeticSurfaceNormal(e,r),t.extrudedHeight,r),Q.center=o["a"].add(e,r,Q.center),Q.radius=n;const s=l["a"].computeEllipsePositions(t,!0,!0),c=s.positions,u=s.numPts,d=s.outerPositions,h=i["a"].union(Y,Q),f=F(c,t,!0);let _=W(u);const g=_.length;_.length=2*g;const b=c.length/3;for(let i=0;i<g;i+=3)_[i+g]=_[i+2]+b,_[i+1+g]=_[i+1]+b,_[i+2+g]=_[i]+b;const x=y["a"].createTypedArray(2*b/3,_),A=new m["a"]({attributes:f,indices:x,primitiveType:P["a"].TRIANGLES}),w=G(d,t);_=H(d);const M=y["a"].createTypedArray(2*d.length/3,_),S=new m["a"]({attributes:w,indices:M,primitiveType:P["a"].TRIANGLES}),v=O["a"].combineInstances([new p["a"]({geometry:A}),new p["a"]({geometry:S})]);return{boundingSphere:h,attributes:v[0].attributes,indices:v[0].indices}}function J(t,e,a,i,n,r,s){const c=l["a"].computeEllipsePositions({center:t,semiMajorAxis:e,semiMinorAxis:a,rotation:i,granularity:n},!1,!0),u=c.outerPositions,d=u.length/3,h=new Array(d);for(let l=0;l<d;++l)h[l]=o["a"].fromArray(u,3*l);const m=w["a"].fromCartesianArray(h,r,s);return m.width>b["a"].PI&&(m.north=m.north>0?b["a"].PI_OVER_TWO-b["a"].EPSILON7:m.north,m.south=m.south<0?b["a"].EPSILON7-b["a"].PI_OVER_TWO:m.south,m.east=b["a"].PI,m.west=-b["a"].PI),m}function X(t){t=Object(c["a"])(t,c["a"].EMPTY_OBJECT);const e=t.center,a=Object(c["a"])(t.ellipsoid,d["a"].WGS84),i=t.semiMajorAxis,n=t.semiMinorAxis,r=Object(c["a"])(t.granularity,b["a"].RADIANS_PER_DEGREE),s=Object(c["a"])(t.vertexFormat,M["a"].DEFAULT),u=Object(c["a"])(t.height,0),l=Object(c["a"])(t.extrudedHeight,u);this._center=o["a"].clone(e),this._semiMajorAxis=i,this._semiMinorAxis=n,this._ellipsoid=d["a"].clone(a),this._rotation=Object(c["a"])(t.rotation,0),this._stRotation=Object(c["a"])(t.stRotation,0),this._height=Math.max(l,u),this._granularity=r,this._vertexFormat=M["a"].clone(s),this._extrudedHeight=Math.min(l,u),this._shadowVolume=Object(c["a"])(t.shadowVolume,!1),this._workerName="createEllipseGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0}X.packedLength=o["a"].packedLength+d["a"].packedLength+M["a"].packedLength+9,X.pack=function(t,e,a){return a=Object(c["a"])(a,0),o["a"].pack(t._center,e,a),a+=o["a"].packedLength,d["a"].pack(t._ellipsoid,e,a),a+=d["a"].packedLength,M["a"].pack(t._vertexFormat,e,a),a+=M["a"].packedLength,e[a++]=t._semiMajorAxis,e[a++]=t._semiMinorAxis,e[a++]=t._rotation,e[a++]=t._stRotation,e[a++]=t._height,e[a++]=t._granularity,e[a++]=t._extrudedHeight,e[a++]=t._shadowVolume?1:0,e[a]=Object(c["a"])(t._offsetAttribute,-1),e};const K=new o["a"],$=new d["a"],tt=new M["a"],et={center:K,ellipsoid:$,vertexFormat:tt,semiMajorAxis:void 0,semiMinorAxis:void 0,rotation:void 0,stRotation:void 0,height:void 0,granularity:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};function at(t){const e=-t._stRotation;if(0===e)return[0,0,0,1,1,0];const a=l["a"].computeEllipsePositions({center:t._center,semiMajorAxis:t._semiMajorAxis,semiMinorAxis:t._semiMinorAxis,rotation:t._rotation,granularity:t._granularity},!1,!0),i=a.outerPositions,n=i.length/3,r=new Array(n);for(let u=0;u<n;++u)r[u]=o["a"].fromArray(i,3*u);const s=t._ellipsoid,c=t.rectangle;return m["a"]._textureCoordinateRotationPoints(r,e,s,c)}X.unpack=function(t,e,a){e=Object(c["a"])(e,0);const i=o["a"].unpack(t,e,K);e+=o["a"].packedLength;const n=d["a"].unpack(t,e,$);e+=d["a"].packedLength;const r=M["a"].unpack(t,e,tt);e+=M["a"].packedLength;const s=t[e++],l=t[e++],h=t[e++],m=t[e++],f=t[e++],_=t[e++],p=t[e++],g=1===t[e++],O=t[e];return Object(u["a"])(a)?(a._center=o["a"].clone(i,a._center),a._ellipsoid=d["a"].clone(n,a._ellipsoid),a._vertexFormat=M["a"].clone(r,a._vertexFormat),a._semiMajorAxis=s,a._semiMinorAxis=l,a._rotation=h,a._stRotation=m,a._height=f,a._granularity=_,a._extrudedHeight=p,a._shadowVolume=g,a._offsetAttribute=-1===O?void 0:O,a):(et.height=f,et.extrudedHeight=p,et.granularity=_,et.stRotation=m,et.rotation=h,et.semiMajorAxis=s,et.semiMinorAxis=l,et.shadowVolume=g,et.offsetAttribute=-1===O?void 0:O,new X(et))},X.computeRectangle=function(t,e){t=Object(c["a"])(t,c["a"].EMPTY_OBJECT);const a=t.center,i=Object(c["a"])(t.ellipsoid,d["a"].WGS84),n=t.semiMajorAxis,o=t.semiMinorAxis,r=Object(c["a"])(t.granularity,b["a"].RADIANS_PER_DEGREE),s=Object(c["a"])(t.rotation,0);return J(a,n,o,s,r,i,e)},X.createGeometry=function(t){if(t._semiMajorAxis<=0||t._semiMinorAxis<=0)return;const e=t._height,a=t._extrudedHeight,i=!b["a"].equalsEpsilon(e,a,0,b["a"].EPSILON2);t._center=t._ellipsoid.scaleToGeodeticSurface(t._center,t._center);const n={center:t._center,semiMajorAxis:t._semiMajorAxis,semiMinorAxis:t._semiMinorAxis,ellipsoid:t._ellipsoid,rotation:t._rotation,height:e,granularity:t._granularity,vertexFormat:t._vertexFormat,stRotation:t._stRotation};let o;if(i)n.extrudedHeight=a,n.shadowVolume=t._shadowVolume,n.offsetAttribute=t._offsetAttribute,o=Z(n);else if(o=B(n),Object(u["a"])(t._offsetAttribute)){const e=o.attributes.position.values.length,a=t._offsetAttribute===g["a"].NONE?0:1,i=new Uint8Array(e/3).fill(a);o.attributes.applyOffset=new f["a"]({componentDatatype:s["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}return new m["a"]({attributes:o.attributes,indices:o.indices,primitiveType:P["a"].TRIANGLES,boundingSphere:o.boundingSphere,offsetAttribute:t._offsetAttribute})},X.createShadowVolume=function(t,e,a){const i=t._granularity,n=t._ellipsoid,o=e(i,n),r=a(i,n);return new X({center:t._center,semiMajorAxis:t._semiMajorAxis,semiMinorAxis:t._semiMinorAxis,ellipsoid:n,rotation:t._rotation,stRotation:t._stRotation,granularity:i,extrudedHeight:o,height:r,vertexFormat:M["a"].POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(X.prototype,{rectangle:{get:function(){return Object(u["a"])(this._rectangle)||(this._rectangle=J(this._center,this._semiMajorAxis,this._semiMinorAxis,this._rotation,this._granularity,this._ellipsoid)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return Object(u["a"])(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=at(this)),this._textureCoordinateRotationPoints}}}),e["a"]=X},aee6:function(t,e,a){"use strict";var i=a("535a"),n=a("2f63");function o(t,e){t=Object(i["a"])(t,0),this._near=t,e=Object(i["a"])(e,Number.MAX_VALUE),this._far=e}Object.defineProperties(o.prototype,{near:{get:function(){return this._near},set:function(t){this._near=t}},far:{get:function(){return this._far},set:function(t){this._far=t}}}),o.packedLength=2,o.pack=function(t,e,a){return a=Object(i["a"])(a,0),e[a++]=t.near,e[a]=t.far,e},o.unpack=function(t,e,a){return e=Object(i["a"])(e,0),Object(n["a"])(a)||(a=new o),a.near=t[e++],a.far=t[e],a},o.equals=function(t,e){return t===e||Object(n["a"])(t)&&Object(n["a"])(e)&&t.near===e.near&&t.far===e.far},o.clone=function(t,e){if(Object(n["a"])(t))return Object(n["a"])(e)||(e=new o),e.near=t.near,e.far=t.far,e},o.prototype.clone=function(t){return o.clone(this,t)},o.prototype.equals=function(t){return o.equals(this,t)},e["a"]=o},bcbd:function(t,e,a){"use strict";var i=a("cef5"),n=a("be18"),o=a("abab"),r=a("535a"),s=a("2f63"),c=a("c52f"),u=a("d2c7"),l=a("81d7"),d=a("473c"),h=a("0276"),m=a("0123"),f=a("93da"),_=a("1b8d");const p=new n["a"](1,1,1),g=Math.cos,O=Math.sin;function y(t){t=Object(r["a"])(t,r["a"].EMPTY_OBJECT);const e=Object(r["a"])(t.radii,p),a=Object(r["a"])(t.innerRadii,e),i=Object(r["a"])(t.minimumClock,0),o=Object(r["a"])(t.maximumClock,f["a"].TWO_PI),s=Object(r["a"])(t.minimumCone,0),c=Object(r["a"])(t.maximumCone,f["a"].PI),u=Math.round(Object(r["a"])(t.stackPartitions,10)),l=Math.round(Object(r["a"])(t.slicePartitions,8)),d=Math.round(Object(r["a"])(t.subdivisions,128));this._radii=n["a"].clone(e),this._innerRadii=n["a"].clone(a),this._minimumClock=i,this._maximumClock=o,this._minimumCone=s,this._maximumCone=c,this._stackPartitions=u,this._slicePartitions=l,this._subdivisions=d,this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidOutlineGeometry"}y.packedLength=2*n["a"].packedLength+8,y.pack=function(t,e,a){return a=Object(r["a"])(a,0),n["a"].pack(t._radii,e,a),a+=n["a"].packedLength,n["a"].pack(t._innerRadii,e,a),a+=n["a"].packedLength,e[a++]=t._minimumClock,e[a++]=t._maximumClock,e[a++]=t._minimumCone,e[a++]=t._maximumCone,e[a++]=t._stackPartitions,e[a++]=t._slicePartitions,e[a++]=t._subdivisions,e[a]=Object(r["a"])(t._offsetAttribute,-1),e};const b=new n["a"],x=new n["a"],P={radii:b,innerRadii:x,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,subdivisions:void 0,offsetAttribute:void 0};y.unpack=function(t,e,a){e=Object(r["a"])(e,0);const i=n["a"].unpack(t,e,b);e+=n["a"].packedLength;const o=n["a"].unpack(t,e,x);e+=n["a"].packedLength;const c=t[e++],u=t[e++],l=t[e++],d=t[e++],h=t[e++],m=t[e++],f=t[e++],_=t[e];return Object(s["a"])(a)?(a._radii=n["a"].clone(i,a._radii),a._innerRadii=n["a"].clone(o,a._innerRadii),a._minimumClock=c,a._maximumClock=u,a._minimumCone=l,a._maximumCone=d,a._stackPartitions=h,a._slicePartitions=m,a._subdivisions=f,a._offsetAttribute=-1===_?void 0:_,a):(P.minimumClock=c,P.maximumClock=u,P.minimumCone=l,P.maximumCone=d,P.stackPartitions=h,P.slicePartitions=m,P.subdivisions=f,P.offsetAttribute=-1===_?void 0:_,new y(P))},y.createGeometry=function(t){const e=t._radii;if(e.x<=0||e.y<=0||e.z<=0)return;const a=t._innerRadii;if(a.x<=0||a.y<=0||a.z<=0)return;const n=t._minimumClock,r=t._maximumClock,p=t._minimumCone,y=t._maximumCone,b=t._subdivisions,x=c["a"].fromCartesian3(e);let P=t._slicePartitions+1,A=t._stackPartitions+1;P=Math.round(P*Math.abs(r-n)/f["a"].TWO_PI),A=Math.round(A*Math.abs(y-p)/f["a"].PI),P<2&&(P=2),A<2&&(A=2);let w=0,M=1;const E=a.x!==e.x||a.y!==e.y||a.z!==e.z;let S=!1,v=!1;E&&(M=2,p>0&&(S=!0,w+=P),y<Math.PI&&(v=!0,w+=P));const T=b*M*(A+P),I=new Float64Array(3*T),j=2*(T+w-(P+A)*M),C=m["a"].createTypedArray(T,j);let N,R,L,k,U=0;const z=new Array(A),q=new Array(A);for(N=0;N<A;N++)k=p+N*(y-p)/(A-1),z[N]=O(k),q[N]=g(k);const D=new Array(b),F=new Array(b);for(N=0;N<b;N++)L=n+N*(r-n)/(b-1),D[N]=O(L),F[N]=g(L);for(N=0;N<A;N++)for(R=0;R<b;R++)I[U++]=e.x*z[N]*F[R],I[U++]=e.y*z[N]*D[R],I[U++]=e.z*q[N];if(E)for(N=0;N<A;N++)for(R=0;R<b;R++)I[U++]=a.x*z[N]*F[R],I[U++]=a.y*z[N]*D[R],I[U++]=a.z*q[N];for(z.length=b,q.length=b,N=0;N<b;N++)k=p+N*(y-p)/(b-1),z[N]=O(k),q[N]=g(k);for(D.length=P,F.length=P,N=0;N<P;N++)L=n+N*(r-n)/(P-1),D[N]=O(L),F[N]=g(L);for(N=0;N<b;N++)for(R=0;R<P;R++)I[U++]=e.x*z[N]*F[R],I[U++]=e.y*z[N]*D[R],I[U++]=e.z*q[N];if(E)for(N=0;N<b;N++)for(R=0;R<P;R++)I[U++]=a.x*z[N]*F[R],I[U++]=a.y*z[N]*D[R],I[U++]=a.z*q[N];for(U=0,N=0;N<A*M;N++){const t=N*b;for(R=0;R<b-1;R++)C[U++]=t+R,C[U++]=t+R+1}let W=A*b*M;for(N=0;N<P;N++)for(R=0;R<b-1;R++)C[U++]=W+N+R*P,C[U++]=W+N+(R+1)*P;if(E)for(W=A*b*M+P*b,N=0;N<P;N++)for(R=0;R<b-1;R++)C[U++]=W+N+R*P,C[U++]=W+N+(R+1)*P;if(E){let t=A*b*M,e=t+b*P;if(S)for(N=0;N<P;N++)C[U++]=t+N,C[U++]=e+N;if(v)for(t+=b*P-P,e+=b*P-P,N=0;N<P;N++)C[U++]=t+N,C[U++]=e+N}const V=new d["a"]({position:new l["a"]({componentDatatype:o["a"].DOUBLE,componentsPerAttribute:3,values:I})});if(Object(s["a"])(t._offsetAttribute)){const e=I.length,a=t._offsetAttribute===h["a"].NONE?0:1,i=new Uint8Array(e/3).fill(a);V.applyOffset=new l["a"]({componentDatatype:o["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}return new u["a"]({attributes:V,indices:C,primitiveType:_["a"].LINES,boundingSphere:i["a"].fromEllipsoid(x),offsetAttribute:t._offsetAttribute})},e["a"]=y},c52f:function(t,e,a){"use strict";var i=a("be18"),n=a("bef8"),o=a("535a"),r=a("2f63"),s=a("93da"),c=a("b2d6");function u(t,e,a,n){e=Object(o["a"])(e,0),a=Object(o["a"])(a,0),n=Object(o["a"])(n,0),t._radii=new i["a"](e,a,n),t._radiiSquared=new i["a"](e*e,a*a,n*n),t._radiiToTheFourth=new i["a"](e*e*e*e,a*a*a*a,n*n*n*n),t._oneOverRadii=new i["a"](0===e?0:1/e,0===a?0:1/a,0===n?0:1/n),t._oneOverRadiiSquared=new i["a"](0===e?0:1/(e*e),0===a?0:1/(a*a),0===n?0:1/(n*n)),t._minimumRadius=Math.min(e,a,n),t._maximumRadius=Math.max(e,a,n),t._centerToleranceSquared=s["a"].EPSILON1,0!==t._radiiSquared.z&&(t._squaredXOverSquaredZ=t._radiiSquared.x/t._radiiSquared.z)}function l(t,e,a){this._radii=void 0,this._radiiSquared=void 0,this._radiiToTheFourth=void 0,this._oneOverRadii=void 0,this._oneOverRadiiSquared=void 0,this._minimumRadius=void 0,this._maximumRadius=void 0,this._centerToleranceSquared=void 0,this._squaredXOverSquaredZ=void 0,u(this,t,e,a)}Object.defineProperties(l.prototype,{radii:{get:function(){return this._radii}},radiiSquared:{get:function(){return this._radiiSquared}},radiiToTheFourth:{get:function(){return this._radiiToTheFourth}},oneOverRadii:{get:function(){return this._oneOverRadii}},oneOverRadiiSquared:{get:function(){return this._oneOverRadiiSquared}},minimumRadius:{get:function(){return this._minimumRadius}},maximumRadius:{get:function(){return this._maximumRadius}}}),l.clone=function(t,e){if(!Object(r["a"])(t))return;const a=t._radii;return Object(r["a"])(e)?(i["a"].clone(a,e._radii),i["a"].clone(t._radiiSquared,e._radiiSquared),i["a"].clone(t._radiiToTheFourth,e._radiiToTheFourth),i["a"].clone(t._oneOverRadii,e._oneOverRadii),i["a"].clone(t._oneOverRadiiSquared,e._oneOverRadiiSquared),e._minimumRadius=t._minimumRadius,e._maximumRadius=t._maximumRadius,e._centerToleranceSquared=t._centerToleranceSquared,e):new l(a.x,a.y,a.z)},l.fromCartesian3=function(t,e){return Object(r["a"])(e)||(e=new l),Object(r["a"])(t)?(u(e,t.x,t.y,t.z),e):e},l.WGS84=Object.freeze(new l(6378137,6378137,6356752.314245179)),l.UNIT_SPHERE=Object.freeze(new l(1,1,1)),l.MOON=Object.freeze(new l(s["a"].LUNAR_RADIUS,s["a"].LUNAR_RADIUS,s["a"].LUNAR_RADIUS)),l.prototype.clone=function(t){return l.clone(this,t)},l.packedLength=i["a"].packedLength,l.pack=function(t,e,a){return a=Object(o["a"])(a,0),i["a"].pack(t._radii,e,a),e},l.unpack=function(t,e,a){e=Object(o["a"])(e,0);const n=i["a"].unpack(t,e);return l.fromCartesian3(n,a)},l.prototype.geocentricSurfaceNormal=i["a"].normalize,l.prototype.geodeticSurfaceNormalCartographic=function(t,e){const a=t.longitude,n=t.latitude,o=Math.cos(n),s=o*Math.cos(a),c=o*Math.sin(a),u=Math.sin(n);return Object(r["a"])(e)||(e=new i["a"]),e.x=s,e.y=c,e.z=u,i["a"].normalize(e,e)},l.prototype.geodeticSurfaceNormal=function(t,e){if(!i["a"].equalsEpsilon(t,i["a"].ZERO,s["a"].EPSILON14))return Object(r["a"])(e)||(e=new i["a"]),e=i["a"].multiplyComponents(t,this._oneOverRadiiSquared,e),i["a"].normalize(e,e)};const d=new i["a"],h=new i["a"];l.prototype.cartographicToCartesian=function(t,e){const a=d,n=h;this.geodeticSurfaceNormalCartographic(t,a),i["a"].multiplyComponents(this._radiiSquared,a,n);const o=Math.sqrt(i["a"].dot(a,n));return i["a"].divideByScalar(n,o,n),i["a"].multiplyByScalar(a,t.height,a),Object(r["a"])(e)||(e=new i["a"]),i["a"].add(n,a,e)},l.prototype.cartographicArrayToCartesianArray=function(t,e){const a=t.length;Object(r["a"])(e)?e.length=a:e=new Array(a);for(let i=0;i<a;i++)e[i]=this.cartographicToCartesian(t[i],e[i]);return e};const m=new i["a"],f=new i["a"],_=new i["a"];l.prototype.cartesianToCartographic=function(t,e){const a=this.scaleToGeodeticSurface(t,f);if(!Object(r["a"])(a))return;const o=this.geodeticSurfaceNormal(a,m),c=i["a"].subtract(t,a,_),u=Math.atan2(o.y,o.x),l=Math.asin(o.z),d=s["a"].sign(i["a"].dot(c,t))*i["a"].magnitude(c);return Object(r["a"])(e)?(e.longitude=u,e.latitude=l,e.height=d,e):new n["a"](u,l,d)},l.prototype.cartesianArrayToCartographicArray=function(t,e){const a=t.length;Object(r["a"])(e)?e.length=a:e=new Array(a);for(let i=0;i<a;++i)e[i]=this.cartesianToCartographic(t[i],e[i]);return e},l.prototype.scaleToGeodeticSurface=function(t,e){return Object(c["a"])(t,this._oneOverRadii,this._oneOverRadiiSquared,this._centerToleranceSquared,e)},l.prototype.scaleToGeocentricSurface=function(t,e){Object(r["a"])(e)||(e=new i["a"]);const a=t.x,n=t.y,o=t.z,s=this._oneOverRadiiSquared,c=1/Math.sqrt(a*a*s.x+n*n*s.y+o*o*s.z);return i["a"].multiplyByScalar(t,c,e)},l.prototype.transformPositionToScaledSpace=function(t,e){return Object(r["a"])(e)||(e=new i["a"]),i["a"].multiplyComponents(t,this._oneOverRadii,e)},l.prototype.transformPositionFromScaledSpace=function(t,e){return Object(r["a"])(e)||(e=new i["a"]),i["a"].multiplyComponents(t,this._radii,e)},l.prototype.equals=function(t){return this===t||Object(r["a"])(t)&&i["a"].equals(this._radii,t._radii)},l.prototype.toString=function(){return this._radii.toString()},l.prototype.getSurfaceNormalIntersectionWithZAxis=function(t,e,a){e=Object(o["a"])(e,0);const n=this._squaredXOverSquaredZ;if(Object(r["a"])(a)||(a=new i["a"]),a.x=0,a.y=0,a.z=t.z*(1-n),!(Math.abs(a.z)>=this._radii.z-e))return a};const p=[.14887433898163,.43339539412925,.67940956829902,.86506336668898,.97390652851717,0],g=[.29552422471475,.26926671930999,.21908636251598,.14945134915058,.066671344308684,0];function O(t,e,a){const i=.5*(e+t),n=.5*(e-t);let o=0;for(let r=0;r<5;r++){const t=n*p[r];o+=g[r]*(a(i+t)+a(i-t))}return o*=n,o}l.prototype.surfaceArea=function(t){const e=t.west;let a=t.east;const i=t.south,n=t.north;while(a<e)a+=s["a"].TWO_PI;const o=this._radiiSquared,r=o.x,c=o.y,u=o.z,l=r*c;return O(i,n,(function(t){const i=Math.cos(t),n=Math.sin(t);return Math.cos(t)*O(e,a,(function(t){const e=Math.cos(t),a=Math.sin(t);return Math.sqrt(l*n*n+u*(c*e*e+r*a*a)*i*i)}))}))},e["a"]=l},cef8:function(t,e,a){"use strict";var i=a("be18"),n=a("bef8"),o=a("535a"),r=a("2f63"),s=a("c52f"),c=a("93da");function u(t,e,a){if(0===t)return e*a;const i=t*t,n=i*i,o=n*i,r=o*i,s=r*i,c=s*i,u=a,l=Math.sin(2*u),d=Math.sin(4*u),h=Math.sin(6*u),m=Math.sin(8*u),f=Math.sin(10*u),_=Math.sin(12*u);return e*((1-i/4-3*n/64-5*o/256-175*r/16384-441*s/65536-4851*c/1048576)*u-(3*i/8+3*n/32+45*o/1024+105*r/4096+2205*s/131072+6237*c/524288)*l+(15*n/256+45*o/1024+525*r/16384+1575*s/65536+155925*c/8388608)*d-(35*o/3072+175*r/12288+3675*s/262144+13475*c/1048576)*h+(315*r/131072+2205*s/524288+43659*c/8388608)*m-(693*s/1310720+6237*c/5242880)*f+1001*c/8388608*_)}function l(t,e,a){const i=t/a;if(0===e)return i;const n=i*i,o=n*i,r=o*i,s=e,c=s*s,u=c*c,l=u*c,d=l*c,h=d*c,m=h*c,f=Math.sin(2*i),_=Math.cos(2*i),p=Math.sin(4*i),g=Math.cos(4*i),O=Math.sin(6*i),y=Math.cos(6*i),b=Math.sin(8*i),x=Math.cos(8*i),P=Math.sin(10*i),A=Math.cos(10*i),w=Math.sin(12*i);return i+i*c/4+7*i*u/64+15*i*l/256+579*i*d/16384+1515*i*h/65536+16837*i*m/1048576+(3*i*u/16+45*i*l/256-i*(32*n-561)*d/4096-i*(232*n-1677)*h/16384+i*(399985-90560*n+512*r)*m/5242880)*_+(21*i*l/256+483*i*d/4096-i*(224*n-1969)*h/16384-i*(33152*n-112599)*m/1048576)*g+(151*i*d/4096+4681*i*h/65536+1479*i*m/16384-453*o*m/32768)*y+(1097*i*h/65536+42783*i*m/1048576)*x+8011*i*m/1048576*A+(3*c/8+3*u/16+213*l/2048-3*n*l/64+255*d/4096-33*n*d/512+20861*h/524288-33*n*h/512+r*h/1024+28273*m/1048576-471*n*m/8192+9*r*m/4096)*f+(21*u/256+21*l/256+533*d/8192-21*n*d/512+197*h/4096-315*n*h/4096+584039*m/16777216-12517*n*m/131072+7*r*m/2048)*p+(151*l/6144+151*d/4096+5019*h/131072-453*n*h/16384+26965*m/786432-8607*n*m/131072)*O+(1097*d/131072+1097*h/65536+225797*m/10485760-1097*n*m/65536)*b+(8011*h/2621440+8011*m/1048576)*P+293393*m/251658240*w}function d(t,e){if(0===t)return Math.log(Math.tan(.5*(c["a"].PI_OVER_TWO+e)));const a=t*Math.sin(e);return Math.log(Math.tan(.5*(c["a"].PI_OVER_TWO+e)))-t/2*Math.log((1+a)/(1-a))}function h(t,e,a,i,n){const o=d(t._ellipticity,a),r=d(t._ellipticity,n);return Math.atan2(c["a"].negativePiToPi(i-e),r-o)}function m(t,e,a,i,n,o,r){const s=t._heading,l=o-i;let d=0;if(c["a"].equalsEpsilon(Math.abs(s),c["a"].PI_OVER_TWO,c["a"].EPSILON8))if(e===a)d=e*Math.cos(n)*c["a"].negativePiToPi(l);else{const a=Math.sin(n);d=e*Math.cos(n)*c["a"].negativePiToPi(l)/Math.sqrt(1-t._ellipticitySquared*a*a)}else{const a=u(t._ellipticity,e,n),i=u(t._ellipticity,e,r);d=(i-a)/Math.cos(s)}return Math.abs(d)}const f=new i["a"],_=new i["a"];function p(t,e,a,o){i["a"].normalize(o.cartographicToCartesian(e,_),f),i["a"].normalize(o.cartographicToCartesian(a,_),_);const r=o.maximumRadius,s=o.minimumRadius,c=r*r,u=s*s;t._ellipticitySquared=(c-u)/c,t._ellipticity=Math.sqrt(t._ellipticitySquared),t._start=n["a"].clone(e,t._start),t._start.height=0,t._end=n["a"].clone(a,t._end),t._end.height=0,t._heading=h(t,e.longitude,e.latitude,a.longitude,a.latitude),t._distance=m(t,o.maximumRadius,o.minimumRadius,e.longitude,e.latitude,a.longitude,a.latitude)}function g(t,e,a,i,o,s){if(0===a)return n["a"].clone(t,s);const h=o*o;let m,f,_;if(Math.abs(c["a"].PI_OVER_TWO-Math.abs(e))>c["a"].EPSILON8){const n=u(o,i,t.latitude),r=a*Math.cos(e),s=n+r;f=l(s,o,i);const h=d(o,t.latitude),p=d(o,f);_=Math.tan(e)*(p-h),m=c["a"].negativePiToPi(t.longitude+_)}else{let n;if(f=t.latitude,0===o)n=i*Math.cos(t.latitude);else{const e=Math.sin(t.latitude);n=i*Math.cos(t.latitude)/Math.sqrt(1-h*e*e)}_=a/n,m=e>0?c["a"].negativePiToPi(t.longitude+_):c["a"].negativePiToPi(t.longitude-_)}return Object(r["a"])(s)?(s.longitude=m,s.latitude=f,s.height=0,s):new n["a"](m,f,0)}function O(t,e,a){const i=Object(o["a"])(a,s["a"].WGS84);this._ellipsoid=i,this._start=new n["a"],this._end=new n["a"],this._heading=void 0,this._distance=void 0,this._ellipticity=void 0,this._ellipticitySquared=void 0,Object(r["a"])(t)&&Object(r["a"])(e)&&p(this,t,e,i)}Object.defineProperties(O.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},surfaceDistance:{get:function(){return this._distance}},start:{get:function(){return this._start}},end:{get:function(){return this._end}},heading:{get:function(){return this._heading}}}),O.fromStartHeadingDistance=function(t,e,a,i,n){const u=Object(o["a"])(i,s["a"].WGS84),l=u.maximumRadius,d=u.minimumRadius,h=l*l,m=d*d,f=Math.sqrt((h-m)/h);e=c["a"].negativePiToPi(e);const _=g(t,e,a,u.maximumRadius,f);return!Object(r["a"])(n)||Object(r["a"])(i)&&!i.equals(n.ellipsoid)?new O(t,_,u):(n.setEndPoints(t,_),n)},O.prototype.setEndPoints=function(t,e){p(this,t,e,this._ellipsoid)},O.prototype.interpolateUsingFraction=function(t,e){return this.interpolateUsingSurfaceDistance(t*this._distance,e)},O.prototype.interpolateUsingSurfaceDistance=function(t,e){return g(this._start,this._heading,t,this._ellipsoid.maximumRadius,this._ellipticity,e)},O.prototype.findIntersectionWithLongitude=function(t,e){const a=this._ellipticity,i=this._heading,o=Math.abs(i),s=this._start;if(t=c["a"].negativePiToPi(t),c["a"].equalsEpsilon(Math.abs(t),Math.PI,c["a"].EPSILON14)&&(t=c["a"].sign(s.longitude)*Math.PI),Object(r["a"])(e)||(e=new n["a"]),Math.abs(c["a"].PI_OVER_TWO-o)<=c["a"].EPSILON8)return e.longitude=t,e.latitude=s.latitude,e.height=0,e;if(c["a"].equalsEpsilon(Math.abs(c["a"].PI_OVER_TWO-o),c["a"].PI_OVER_TWO,c["a"].EPSILON8)){if(c["a"].equalsEpsilon(t,s.longitude,c["a"].EPSILON12))return;return e.longitude=t,e.latitude=c["a"].PI_OVER_TWO*c["a"].sign(c["a"].PI_OVER_TWO-i),e.height=0,e}const u=s.latitude,l=a*Math.sin(u),d=Math.tan(.5*(c["a"].PI_OVER_TWO+u))*Math.exp((t-s.longitude)/Math.tan(i)),h=(1+l)/(1-l);let m,f=s.latitude;do{m=f;const t=a*Math.sin(m),e=(1+t)/(1-t);f=2*Math.atan(d*Math.pow(e/h,a/2))-c["a"].PI_OVER_TWO}while(!c["a"].equalsEpsilon(f,m,c["a"].EPSILON12));return e.longitude=t,e.latitude=f,e.height=0,e},O.prototype.findIntersectionWithLatitude=function(t,e){const a=this._ellipticity,i=this._heading,o=this._start;if(c["a"].equalsEpsilon(Math.abs(i),c["a"].PI_OVER_TWO,c["a"].EPSILON8))return;const s=d(a,o.latitude),u=d(a,t),l=Math.tan(i)*(u-s),h=c["a"].negativePiToPi(o.longitude+l);return Object(r["a"])(e)?(e.longitude=h,e.latitude=t,e.height=0,e):new n["a"](h,t,0)},e["a"]=O},cfdc:function(t,e,a){"use strict";var i=a("be18"),n=a("93da"),o=a("df07"),r=a("0260");const s={},c=new i["a"],u=new i["a"],l=new r["a"],d=new o["a"];function h(t,e,a,n,s,h,m,f,_,p){const g=t+e;i["a"].multiplyByScalar(n,Math.cos(g),c),i["a"].multiplyByScalar(a,Math.sin(g),u),i["a"].add(c,u,c);let O=Math.cos(t);O*=O;let y=Math.sin(t);y*=y;const b=h/Math.sqrt(m*O+s*y),x=b/f;return r["a"].fromAxisAngle(c,x,l),o["a"].fromQuaternion(l,d),o["a"].multiplyByVector(d,_,p),i["a"].normalize(p,p),i["a"].multiplyByScalar(p,f,p),p}const m=new i["a"],f=new i["a"],_=new i["a"],p=new i["a"];s.raisePositionsToHeight=function(t,e,a){const n=e.ellipsoid,o=e.height,r=e.extrudedHeight,s=a?t.length/3*2:t.length/3,c=new Float64Array(3*s),u=t.length,l=a?u:0;for(let d=0;d<u;d+=3){const e=d+1,s=d+2,u=i["a"].fromArray(t,d,m);n.scaleToGeodeticSurface(u,u);const h=i["a"].clone(u,f),g=n.geodeticSurfaceNormal(u,p),O=i["a"].multiplyByScalar(g,o,_);i["a"].add(u,O,u),a&&(i["a"].multiplyByScalar(g,r,O),i["a"].add(h,O,h),c[d+l]=h.x,c[e+l]=h.y,c[s+l]=h.z),c[d]=u.x,c[e]=u.y,c[s]=u.z}return c};const g=new i["a"],O=new i["a"],y=new i["a"];s.computeEllipsePositions=function(t,e,a){const o=t.semiMinorAxis,r=t.semiMajorAxis,s=t.rotation,c=t.center,u=8*t.granularity,l=o*o,d=r*r,p=r*o,b=i["a"].magnitude(c),x=i["a"].normalize(c,g);let P=i["a"].cross(i["a"].UNIT_Z,c,O);P=i["a"].normalize(P,P);const A=i["a"].cross(x,P,y);let w=1+Math.ceil(n["a"].PI_OVER_TWO/u);const M=n["a"].PI_OVER_TWO/(w-1);let E=n["a"].PI_OVER_TWO-w*M;E<0&&(w-=Math.ceil(Math.abs(E)/M));const S=w*(w+2)*2,v=e?new Array(3*S):void 0;let T=0,I=m,j=f;const C=4*w*3;let N=C-1,R=0;const L=a?new Array(C):void 0;let k,U,z,q,D;for(E=n["a"].PI_OVER_TWO,I=h(E,s,A,P,l,p,d,b,x,I),e&&(v[T++]=I.x,v[T++]=I.y,v[T++]=I.z),a&&(L[N--]=I.z,L[N--]=I.y,L[N--]=I.x),E=n["a"].PI_OVER_TWO-M,k=1;k<w+1;++k){if(I=h(E,s,A,P,l,p,d,b,x,I),j=h(Math.PI-E,s,A,P,l,p,d,b,x,j),e){for(v[T++]=I.x,v[T++]=I.y,v[T++]=I.z,z=2*k+2,U=1;U<z-1;++U)q=U/(z-1),D=i["a"].lerp(I,j,q,_),v[T++]=D.x,v[T++]=D.y,v[T++]=D.z;v[T++]=j.x,v[T++]=j.y,v[T++]=j.z}a&&(L[N--]=I.z,L[N--]=I.y,L[N--]=I.x,L[R++]=j.x,L[R++]=j.y,L[R++]=j.z),E=n["a"].PI_OVER_TWO-(k+1)*M}for(k=w;k>1;--k){if(E=n["a"].PI_OVER_TWO-(k-1)*M,I=h(-E,s,A,P,l,p,d,b,x,I),j=h(E+Math.PI,s,A,P,l,p,d,b,x,j),e){for(v[T++]=I.x,v[T++]=I.y,v[T++]=I.z,z=2*(k-1)+2,U=1;U<z-1;++U)q=U/(z-1),D=i["a"].lerp(I,j,q,_),v[T++]=D.x,v[T++]=D.y,v[T++]=D.z;v[T++]=j.x,v[T++]=j.y,v[T++]=j.z}a&&(L[N--]=I.z,L[N--]=I.y,L[N--]=I.x,L[R++]=j.x,L[R++]=j.y,L[R++]=j.z)}E=n["a"].PI_OVER_TWO,I=h(-E,s,A,P,l,p,d,b,x,I);const F={};return e&&(v[T++]=I.x,v[T++]=I.y,v[T++]=I.z,F.positions=v,F.numPts=w),a&&(L[N--]=I.z,L[N--]=I.y,L[N--]=I.x,F.outerPositions=L),F},e["a"]=s}}]);