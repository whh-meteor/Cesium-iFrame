(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["Cesium~66537c81"],{"2a1b":function(e,t,a){"use strict";var i=a("670c"),n=a("be18"),s=a("bef8"),o=a("abab"),r=a("535a"),c=a("2f63"),u=a("6cbd"),h=a("c888"),d=a("93da"),m=a("52f0"),l=a("eace"),p=a("f806"),_=a("5770"),f=a("3a8e"),w=a("001c");function g(e,t,a){this._projectionExtentDefines={eastMostYhighDefine:"",eastMostYlowDefine:"",westMostYhighDefine:"",westMostYlowDefine:""};const i=new E;i.requiresTextureCoordinates=e,i.requiresEC=!a.flat;const n=new E;if(n.requiresTextureCoordinates=e,a instanceof f["a"])i.requiresNormalEC=!a.flat;else{const e=`${a.material.shaderSource}\n${a.fragmentShaderSource}`;i.normalEC=-1!==e.indexOf("materialInput.normalEC")||-1!==e.indexOf("czm_getDefaultMaterial"),i.positionToEyeEC=-1!==e.indexOf("materialInput.positionToEyeEC"),i.tangentToEyeMatrix=-1!==e.indexOf("materialInput.tangentToEyeMatrix"),i.st=-1!==e.indexOf("materialInput.st")}this._colorShaderDependencies=i,this._pickShaderDependencies=n,this._appearance=a,this._extentsCulling=e,this._planarExtents=t}g.prototype.createFragmentShader=function(e){const t=this._appearance,a=this._colorShaderDependencies,i=[];e||this._planarExtents||i.push("SPHERICAL"),a.requiresEC&&i.push("REQUIRES_EC"),a.requiresWC&&i.push("REQUIRES_WC"),a.requiresTextureCoordinates&&i.push("TEXTURE_COORDINATES"),this._extentsCulling&&i.push("CULL_FRAGMENTS"),a.requiresNormalEC&&i.push("NORMAL_EC"),t instanceof f["a"]&&i.push("PER_INSTANCE_COLOR"),a.normalEC&&i.push("USES_NORMAL_EC"),a.positionToEyeEC&&i.push("USES_POSITION_TO_EYE_EC"),a.tangentToEyeMatrix&&i.push("USES_TANGENT_TO_EYE"),a.st&&i.push("USES_ST"),t.flat&&i.push("FLAT");let n="";return t instanceof f["a"]||(n=t.material.shaderSource),new _["a"]({defines:i,sources:[n,w["a"]]})},g.prototype.createPickFragmentShader=function(e){const t=this._pickShaderDependencies,a=["PICK"];return e||this._planarExtents||a.push("SPHERICAL"),t.requiresEC&&a.push("REQUIRES_EC"),t.requiresWC&&a.push("REQUIRES_WC"),t.requiresTextureCoordinates&&a.push("TEXTURE_COORDINATES"),this._extentsCulling&&a.push("CULL_FRAGMENTS"),new _["a"]({defines:a,sources:[w["a"]],pickColorQualifier:"varying"})},g.prototype.createVertexShader=function(e,t,a,i){return b(this._colorShaderDependencies,this._planarExtents,a,e,t,this._appearance,i,this._projectionExtentDefines)},g.prototype.createPickVertexShader=function(e,t,a,i){return b(this._pickShaderDependencies,this._planarExtents,a,e,t,void 0,i,this._projectionExtentDefines)};const C=new n["a"],S=new s["a"],x={high:0,low:0};function b(e,t,a,i,n,s,o,r){const h=i.slice();if(""===r.eastMostYhighDefine){const e=S;e.longitude=d["a"].PI,e.latitude=0,e.height=0;const t=o.project(e,C);let a=u["a"].encode(t.x,x);r.eastMostYhighDefine="EAST_MOST_X_HIGH "+a.high.toFixed((""+a.high).length+1),r.eastMostYlowDefine="EAST_MOST_X_LOW "+a.low.toFixed((""+a.low).length+1);const i=S;i.longitude=-d["a"].PI,i.latitude=0,i.height=0;const n=o.project(i,C);a=u["a"].encode(n.x,x),r.westMostYhighDefine="WEST_MOST_X_HIGH "+a.high.toFixed((""+a.high).length+1),r.westMostYlowDefine="WEST_MOST_X_LOW "+a.low.toFixed((""+a.low).length+1)}return a&&(h.push(r.eastMostYhighDefine),h.push(r.eastMostYlowDefine),h.push(r.westMostYhighDefine),h.push(r.westMostYlowDefine)),Object(c["a"])(s)&&s instanceof f["a"]&&h.push("PER_INSTANCE_COLOR"),e.requiresTextureCoordinates&&(h.push("TEXTURE_COORDINATES"),t||a||h.push("SPHERICAL"),a&&h.push("COLUMBUS_VIEW_2D")),new _["a"]({defines:h,sources:[n]})}function E(){this._requiresEC=!1,this._requiresWC=!1,this._requiresNormalEC=!1,this._requiresTextureCoordinates=!1,this._usesNormalEC=!1,this._usesPositionToEyeEC=!1,this._usesTangentToEyeMat=!1,this._usesSt=!1}function y(e,t,a){return Math.abs((t.y-e.y)*a.x-(t.x-e.x)*a.y+t.x*e.y-t.y*e.x)/i["a"].distance(t,e)}Object.defineProperties(E.prototype,{requiresEC:{get:function(){return this._requiresEC},set:function(e){this._requiresEC=e||this._requiresEC}},requiresWC:{get:function(){return this._requiresWC},set:function(e){this._requiresWC=e||this._requiresWC,this.requiresEC=this._requiresWC}},requiresNormalEC:{get:function(){return this._requiresNormalEC},set:function(e){this._requiresNormalEC=e||this._requiresNormalEC,this.requiresEC=this._requiresNormalEC}},requiresTextureCoordinates:{get:function(){return this._requiresTextureCoordinates},set:function(e){this._requiresTextureCoordinates=e||this._requiresTextureCoordinates,this.requiresWC=this._requiresTextureCoordinates}},normalEC:{set:function(e){this.requiresNormalEC=e,this._usesNormalEC=e},get:function(){return this._usesNormalEC}},tangentToEyeMatrix:{set:function(e){this.requiresWC=e,this.requiresNormalEC=e,this._usesTangentToEyeMat=e},get:function(){return this._usesTangentToEyeMat}},positionToEyeEC:{set:function(e){this.requiresEC=e,this._usesPositionToEyeEC=e},get:function(){return this._usesPositionToEyeEC}},st:{set:function(e){this.requiresTextureCoordinates=e,this._usesSt=e},get:function(){return this._usesSt}}});const v=[new i["a"],new i["a"],new i["a"],new i["a"]];function O(e,t){const a=v,n=i["a"].unpack(t,0,a[0]),s=i["a"].unpack(t,2,a[1]),r=i["a"].unpack(t,4,a[2]);e.uMaxVmax=new h["a"]({componentDatatype:o["a"].FLOAT,componentsPerAttribute:4,normalize:!1,value:[s.x,s.y,r.x,r.y]});const c=1/y(n,s,r),u=1/y(n,r,s);e.uvMinAndExtents=new h["a"]({componentDatatype:o["a"].FLOAT,componentsPerAttribute:4,normalize:!1,value:[n.x,n.y,c,u]})}const M=new s["a"],P=new n["a"],A=new n["a"],T=new n["a"],D={high:0,low:0};function L(e,t,a){const i=M;i.height=0,i.longitude=e.west,i.latitude=e.south;const n=t.project(i,P);i.latitude=e.north;const s=t.project(i,A);i.longitude=e.east,i.latitude=e.south;const r=t.project(i,T),c=[0,0,0,0],d=[0,0,0,0];let m=u["a"].encode(n.x,D);c[0]=m.high,d[0]=m.low,m=u["a"].encode(n.y,D),c[1]=m.high,d[1]=m.low,m=u["a"].encode(s.y,D),c[2]=m.high,d[2]=m.low,m=u["a"].encode(r.x,D),c[3]=m.high,d[3]=m.low,a.planes2D_HIGH=new h["a"]({componentDatatype:o["a"].FLOAT,componentsPerAttribute:4,normalize:!1,value:c}),a.planes2D_LOW=new h["a"]({componentDatatype:o["a"].FLOAT,componentsPerAttribute:4,normalize:!1,value:d})}const N=new m["a"],z=new m["a"],F=new n["a"],I=new s["a"],R=[new s["a"],new s["a"],new s["a"],new s["a"],new s["a"],new s["a"],new s["a"],new s["a"]];function j(e,t,a,i,o,r){const c=l["a"].center(e,I);c.height=a;const u=s["a"].toCartesian(c,t,F),h=p["a"].eastNorthUpToFixedFrame(u,t,N),d=m["a"].inverse(h,z),_=e.west,f=e.east,w=e.north,g=e.south,C=R;C[0].latitude=g,C[0].longitude=_,C[1].latitude=w,C[1].longitude=_,C[2].latitude=w,C[2].longitude=f,C[3].latitude=g,C[3].longitude=f;const S=.5*(_+f),x=.5*(w+g);C[4].latitude=g,C[4].longitude=S,C[5].latitude=w,C[5].longitude=S,C[6].latitude=x,C[6].longitude=_,C[7].latitude=x,C[7].longitude=f;let b=Number.POSITIVE_INFINITY,E=Number.NEGATIVE_INFINITY,y=Number.POSITIVE_INFINITY,v=Number.NEGATIVE_INFINITY;for(let n=0;n<8;n++){C[n].height=a;const e=s["a"].toCartesian(C[n],t,F);m["a"].multiplyByPoint(d,e,e),e.z=0,b=Math.min(b,e.x),E=Math.max(E,e.x),y=Math.min(y,e.y),v=Math.max(v,e.y)}const O=i;O.x=b,O.y=y,O.z=0,m["a"].multiplyByPoint(h,O,O);const M=o;M.x=E,M.y=y,M.z=0,m["a"].multiplyByPoint(h,M,M),n["a"].subtract(M,O,o);const P=r;P.x=b,P.y=v,P.z=0,m["a"].multiplyByPoint(h,P,P),n["a"].subtract(P,O,r)}const V=new n["a"],W=new n["a"],B=new u["a"];g.getPlanarTextureCoordinateAttributes=function(e,t,a,i,s){const c=P,d=V,m=W;j(e,a,Object(r["a"])(s,0),c,d,m);const l={};O(l,t);const p=u["a"].fromCartesian(c,B);return l.southWest_HIGH=new h["a"]({componentDatatype:o["a"].FLOAT,componentsPerAttribute:3,normalize:!1,value:n["a"].pack(p.high,[0,0,0])}),l.southWest_LOW=new h["a"]({componentDatatype:o["a"].FLOAT,componentsPerAttribute:3,normalize:!1,value:n["a"].pack(p.low,[0,0,0])}),l.eastward=new h["a"]({componentDatatype:o["a"].FLOAT,componentsPerAttribute:3,normalize:!1,value:n["a"].pack(d,[0,0,0])}),l.northward=new h["a"]({componentDatatype:o["a"].FLOAT,componentsPerAttribute:3,normalize:!1,value:n["a"].pack(m,[0,0,0])}),L(e,i,l),l};const U=new n["a"];function H(e,t,a,i){const n=M;n.latitude=e,n.longitude=t,n.height=0;const o=s["a"].toCartesian(n,a,U),r=Math.sqrt(o.x*o.x+o.y*o.y),c=d["a"].fastApproximateAtan2(r,o.z),u=d["a"].fastApproximateAtan2(o.x,o.y);return i.x=c,i.y=u,i}const q=new i["a"];function k(e){return Math.max(e.width,e.height)>g.MAX_WIDTH_FOR_PLANAR_EXTENTS}g.getSphericalExtentGeometryInstanceAttributes=function(e,t,a,i){const n=H(e.south,e.west,a,q);let s=n.x,r=n.y;const c=H(e.north,e.east,a,q);let u=c.x,m=c.y,l=0;r>m&&(l=d["a"].PI-r,r=-d["a"].PI,m+=l),s-=d["a"].EPSILON5,r-=d["a"].EPSILON5,u+=d["a"].EPSILON5,m+=d["a"].EPSILON5;const p=1/(m-r),_=1/(u-s),f={sphericalExtents:new h["a"]({componentDatatype:o["a"].FLOAT,componentsPerAttribute:4,normalize:!1,value:[s,r,_,p]}),longitudeRotation:new h["a"]({componentDatatype:o["a"].FLOAT,componentsPerAttribute:1,normalize:!1,value:[l]})};return O(f,t),L(e,i,f),f},g.hasAttributesForTextureCoordinatePlanes=function(e){return Object(c["a"])(e.southWest_HIGH)&&Object(c["a"])(e.southWest_LOW)&&Object(c["a"])(e.northward)&&Object(c["a"])(e.eastward)&&Object(c["a"])(e.planes2D_HIGH)&&Object(c["a"])(e.planes2D_LOW)&&Object(c["a"])(e.uMaxVmax)&&Object(c["a"])(e.uvMinAndExtents)},g.hasAttributesForSphericalExtents=function(e){return Object(c["a"])(e.sphericalExtents)&&Object(c["a"])(e.longitudeRotation)&&Object(c["a"])(e.planes2D_HIGH)&&Object(c["a"])(e.planes2D_LOW)&&Object(c["a"])(e.uMaxVmax)&&Object(c["a"])(e.uvMinAndExtents)},g.shouldUseSphericalCoordinates=function(e){return k(e)},g.MAX_WIDTH_FOR_PLANAR_EXTENTS=d["a"].toRadians(1),t["a"]=g},"569f":function(e,t,a){"use strict";var i=a("77af"),n=a("cef5"),s=a("b081"),o=a("670c"),r=a("be18"),c=a("a561"),u=a("bef8"),h=a("dc1c"),d=a("bd8d"),m=a("9541"),l=a("2bb9"),p=a("2384"),_=a("535a"),f=a("2f63"),w=a("7d62"),g=a("5e57"),C=a("d940"),S=a("66bf"),x=a("93da"),b=a("52f0"),E=a("c34a"),y=a("4e1a"),v=a("e42d"),O=a("0260"),M=a("98f6"),P=a("daa2"),A=a("f845"),T=a("b997"),D=a("9ab9"),L=a("a894"),N=a("ac3b"),z=a("d289"),F=a("00f8"),I=a("6ef5"),R=a("8a65"),j=a("3550"),V=a("6dc0"),W=a("6c84"),B=a("a913"),U=a("9dbf"),H=a("29ab"),q=a("c965"),k=a("3a8e"),G=a("894b"),Y=a("5770");function X(){}X.getShadowCastShaderKeyword=function(e,t,a,i){return`castShadow ${e} ${t} ${a} ${i}`},X.createShadowCastVertexShader=function(e,t,a){const i=e.defines.slice(0),n=e.sources.slice(0);i.push("SHADOW_MAP"),a&&i.push("GENERATE_POSITION");const s=Y["a"].findPositionVarying(e),o=Object(f["a"])(s);if(t&&!o){const e=n.length;for(let a=0;a<e;++a)n[a]=Y["a"].replaceMain(n[a],"czm_shadow_cast_main");const t="varying vec3 v_positionEC; \nvoid main() \n{ \n    czm_shadow_cast_main(); \n    v_positionEC = (czm_inverseProjection * gl_Position).xyz; \n}";n.push(t)}return new Y["a"]({defines:i,sources:n})},X.createShadowCastFragmentShader=function(e,t,a,i){const n=e.defines.slice(0),s=e.sources.slice(0);n.push("SHADOW_MAP");let o=Y["a"].findPositionVarying(e);const r=Object(f["a"])(o);r||(o="v_positionEC");const c=s.length;for(let h=0;h<c;++h)s[h]=Y["a"].replaceMain(s[h],"czm_shadow_cast_main");let u="";return t&&(r||(u+="varying vec3 v_positionEC; \n"),u+="uniform vec4 shadowMap_lightPositionEC; \n"),u+=i?"void main() \n{ \n":"void main() \n{ \n    czm_shadow_cast_main(); \n    if (gl_FragColor.a == 0.0) \n    { \n       discard; \n    } \n",u+=t?`    float distance = length(${o}); \n    if (distance >= shadowMap_lightPositionEC.w) \n    { \n        discard; \n    } \n    distance /= shadowMap_lightPositionEC.w; // radius \n    gl_FragColor = czm_packDepth(distance); \n`:a?"    gl_FragColor = vec4(1.0); \n":"    gl_FragColor = czm_packDepth(gl_FragCoord.z); \n",u+="} \n",s.push(u),new Y["a"]({defines:n,sources:s})},X.getShadowReceiveShaderKeyword=function(e,t,a,i){const n=e._usesDepthTexture,s=e._polygonOffsetSupported,o=e._isPointLight,r=e._isSpotLight,c=e._numberOfCascades>1,u=e.debugCascadeColors,h=e.softShadows;return`receiveShadow ${n}${s}${o}${r}${c}${u}${h}${t}${a}${i}`},X.createShadowReceiveVertexShader=function(e,t,a){const i=e.defines.slice(0),n=e.sources.slice(0);return i.push("SHADOW_MAP"),t&&(a?i.push("GENERATE_POSITION_AND_NORMAL"):i.push("GENERATE_POSITION")),new Y["a"]({defines:i,sources:n})},X.createShadowReceiveFragmentShader=function(e,t,a,i,n){const s=Y["a"].findNormalVarying(e),o=!i&&Object(f["a"])(s)||i&&n,r=Y["a"].findPositionVarying(e),c=Object(f["a"])(r),u=t._usesDepthTexture,h=t._polygonOffsetSupported,d=t._isPointLight,m=t._isSpotLight,l=t._numberOfCascades>1,p=t.debugCascadeColors,_=t.softShadows,w=d?t._pointBias:i?t._terrainBias:t._primitiveBias,g=e.defines.slice(0),C=e.sources.slice(0),S=C.length;for(let f=0;f<S;++f)C[f]=Y["a"].replaceMain(C[f],"czm_shadow_receive_main");d?g.push("USE_CUBE_MAP_SHADOW"):u&&g.push("USE_SHADOW_DEPTH_TEXTURE"),_&&!d&&g.push("USE_SOFT_SHADOWS"),l&&a&&i&&(o?g.push("ENABLE_VERTEX_LIGHTING"):g.push("ENABLE_DAYNIGHT_SHADING")),a&&w.normalShading&&o&&(g.push("USE_NORMAL_SHADING"),w.normalShadingSmooth>0&&g.push("USE_NORMAL_SHADING_SMOOTH"));let x,b="";return b+=d?"uniform samplerCube shadowMap_textureCube; \n":"uniform sampler2D shadowMap_texture; \n",x=c?`    return vec4(${r}, 1.0); \n`:"#ifndef LOG_DEPTH \n    return czm_windowToEyeCoordinates(gl_FragCoord); \n#else \n    return vec4(v_logPositionEC, 1.0); \n#endif \n",b+=`uniform mat4 shadowMap_matrix; \nuniform vec3 shadowMap_lightDirectionEC; \nuniform vec4 shadowMap_lightPositionEC; \nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \n#ifdef LOG_DEPTH \nvarying vec3 v_logPositionEC; \n#endif \nvec4 getPositionEC() \n{ \n${x}} \nvec3 getNormalEC() \n{ \n${o?`    return normalize(${s}); \n`:"    return vec3(1.0); \n"}} \nvoid applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) \n{ \n${w.normalOffset&&o?"    float normalOffset = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.x; \n    float normalOffsetScale = 1.0 - nDotL; \n    vec3 offset = normalOffset * normalOffsetScale * normalEC; \n    positionEC.xyz += offset; \n":""}} \n`,b+="void main() \n{ \n    czm_shadow_receive_main(); \n    vec4 positionEC = getPositionEC(); \n    vec3 normalEC = getNormalEC(); \n    float depth = -positionEC.z; \n",b+="    czm_shadowParameters shadowParameters; \n    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy; \n    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z; \n    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w; \n    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w; \n",i?b+="    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \n":h||(b+="    shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015); \n"),b+=d?"    vec3 directionEC = positionEC.xyz - shadowMap_lightPositionEC.xyz; \n    float distance = length(directionEC); \n    directionEC = normalize(directionEC); \n    float radius = shadowMap_lightPositionEC.w; \n    // Stop early if the fragment is beyond the point light radius \n    if (distance > radius) \n    { \n        return; \n    } \n    vec3 directionWC  = czm_inverseViewRotation * directionEC; \n    shadowParameters.depth = distance / radius; \n    shadowParameters.nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    shadowParameters.texCoords = directionWC; \n    float visibility = czm_shadowVisibility(shadowMap_textureCube, shadowParameters); \n":m?"    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); \n    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Spot light uses a perspective projection, so perform the perspective divide \n    shadowPosition /= shadowPosition.w; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n":l?"    float maxDepth = shadowMap_cascadeSplits[1].w; \n    // Stop early if the eye depth exceeds the last cascade \n    if (depth > maxDepth) \n    { \n        return; \n    } \n    // Get the cascade based on the eye-space depth \n    vec4 weights = czm_cascadeWeights(depth); \n    // Apply normal offset \n    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    // Transform position into the cascade \n    vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC; \n    // Get visibility \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n    // Fade out shadows that are far away \n    float shadowMapMaximumDistance = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.z; \n    float fade = max((depth - shadowMapMaximumDistance * 0.8) / (shadowMapMaximumDistance * 0.2), 0.0); \n    visibility = mix(visibility, 1.0, fade); \n"+(p?"    // Draw cascade colors for debugging \n    gl_FragColor *= czm_cascadeColor(weights); \n":""):"    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \n    applyNormalOffset(positionEC, normalEC, nDotL); \n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    shadowParameters.nDotL = nDotL; \n    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \n",b+="    gl_FragColor.rgb *= visibility; \n} \n",C.push(b),new Y["a"]({defines:g,sources:C})};var $=X;function Q(e){e=Object(_["a"])(e,_["a"].EMPTY_OBJECT);const t=e.context;this._enabled=Object(_["a"])(e.enabled,!0),this._softShadows=Object(_["a"])(e.softShadows,!1),this._normalOffset=Object(_["a"])(e.normalOffset,!0),this.dirty=!0,this.fromLightSource=Object(_["a"])(e.fromLightSource,!0),this.darkness=Object(_["a"])(e.darkness,.3),this._darkness=this.darkness,this.fadingEnabled=Object(_["a"])(e.fadingEnabled,!0),this.maximumDistance=Object(_["a"])(e.maximumDistance,5e3),this._outOfView=!1,this._outOfViewPrevious=!1,this._needsUpdate=!0;let a,i=!0;(g["a"].isInternetExplorer()||g["a"].isEdge()||(g["a"].isChrome()||g["a"].isFirefox())&&g["a"].isWindows()&&!t.depthTexture)&&(i=!1),this._polygonOffsetSupported=i,this._terrainBias={polygonOffset:i,polygonOffsetFactor:1.1,polygonOffsetUnits:4,normalOffset:this._normalOffset,normalOffsetScale:.5,normalShading:!0,normalShadingSmooth:.3,depthBias:1e-4},this._primitiveBias={polygonOffset:i,polygonOffsetFactor:1.1,polygonOffsetUnits:4,normalOffset:this._normalOffset,normalOffsetScale:.1,normalShading:!0,normalShadingSmooth:.05,depthBias:2e-5},this._pointBias={polygonOffset:!1,polygonOffsetFactor:1.1,polygonOffsetUnits:4,normalOffset:this._normalOffset,normalOffsetScale:0,normalShading:!0,normalShadingSmooth:.1,depthBias:5e-4},this._depthAttachment=void 0,this._colorAttachment=void 0,this._shadowMapMatrix=new b["a"],this._shadowMapTexture=void 0,this._lightDirectionEC=new r["a"],this._lightPositionEC=new c["a"],this._distance=0,this._lightCamera=e.lightCamera,this._shadowMapCamera=new Ce,this._shadowMapCullingVolume=void 0,this._sceneCamera=void 0,this._boundingSphere=new n["a"],this._isPointLight=Object(_["a"])(e.isPointLight,!1),this._pointLightRadius=Object(_["a"])(e.pointLightRadius,100),this._cascadesEnabled=!this._isPointLight&&Object(_["a"])(e.cascadesEnabled,!0),this._numberOfCascades=this._cascadesEnabled?Object(_["a"])(e.numberOfCascades,4):0,this._fitNearFar=!0,this._maximumCascadeDistances=[25,150,700,Number.MAX_VALUE],this._textureSize=new o["a"],this._isSpotLight=!1,this._cascadesEnabled?this._shadowMapCamera.frustum=new E["a"]:Object(f["a"])(this._lightCamera.frustum.fov)&&(this._isSpotLight=!0),this._cascadeSplits=[new c["a"],new c["a"]],this._cascadeMatrices=[new b["a"],new b["a"],new b["a"],new b["a"]],this._cascadeDistances=new c["a"],a=this._isPointLight?6:this._cascadesEnabled?this._numberOfCascades:1,this._passes=new Array(a);for(let n=0;n<a;++n)this._passes[n]=new Z(t);this.debugShow=!1,this.debugFreezeFrame=!1,this._debugFreezeFrame=!1,this._debugCascadeColors=!1,this._debugLightFrustum=void 0,this._debugCameraFrustum=void 0,this._debugCascadeFrustums=new Array(this._numberOfCascades),this._debugShadowViewCommand=void 0,this._usesDepthTexture=t.depthTexture,this._isPointLight&&(this._usesDepthTexture=!1),this._primitiveRenderState=void 0,this._terrainRenderState=void 0,this._pointRenderState=void 0,J(this),this._clearCommand=new A["a"]({depth:1,color:new d["a"]}),this._clearPassState=new F["a"](t),this._size=Object(_["a"])(e.size,2048),this.size=this._size}function Z(e){this.camera=new Ce,this.passState=new F["a"](e),this.framebuffer=void 0,this.textureOffsets=void 0,this.commandList=[],this.cullingVolume=void 0}function K(e,t){return V["a"].fromCache({cull:{enabled:!0,face:H["a"].BACK},depthTest:{enabled:!0},colorMask:{red:e,green:e,blue:e,alpha:e},depthMask:!0,polygonOffset:{enabled:t.polygonOffset,factor:t.polygonOffsetFactor,units:t.polygonOffsetUnits}})}function J(e){const t=!e._usesDepthTexture;e._primitiveRenderState=K(t,e._primitiveBias),e._terrainRenderState=K(t,e._terrainBias),e._pointRenderState=K(t,e._pointBias)}function ee(e){const t=e._passes.length;for(let a=0;a<t;++a){const t=e._passes[a],i=t.framebuffer;Object(f["a"])(i)&&!i.isDestroyed()&&i.destroy(),t.framebuffer=void 0}e._depthAttachment=e._depthAttachment&&e._depthAttachment.destroy(),e._colorAttachment=e._colorAttachment&&e._colorAttachment.destroy()}function te(e,t){const a=new R["a"]({context:t,width:e._textureSize.x,height:e._textureSize.y,format:j["a"].DEPTH_COMPONENT16}),i=new B["a"]({context:t,width:e._textureSize.x,height:e._textureSize.y,pixelFormat:v["a"].RGBA,pixelDatatype:I["a"].UNSIGNED_BYTE,sampler:W["a"].NEAREST}),n=new N["a"]({context:t,depthRenderbuffer:a,colorTextures:[i],destroyAttachments:!1}),s=e._passes.length;for(let o=0;o<s;++o){const t=e._passes[o];t.framebuffer=n,t.passState.framebuffer=n}e._shadowMapTexture=i,e._depthAttachment=a,e._colorAttachment=i}function ae(e,t){const a=new B["a"]({context:t,width:e._textureSize.x,height:e._textureSize.y,pixelFormat:v["a"].DEPTH_STENCIL,pixelDatatype:I["a"].UNSIGNED_INT_24_8,sampler:W["a"].NEAREST}),i=new N["a"]({context:t,depthStencilTexture:a,destroyAttachments:!1}),n=e._passes.length;for(let s=0;s<n;++s){const t=e._passes[s];t.framebuffer=i,t.passState.framebuffer=i}e._shadowMapTexture=a,e._depthAttachment=a}function ie(e,t){const a=new R["a"]({context:t,width:e._textureSize.x,height:e._textureSize.y,format:j["a"].DEPTH_COMPONENT16}),i=new D["a"]({context:t,width:e._textureSize.x,height:e._textureSize.y,pixelFormat:v["a"].RGBA,pixelDatatype:I["a"].UNSIGNED_BYTE,sampler:W["a"].NEAREST}),n=[i.negativeX,i.negativeY,i.negativeZ,i.positiveX,i.positiveY,i.positiveZ];for(let s=0;s<6;++s){const i=new N["a"]({context:t,depthRenderbuffer:a,colorTextures:[n[s]],destroyAttachments:!1}),o=e._passes[s];o.framebuffer=i,o.passState.framebuffer=i}e._shadowMapTexture=i,e._depthAttachment=a,e._colorAttachment=i}function ne(e,t){e._isPointLight?ie(e,t):e._usesDepthTexture?ae(e,t):te(e,t)}function se(e,t){e._usesDepthTexture&&e._passes[0].framebuffer.status!==P["a"].FRAMEBUFFER_COMPLETE&&(e._usesDepthTexture=!1,J(e),ee(e),ne(e,t))}function oe(e,t){Object(f["a"])(e._passes[0].framebuffer)&&e._shadowMapTexture.width===e._textureSize.x||(ee(e),ne(e,t),se(e,t),re(e,t))}function re(e,t,a){a=Object(_["a"])(a,0),(e._isPointLight||0===a)&&(e._clearCommand.framebuffer=e._passes[a].framebuffer,e._clearCommand.execute(t,e._clearPassState))}function ce(e,t){e._size=t;const a=e._passes,n=a.length,s=e._textureSize;if(e._isPointLight){t=T["a"].maximumCubeMapSize>=t?t:T["a"].maximumCubeMapSize,s.x=t,s.y=t;const e=new i["a"](0,0,t,t);a[0].passState.viewport=e,a[1].passState.viewport=e,a[2].passState.viewport=e,a[3].passState.viewport=e,a[4].passState.viewport=e,a[5].passState.viewport=e}else 1===n?(t=T["a"].maximumTextureSize>=t?t:T["a"].maximumTextureSize,s.x=t,s.y=t,a[0].passState.viewport=new i["a"](0,0,t,t)):4===n&&(t=T["a"].maximumTextureSize>=2*t?t:T["a"].maximumTextureSize/2,s.x=2*t,s.y=2*t,a[0].passState.viewport=new i["a"](0,0,t,t),a[1].passState.viewport=new i["a"](t,0,t,t),a[2].passState.viewport=new i["a"](0,t,t,t),a[3].passState.viewport=new i["a"](t,t,t,t));e._clearPassState.viewport=new i["a"](0,0,s.x,s.y);for(let i=0;i<n;++i){const e=a[i],t=e.passState.viewport,n=t.x/s.x,o=t.y/s.y,r=t.width/s.x,c=t.height/s.y;e.textureOffsets=new b["a"](r,0,0,n,0,c,0,o,0,0,1,0,0,0,0,1)}}Q.MAXIMUM_DISTANCE=2e4,Q.prototype.debugCreateRenderStates=function(){J(this)},Object.defineProperties(Q.prototype,{enabled:{get:function(){return this._enabled},set:function(e){this.dirty=this._enabled!==e,this._enabled=e}},normalOffset:{get:function(){return this._normalOffset},set:function(e){this.dirty=this._normalOffset!==e,this._normalOffset=e,this._terrainBias.normalOffset=e,this._primitiveBias.normalOffset=e,this._pointBias.normalOffset=e}},softShadows:{get:function(){return this._softShadows},set:function(e){this.dirty=this._softShadows!==e,this._softShadows=e}},size:{get:function(){return this._size},set:function(e){ce(this,e)}},outOfView:{get:function(){return this._outOfView}},shadowMapCullingVolume:{get:function(){return this._shadowMapCullingVolume}},passes:{get:function(){return this._passes}},isPointLight:{get:function(){return this._isPointLight}},debugCascadeColors:{get:function(){return this._debugCascadeColors},set:function(e){this.dirty=this._debugCascadeColors!==e,this._debugCascadeColors=e}}});const ue=new i["a"];function he(e,t){let a;a=e._isPointLight?"uniform samplerCube shadowMap_textureCube; \nvarying vec2 v_textureCoordinates; \nvoid main() \n{ \n    vec2 uv = v_textureCoordinates; \n    vec3 dir; \n \n    if (uv.y < 0.5) \n    { \n        if (uv.x < 0.333) \n        { \n            dir.x = -1.0; \n            dir.y = uv.x * 6.0 - 1.0; \n            dir.z = uv.y * 4.0 - 1.0; \n        } \n        else if (uv.x < 0.666) \n        { \n            dir.y = -1.0; \n            dir.x = uv.x * 6.0 - 3.0; \n            dir.z = uv.y * 4.0 - 1.0; \n        } \n        else \n        { \n            dir.z = -1.0; \n            dir.x = uv.x * 6.0 - 5.0; \n            dir.y = uv.y * 4.0 - 1.0; \n        } \n    } \n    else \n    { \n        if (uv.x < 0.333) \n        { \n            dir.x = 1.0; \n            dir.y = uv.x * 6.0 - 1.0; \n            dir.z = uv.y * 4.0 - 3.0; \n        } \n        else if (uv.x < 0.666) \n        { \n            dir.y = 1.0; \n            dir.x = uv.x * 6.0 - 3.0; \n            dir.z = uv.y * 4.0 - 3.0; \n        } \n        else \n        { \n            dir.z = 1.0; \n            dir.x = uv.x * 6.0 - 5.0; \n            dir.y = uv.y * 4.0 - 3.0; \n        } \n    } \n \n    float shadow = czm_unpackDepth(textureCube(shadowMap_textureCube, dir)); \n    gl_FragColor = vec4(vec3(shadow), 1.0); \n} \n":`uniform sampler2D shadowMap_texture; \nvarying vec2 v_textureCoordinates; \nvoid main() \n{ \n${e._usesDepthTexture?"    float shadow = texture2D(shadowMap_texture, v_textureCoordinates).r; \n":"    float shadow = czm_unpackDepth(texture2D(shadowMap_texture, v_textureCoordinates)); \n"}    gl_FragColor = vec4(vec3(shadow), 1.0); \n} \n`;const i=t.createViewportQuadCommand(a,{uniformMap:{shadowMap_texture:function(){return e._shadowMapTexture},shadowMap_textureCube:function(){return e._shadowMapTexture}}});return i.pass=z["a"].OVERLAY,i}function de(e,t){const a=t.context,n=t.context.drawingBufferWidth,s=t.context.drawingBufferHeight,o=.3*Math.min(n,s),r=ue;r.x=n-o,r.y=0,r.width=o,r.height=o;let c=e._debugShadowViewCommand;Object(f["a"])(c)||(c=he(e,a),e._debugShadowViewCommand=c),Object(f["a"])(c.renderState)&&i["a"].equals(c.renderState.viewport,r)||(c.renderState=V["a"].fromCache({viewport:i["a"].clone(r)})),t.commandList.push(e._debugShadowViewCommand)}const me=new Array(8);me[0]=new c["a"](-1,-1,-1,1),me[1]=new c["a"](1,-1,-1,1),me[2]=new c["a"](1,1,-1,1),me[3]=new c["a"](-1,1,-1,1),me[4]=new c["a"](-1,-1,1,1),me[5]=new c["a"](1,-1,1,1),me[6]=new c["a"](1,1,1,1),me[7]=new c["a"](-1,1,1,1);const le=new b["a"],pe=new Array(8);for(let ke=0;ke<8;++ke)pe[ke]=new c["a"];function _e(e,t){const a=new C["a"]({geometry:new s["a"]({minimum:new r["a"](-.5,-.5,-.5),maximum:new r["a"](.5,.5,.5)}),attributes:{color:m["a"].fromColor(t)}}),i=new C["a"]({geometry:new M["a"]({radius:.5}),attributes:{color:m["a"].fromColor(t)}});return new G["a"]({geometryInstances:[a,i],appearance:new k["a"]({translucent:!1,flat:!0}),asynchronous:!1,modelMatrix:e})}const fe=[d["a"].RED,d["a"].GREEN,d["a"].BLUE,d["a"].MAGENTA],we=new r["a"];function ge(e,t){de(e,t);const a=e.debugFreezeFrame&&!e._debugFreezeFrame;if(e._debugFreezeFrame=e.debugFreezeFrame,e.debugFreezeFrame&&(a&&(e._debugCameraFrustum=e._debugCameraFrustum&&e._debugCameraFrustum.destroy(),e._debugCameraFrustum=new q["a"]({camera:e._sceneCamera,color:d["a"].CYAN,updateOnChange:!1})),e._debugCameraFrustum.update(t)),e._cascadesEnabled){if(e.debugFreezeFrame){a&&(e._debugLightFrustum=e._debugLightFrustum&&e._debugLightFrustum.destroy(),e._debugLightFrustum=new q["a"]({camera:e._shadowMapCamera,color:d["a"].YELLOW,updateOnChange:!1})),e._debugLightFrustum.update(t);for(let i=0;i<e._numberOfCascades;++i)a&&(e._debugCascadeFrustums[i]=e._debugCascadeFrustums[i]&&e._debugCascadeFrustums[i].destroy(),e._debugCascadeFrustums[i]=new q["a"]({camera:e._passes[i].camera,color:fe[i],updateOnChange:!1})),e._debugCascadeFrustums[i].update(t)}}else if(e._isPointLight){if(!Object(f["a"])(e._debugLightFrustum)||e._needsUpdate){const t=e._shadowMapCamera.positionWC,a=O["a"].IDENTITY,i=2*e._pointLightRadius,n=r["a"].fromElements(i,i,i,we),s=b["a"].fromTranslationQuaternionRotationScale(t,a,n,le);e._debugLightFrustum=e._debugLightFrustum&&e._debugLightFrustum.destroy(),e._debugLightFrustum=_e(s,d["a"].YELLOW)}e._debugLightFrustum.update(t)}else Object(f["a"])(e._debugLightFrustum)&&!e._needsUpdate||(e._debugLightFrustum=new q["a"]({camera:e._shadowMapCamera,color:d["a"].YELLOW,updateOnChange:!1})),e._debugLightFrustum.update(t)}function Ce(){this.viewMatrix=new b["a"],this.inverseViewMatrix=new b["a"],this.frustum=void 0,this.positionCartographic=new u["a"],this.positionWC=new r["a"],this.directionWC=r["a"].clone(r["a"].UNIT_Z),this.upWC=r["a"].clone(r["a"].UNIT_Y),this.rightWC=r["a"].clone(r["a"].UNIT_X),this.viewProjectionMatrix=new b["a"]}Ce.prototype.clone=function(e){b["a"].clone(e.viewMatrix,this.viewMatrix),b["a"].clone(e.inverseViewMatrix,this.inverseViewMatrix),this.frustum=e.frustum.clone(this.frustum),u["a"].clone(e.positionCartographic,this.positionCartographic),r["a"].clone(e.positionWC,this.positionWC),r["a"].clone(e.directionWC,this.directionWC),r["a"].clone(e.upWC,this.upWC),r["a"].clone(e.rightWC,this.rightWC)};const Se=new b["a"](.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1);Ce.prototype.getViewProjection=function(){const e=this.viewMatrix,t=this.frustum.projectionMatrix;return b["a"].multiply(t,e,this.viewProjectionMatrix),b["a"].multiply(Se,this.viewProjectionMatrix,this.viewProjectionMatrix),this.viewProjectionMatrix};const xe=new Array(5),be=new y["a"],Ee=new Array(4),ye=new r["a"],ve=new r["a"];function Oe(e,t){const a=e._shadowMapCamera,i=e._sceneCamera,n=i.frustum.near,s=i.frustum.far,o=e._numberOfCascades;let u;const h=s-n,d=s/n;let m=.9,l=!1;t.shadowState.closestObjectSize<200&&(l=!0,m=.9);const p=Ee,_=xe;for(_[0]=n,_[o]=s,u=0;u<o;++u){const e=(u+1)/o,t=n*Math.pow(d,e),a=n+h*e,i=x["a"].lerp(a,t,m);_[u+1]=i,p[u]=i-_[u]}if(l){for(u=0;u<o;++u)p[u]=Math.min(p[u],e._maximumCascadeDistances[u]);let t=_[0];for(u=0;u<o-1;++u)t+=p[u],_[u+1]=t}c["a"].unpack(_,0,e._cascadeSplits[0]),c["a"].unpack(_,1,e._cascadeSplits[1]),c["a"].unpack(p,0,e._cascadeDistances);const f=a.frustum,w=f.left,g=f.right,C=f.bottom,S=f.top,E=f.near,y=f.far,v=a.positionWC,O=a.directionWC,M=a.upWC,P=i.frustum.clone(be),A=a.getViewProjection();for(u=0;u<o;++u){P.near=_[u],P.far=_[u+1];const t=b["a"].multiply(P.projectionMatrix,i.viewMatrix,le),n=b["a"].inverse(t,le),s=b["a"].multiply(A,n,le),o=r["a"].fromElements(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE,ye),h=r["a"].fromElements(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE,ve);for(let e=0;e<8;++e){const t=c["a"].clone(me[e],pe[e]);b["a"].multiplyByVector(s,t,t),r["a"].divideByScalar(t,t.w,t),r["a"].minimumByComponent(t,o,o),r["a"].maximumByComponent(t,h,h)}o.x=Math.max(o.x,0),o.y=Math.max(o.y,0),o.z=0,h.x=Math.min(h.x,1),h.y=Math.min(h.y,1),h.z=Math.min(h.z,1);const d=e._passes[u],m=d.camera;m.clone(a);const l=m.frustum;l.left=w+o.x*(g-w),l.right=w+h.x*(g-w),l.bottom=C+o.y*(S-C),l.top=C+h.y*(S-C),l.near=E+o.z*(y-E),l.far=E+h.z*(y-E),d.cullingVolume=m.frustum.computeCullingVolume(v,O,M);const p=e._cascadeMatrices[u];b["a"].multiply(m.getViewProjection(),i.inverseViewMatrix,p),b["a"].multiply(d.textureOffsets,p,p)}}const Me=new b["a"],Pe=new r["a"],Ae=new r["a"],Te=new r["a"];function De(e,t){const a=e._shadowMapCamera,i=e._sceneCamera,n=b["a"].multiply(i.frustum.projectionMatrix,i.viewMatrix,le),s=b["a"].inverse(n,le),o=a.directionWC;let u=i.directionWC;r["a"].equalsEpsilon(o,u,x["a"].EPSILON10)&&(u=i.upWC);const h=r["a"].cross(o,u,Pe);u=r["a"].cross(h,o,Ae),r["a"].normalize(u,u),r["a"].normalize(h,h);const d=r["a"].fromElements(0,0,0,Te);let m=b["a"].computeView(d,o,u,h,Me);const l=b["a"].multiply(m,s,le),p=r["a"].fromElements(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE,ye),_=r["a"].fromElements(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE,ve);for(let x=0;x<8;++x){const e=c["a"].clone(me[x],pe[x]);b["a"].multiplyByVector(l,e,e),r["a"].divideByScalar(e,e.w,e),r["a"].minimumByComponent(e,p,p),r["a"].maximumByComponent(e,_,_)}_.z+=1e3,p.z-=10;const f=Te;f.x=-.5*(p.x+_.x),f.y=-.5*(p.y+_.y),f.z=-_.z;const w=b["a"].fromTranslation(f,le);m=b["a"].multiply(w,m,m);const g=.5*(_.x-p.x),C=.5*(_.y-p.y),S=_.z-p.z,E=a.frustum;E.left=-g,E.right=g,E.bottom=-C,E.top=C,E.near=.01,E.far=S,b["a"].clone(m,a.viewMatrix),b["a"].inverse(m,a.inverseViewMatrix),b["a"].getTranslation(a.inverseViewMatrix,a.positionWC),t.mapProjection.ellipsoid.cartesianToCartographic(a.positionWC,a.positionCartographic),r["a"].clone(o,a.directionWC),r["a"].clone(u,a.upWC),r["a"].clone(h,a.rightWC)}const Le=[new r["a"](-1,0,0),new r["a"](0,-1,0),new r["a"](0,0,-1),new r["a"](1,0,0),new r["a"](0,1,0),new r["a"](0,0,1)],Ne=[new r["a"](0,-1,0),new r["a"](0,0,-1),new r["a"](0,-1,0),new r["a"](0,-1,0),new r["a"](0,0,1),new r["a"](0,-1,0)],ze=[new r["a"](0,0,1),new r["a"](1,0,0),new r["a"](-1,0,0),new r["a"](0,0,-1),new r["a"](1,0,0),new r["a"](1,0,0)];function Fe(e,t){const a=new y["a"];a.fov=x["a"].PI_OVER_TWO,a.near=1,a.far=e._pointLightRadius,a.aspectRatio=1;for(let i=0;i<6;++i){const n=e._passes[i].camera;n.positionWC=e._shadowMapCamera.positionWC,n.positionCartographic=t.mapProjection.ellipsoid.cartesianToCartographic(n.positionWC,n.positionCartographic),n.directionWC=Le[i],n.upWC=Ne[i],n.rightWC=ze[i],b["a"].computeView(n.positionWC,n.directionWC,n.upWC,n.rightWC,n.viewMatrix),b["a"].inverse(n.viewMatrix,n.inverseViewMatrix),n.frustum=a}}const Ie=new r["a"],Re=new r["a"],je=new n["a"],Ve=je.center;function We(e,t){const a=e._sceneCamera,i=e._shadowMapCamera,s=je;if(e._cascadesEnabled){if(a.frustum.near>=e.maximumDistance)return e._outOfView=!0,void(e._needsUpdate=!1);const n=t.mapProjection.ellipsoid.geodeticSurfaceNormal(a.positionWC,Ie),s=r["a"].negate(i.directionWC,Re),o=r["a"].dot(n,s);if(e.fadingEnabled){const t=x["a"].clamp(o/.1,0,1);e._darkness=x["a"].lerp(1,e.darkness,t)}else e._darkness=e.darkness;if(o<0)return e._outOfView=!0,void(e._needsUpdate=!1);e._needsUpdate=!0,e._outOfView=!1}else if(e._isPointLight)s.center=i.positionWC,s.radius=e._pointLightRadius,e._outOfView=t.cullingVolume.computeVisibility(s)===S["a"].OUTSIDE,e._needsUpdate=!e._outOfView&&!e._boundingSphere.equals(s),n["a"].clone(s,e._boundingSphere);else{const a=i.frustum.far/2,o=r["a"].add(i.positionWC,r["a"].multiplyByScalar(i.directionWC,a,Ve),Ve);s.center=o,s.radius=a,e._outOfView=t.cullingVolume.computeVisibility(s)===S["a"].OUTSIDE,e._needsUpdate=!e._outOfView&&!e._boundingSphere.equals(s),n["a"].clone(s,e._boundingSphere)}}function Be(e,t){const a=t.camera,i=e._lightCamera,n=e._sceneCamera,s=e._shadowMapCamera;e._cascadesEnabled?r["a"].clone(i.directionWC,s.directionWC):e._isPointLight?r["a"].clone(i.positionWC,s.positionWC):s.clone(i);const o=e._lightDirectionEC;let c,u;b["a"].multiplyByPointAsVector(a.viewMatrix,s.directionWC,o),r["a"].normalize(o,o),r["a"].negate(o,o),b["a"].multiplyByPoint(a.viewMatrix,s.positionWC,e._lightPositionEC),e._lightPositionEC.w=e._pointLightRadius,e._fitNearFar?(c=Math.min(t.shadowState.nearPlane,e.maximumDistance),u=Math.min(t.shadowState.farPlane,e.maximumDistance),u=Math.max(u,c+1)):(c=a.frustum.near,u=e.maximumDistance),e._sceneCamera=U["a"].clone(a,n),a.frustum.clone(e._sceneCamera.frustum),e._sceneCamera.frustum.near=c,e._sceneCamera.frustum.far=u,e._distance=u-c,We(e,t),!e._outOfViewPrevious&&e._outOfView&&(e._needsUpdate=!0),e._outOfViewPrevious=e._outOfView}Q.prototype.update=function(e){if(Be(this,e),this._needsUpdate)if(oe(this,e.context),this._isPointLight&&Fe(this,e),this._cascadesEnabled&&(De(this,e),this._numberOfCascades>1&&Oe(this,e)),this._isPointLight)this._shadowMapCullingVolume=p["a"].fromBoundingSphere(this._boundingSphere);else{const e=this._shadowMapCamera,t=e.positionWC,a=e.directionWC,i=e.upWC;this._shadowMapCullingVolume=e.frustum.computeCullingVolume(t,a,i),1===this._passes.length&&this._passes[0].camera.clone(e)}if(1===this._passes.length){const e=this._sceneCamera.inverseViewMatrix;b["a"].multiply(this._shadowMapCamera.getViewProjection(),e,this._shadowMapMatrix)}this.debugShow&&ge(this,e)},Q.prototype.updatePass=function(e,t){re(this,e,t)};const Ue=new o["a"];function He(e,t,a){const i=e._isPointLight?e._pointBias:a?e._terrainBias:e._primitiveBias,n={shadowMap_texture:function(){return e._shadowMapTexture},shadowMap_textureCube:function(){return e._shadowMapTexture},shadowMap_matrix:function(){return e._shadowMapMatrix},shadowMap_cascadeSplits:function(){return e._cascadeSplits},shadowMap_cascadeMatrices:function(){return e._cascadeMatrices},shadowMap_lightDirectionEC:function(){return e._lightDirectionEC},shadowMap_lightPositionEC:function(){return e._lightPositionEC},shadowMap_cascadeDistances:function(){return e._cascadeDistances},shadowMap_texelSizeDepthBiasAndNormalShadingSmooth:function(){const t=Ue;return t.x=1/e._textureSize.x,t.y=1/e._textureSize.y,c["a"].fromElements(t.x,t.y,i.depthBias,i.normalShadingSmooth,this.combinedUniforms1)},shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness:function(){return c["a"].fromElements(i.normalOffsetScale,e._distance,e.maximumDistance,e._darkness,this.combinedUniforms2)},combinedUniforms1:new c["a"],combinedUniforms2:new c["a"]};return Object(l["a"])(t,n,!1)}function qe(e,t,a,i,n,s){let o,r,c;if(Object(f["a"])(s)&&(o=s.shaderProgram,r=s.renderState,c=s.uniformMap),s=L["a"].shallowClone(a,s),s.castShadows=!0,s.receiveShadows=!1,!Object(f["a"])(o)||n!==a.shaderProgram.id||t){const t=a.shaderProgram,n=a.pass===z["a"].GLOBE,s=a.pass!==z["a"].TRANSLUCENT,u=e._isPointLight,d=e._usesDepthTexture,m=$.getShadowCastShaderKeyword(u,n,d,s);if(o=i.shaderCache.getDerivedShaderProgram(t,m),!Object(f["a"])(o)){const e=t.vertexShaderSource,a=t.fragmentShaderSource,r=$.createShadowCastVertexShader(e,u,n),c=$.createShadowCastFragmentShader(a,u,d,s);o=i.shaderCache.createDerivedShaderProgram(t,m,{vertexShaderSource:r,fragmentShaderSource:c,attributeLocations:t._attributeLocations})}r=e._primitiveRenderState,u?r=e._pointRenderState:n&&(r=e._terrainRenderState);const l=a.renderState.cull.enabled;l||(r=Object(h["a"])(r,!1),r.cull=Object(h["a"])(r.cull,!1),r.cull.enabled=!1,r=V["a"].fromCache(r)),c=He(e,a.uniformMap,n)}return s.shaderProgram=o,s.renderState=r,s.uniformMap=c,s}Q.createReceiveDerivedCommand=function(e,t,a,i,n){Object(f["a"])(n)||(n={});const s=e.length>0,o=t.shaderProgram,r=o.vertexShaderSource,c=o.fragmentShaderSource,u=t.pass===z["a"].GLOBE;let h=!1;if(u&&(h=t.owner.data.renderedMesh.encoding.hasVertexNormals),t.receiveShadows&&s){let s,d;Object(f["a"])(n.receiveCommand)&&(s=n.receiveCommand.shaderProgram,d=n.receiveCommand.uniformMap),n.receiveCommand=L["a"].shallowClone(t,n.receiveCommand),n.castShadows=!1,n.receiveShadows=!0;const m=n.receiveShaderCastShadows!==t.castShadows,l=n.receiveShaderProgramId!==t.shaderProgram.id;if(!Object(f["a"])(s)||l||a||m){const a=$.getShadowReceiveShaderKeyword(e[0],t.castShadows,u,h);if(s=i.shaderCache.getDerivedShaderProgram(o,a),!Object(f["a"])(s)){const n=$.createShadowReceiveVertexShader(r,u,h),d=$.createShadowReceiveFragmentShader(c,e[0],t.castShadows,u,h);s=i.shaderCache.createDerivedShaderProgram(o,a,{vertexShaderSource:n,fragmentShaderSource:d,attributeLocations:o._attributeLocations})}d=He(e[0],t.uniformMap,u)}n.receiveCommand.shaderProgram=s,n.receiveCommand.uniformMap=d,n.receiveShaderProgramId=t.shaderProgram.id,n.receiveShaderCastShadows=t.castShadows}return n},Q.createCastDerivedCommand=function(e,t,a,i,n){if(Object(f["a"])(n)||(n={}),t.castShadows){let s=n.castCommands;Object(f["a"])(s)||(s=n.castCommands=[]);const o=n.castShaderProgramId,r=e.length;s.length=r;for(let n=0;n<r;++n)s[n]=qe(e[n],a,t,i,o,s[n]);n.castShaderProgramId=t.shaderProgram.id}return n},Q.prototype.isDestroyed=function(){return!1},Q.prototype.destroy=function(){ee(this),this._debugLightFrustum=this._debugLightFrustum&&this._debugLightFrustum.destroy(),this._debugCameraFrustum=this._debugCameraFrustum&&this._debugCameraFrustum.destroy(),this._debugShadowViewCommand=this._debugShadowViewCommand&&this._debugShadowViewCommand.shaderProgram&&this._debugShadowViewCommand.shaderProgram.destroy();for(let e=0;e<this._numberOfCascades;++e)this._debugCascadeFrustums[e]=this._debugCascadeFrustums[e]&&this._debugCascadeFrustums[e].destroy();return Object(w["a"])(this)};t["a"]=Q},a098:function(e,t,a){"use strict";var i=a("b482"),n=a("be18"),s=a("535a"),o=a("2f63"),r=a("7d62"),c=a("c1e2"),u=a("52f0"),h=a("0541"),d=a("8b68"),m=a("9ab9"),l=a("a894"),p=a("b0b5"),_=a("6dc0"),f=a("e90c"),w=a("5770"),g=a("7c5e"),C=a("8167"),S=a("688e"),x=a("b7c8"),b=a("a307");function E(e){this.sources=e.sources,this._sources=void 0,this.show=Object(s["a"])(e.show,!0),this._command=new l["a"]({modelMatrix:u["a"].clone(u["a"].IDENTITY),owner:this}),this._cubeMap=void 0,this._attributeLocations=void 0,this._useHdr=void 0}E.prototype.update=function(e,t){const a=this;if(!this.show)return;if(e.mode!==b["a"].SCENE3D&&e.mode!==b["a"].MORPHING)return;if(!e.passes.render)return;const s=e.context;if(this._sources!==this.sources){this._sources=this.sources;const e=this.sources;"string"===typeof e.positiveX?Object(p["a"])(s,this._sources).then((function(e){a._cubeMap=a._cubeMap&&a._cubeMap.destroy(),a._cubeMap=e})):(this._cubeMap=this._cubeMap&&this._cubeMap.destroy(),this._cubeMap=new m["a"]({context:s,source:e}))}const r=this._command;if(!Object(o["a"])(r.vertexArray)){r.uniformMap={u_cubeMap:function(){return a._cubeMap}};const e=i["a"].createGeometry(i["a"].fromDimensions({dimensions:new n["a"](2,2,2),vertexFormat:h["a"].POSITION_ONLY})),t=this._attributeLocations=c["a"].createAttributeLocations(e);r.vertexArray=g["a"].fromGeometry({context:s,geometry:e,attributeLocations:t,bufferUsage:d["a"].STATIC_DRAW}),r.renderState=_["a"].fromCache({blending:x["a"].ALPHA_BLEND})}if(!Object(o["a"])(r.shaderProgram)||this._useHdr!==t){const e=new w["a"]({defines:[t?"HDR":""],sources:[C["a"]]});r.shaderProgram=f["a"].fromCache({context:s,vertexShaderSource:S["a"],fragmentShaderSource:e,attributeLocations:this._attributeLocations}),this._useHdr=t}return Object(o["a"])(this._cubeMap)?r:void 0},E.prototype.isDestroyed=function(){return!1},E.prototype.destroy=function(){const e=this._command;return e.vertexArray=e.vertexArray&&e.vertexArray.destroy(),e.shaderProgram=e.shaderProgram&&e.shaderProgram.destroy(),this._cubeMap=this._cubeMap&&this._cubeMap.destroy(),Object(r["a"])(this)},t["a"]=E},a12c:function(e,t,a){"use strict";var i=a("be18"),n=a("535a"),s=a("2f63"),o=a("7d62"),r=a("c52f"),c=a("6cae"),u=a("c1e2"),h=a("93da"),d=a("52f0"),m=a("0541"),l=a("8b68"),p=a("a894"),_=a("6dc0"),f=a("e90c"),w=a("5770"),g=a("7c5e"),C=a("b0df"),S=a("aeca"),x=a("ef10"),b=a("2a08"),E=a("b08e"),y=a("b7c8"),v=a("29ab"),O=a("a307");function M(e){e=Object(n["a"])(e,r["a"].WGS84),this.show=!0,this.perFragmentAtmosphere=!1,this._ellipsoid=e;const t=1.025,a=i["a"].multiplyByScalar(e.radii,t,new i["a"]);this._scaleMatrix=d["a"].fromScale(a),this._modelMatrix=new d["a"],this._command=new p["a"]({owner:this,modelMatrix:this._modelMatrix}),this._spSkyFromSpace=void 0,this._spSkyFromAtmosphere=void 0,this._flags=void 0,this.atmosphereLightIntensity=50,this.atmosphereRayleighCoefficient=new i["a"](55e-7,13e-6,284e-7),this.atmosphereMieCoefficient=new i["a"](21e-6,21e-6,21e-6),this.atmosphereRayleighScaleHeight=1e4,this.atmosphereMieScaleHeight=3200,this.atmosphereMieAnisotropy=.9,this.hueShift=0,this.saturationShift=0,this.brightnessShift=0,this._hueSaturationBrightness=new i["a"];const s=new i["a"];s.x=e.maximumRadius*t,s.y=e.maximumRadius,s.z=0,this._radiiAndDynamicAtmosphereColor=s;const o=this;this._command.uniformMap={u_radiiAndDynamicAtmosphereColor:function(){return o._radiiAndDynamicAtmosphereColor},u_hsbShift:function(){return o._hueSaturationBrightness.x=o.hueShift,o._hueSaturationBrightness.y=o.saturationShift,o._hueSaturationBrightness.z=o.brightnessShift,o._hueSaturationBrightness},u_atmosphereLightIntensity:function(){return o.atmosphereLightIntensity},u_atmosphereRayleighCoefficient:function(){return o.atmosphereRayleighCoefficient},u_atmosphereMieCoefficient:function(){return o.atmosphereMieCoefficient},u_atmosphereRayleighScaleHeight:function(){return o.atmosphereRayleighScaleHeight},u_atmosphereMieScaleHeight:function(){return o.atmosphereMieScaleHeight},u_atmosphereMieAnisotropy:function(){return o.atmosphereMieAnisotropy}}}Object.defineProperties(M.prototype,{ellipsoid:{get:function(){return this._ellipsoid}}}),M.prototype.setDynamicAtmosphereColor=function(e,t){const a=e?t?2:1:0;this._radiiAndDynamicAtmosphereColor.z=a};const P=new d["a"];function A(e){return!(h["a"].equalsEpsilon(e.hueShift,0,h["a"].EPSILON7)&&h["a"].equalsEpsilon(e.saturationShift,0,h["a"].EPSILON7)&&h["a"].equalsEpsilon(e.brightnessShift,0,h["a"].EPSILON7))}M.prototype.update=function(e,t){if(!this.show)return;const a=e.mode;if(a!==O["a"].SCENE3D&&a!==O["a"].MORPHING)return;if(!e.passes.render)return;const n=d["a"].fromRotationTranslation(e.context.uniformState.inverseViewRotation,i["a"].ZERO,P),o=d["a"].multiplyTransformation(n,E["a"].Y_UP_TO_Z_UP,P),r=d["a"].multiply(this._scaleMatrix,o,P);d["a"].clone(r,this._modelMatrix);const h=e.context,p=A(this),M=e.globeTranslucencyState.translucent,T=this.perFragmentAtmosphere||M||!Object(s["a"])(t)||!t.show,D=this._command;if(!Object(s["a"])(D.vertexArray)){const e=c["a"].createGeometry(new c["a"]({radii:new i["a"](1,1,1),slicePartitions:256,stackPartitions:256,vertexFormat:m["a"].POSITION_ONLY}));D.vertexArray=g["a"].fromGeometry({context:h,geometry:e,attributeLocations:u["a"].createAttributeLocations(e),bufferUsage:l["a"].STATIC_DRAW}),D.renderState=_["a"].fromCache({cull:{enabled:!0,face:v["a"].FRONT},blending:y["a"].ALPHA_BLEND,depthMask:!1})}const L=p|T<<2|M<<3;if(L!==this._flags){this._flags=L;const e=[];p&&e.push("COLOR_CORRECT"),T&&e.push("PER_FRAGMENT_ATMOSPHERE"),M&&e.push("GLOBE_TRANSLUCENT");const t=new w["a"]({defines:e,sources:[C["a"],S["a"],b["a"]]}),a=new w["a"]({defines:e,sources:[C["a"],S["a"],x["a"]]});this._spSkyAtmosphere=f["a"].fromCache({context:h,vertexShaderSource:t,fragmentShaderSource:a}),D.shaderProgram=this._spSkyAtmosphere}return D},M.prototype.isDestroyed=function(){return!1},M.prototype.destroy=function(){const e=this._command;return e.vertexArray=e.vertexArray&&e.vertexArray.destroy(),this._spSkyAtmosphere=this._spSkyAtmosphere&&this._spSkyAtmosphere.destroy(),Object(o["a"])(this)},t["a"]=M},b85d:function(e,t,a){"use strict";var i=a("8dfe"),n=a("535a"),s=a("2f63"),o=a("21d7"),r=a("5d5c"),c=a("eace"),u=a("d4ed"),h=a("283e"),d=a("a89b"),m=a("64ac");function l(e){e=Object(n["a"])(e,n["a"].EMPTY_OBJECT),this.defaultAlpha=void 0,this.defaultNightAlpha=void 0,this.defaultDayAlpha=void 0,this.defaultBrightness=void 0,this.defaultContrast=void 0,this.defaultHue=void 0,this.defaultSaturation=void 0,this.defaultGamma=void 0,this.defaultMinificationFilter=void 0,this.defaultMagnificationFilter=void 0;const t=u["a"].createIfNeeded(e.url),a=Object(n["a"])(e.rectangle,c["a"].MAX_VALUE),s=new r["a"]({rectangle:a,numberOfLevelZeroTilesX:1,numberOfLevelZeroTilesY:1,ellipsoid:e.ellipsoid});this._tilingScheme=s,this._resource=t,this._image=void 0,this._texture=void 0,this._tileWidth=0,this._tileHeight=0,this._errorEvent=new o["a"],this._ready=!1;let l=e.credit;"string"===typeof l&&(l=new i["a"](l)),this._credit=l;const p=this;let _;function f(e){return p._image=e,p._tileWidth=e.width,p._tileHeight=e.height,p._ready=!0,d["a"].reportSuccess(p._errorEvent),Promise.resolve(!0)}function w(e){const a=`Failed to load image ${t.url}.`;return _=d["a"].reportError(_,p,p._errorEvent,a,0,0,0),_.retry?g():Promise.reject(new h["a"](a))}function g(){return m["a"].loadImage(null,t).then(f).catch(w)}this._readyPromise=g()}Object.defineProperties(l.prototype,{url:{get:function(){return this._resource.url}},proxy:{get:function(){return this._resource.proxy}},tileWidth:{get:function(){return this._tileWidth}},tileHeight:{get:function(){return this._tileHeight}},maximumLevel:{get:function(){return 0}},minimumLevel:{get:function(){return 0}},tilingScheme:{get:function(){return this._tilingScheme}},rectangle:{get:function(){return this._tilingScheme.rectangle}},tileDiscardPolicy:{get:function(){}},errorEvent:{get:function(){return this._errorEvent}},ready:{get:function(){return this._ready}},readyPromise:{get:function(){return this._readyPromise}},credit:{get:function(){return this._credit}},hasAlphaChannel:{get:function(){return!0}}}),l.prototype.getTileCredits=function(e,t,a){},l.prototype.requestImage=function(e,t,a,i){if(Object(s["a"])(this._image))return Promise.resolve(this._image)},l.prototype.pickFeatures=function(e,t,a,i,n){},t["a"]=l},c86b:function(e,t,a){"use strict";const i={DISABLED:0,ENABLED:1,CAST_ONLY:2,RECEIVE_ONLY:3,NUMBER_OF_SHADOW_MODES:4,castShadows:function(e){return e===i.ENABLED||e===i.CAST_ONLY},receiveShadows:function(e){return e===i.ENABLED||e===i.RECEIVE_ONLY},fromCastReceive:function(e,t){return e&&t?i.ENABLED:e?i.CAST_ONLY:t?i.RECEIVE_ONLY:i.DISABLED}};t["a"]=Object.freeze(i)}}]);